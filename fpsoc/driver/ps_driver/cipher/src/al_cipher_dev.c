/*
 * Copyright (c) 2023, Anlogic Inc. and Contributors. All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

/***************************** Include Files *********************************/
#include "al_cipher_dev.h"
#include <stdio.h>
/************************** Constant Definitions *****************************/
/* big endian */
const AL_CIPHER_EcCurveStruct Sm2Curve = {.A = {0xFFFFFFFC, 0xFFFFFFFF, 0x00000000, 0xFFFFFFFF, \
                                                0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFE}, \
                                          .B = {0x4D940E93, 0xDDBCBD41, 0x15AB8F92, 0xF39789F5, \
                                                0xCF6509A7, 0x4D5A9E4B, 0x9D9F5E34, 0x28E9FA9E}, \
                                          .X = {0x334C74C7, 0x715A4589, 0xF2660BE1, 0x8FE30BBF, \
                                                0x6A39C994, 0x5F990446, 0x1F198119, 0x32C4AE2C}, \
                                          .Y = {0x2139F0A0, 0x02DF32E5, 0xC62A4740, 0xD0A9877C, \
                                                0x6B692153, 0x59BDCEE3, 0xF4F6779C, 0xBC3736A2}};
/**************************** Type Definitions *******************************/

/***************** Macros (Inline Functions) Definitions *********************/
#define AL_CIPHER_MSG_WORD_SIZE 10
#define AL_CIPHER_ACK_WORD_SIZE 2

#define AL_CIPHER_GETZ_HASH_BUF_SIZE 0x200

#define IS_CRYPT_ALGM(Algm)     ((Algm == AL_CIPHER_OPS_CRYPT_AES256) || \
                                 (Algm == AL_CIPHER_OPS_CRYPT_SM4) || \
                                 (Algm == AL_CIPHER_OPS_CRYPT_NONE))

#define IS_VALID_CRYPT_ALGM(Algm)   ((Algm == AL_CIPHER_OPS_CRYPT_AES256) || \
                                     (Algm == AL_CIPHER_OPS_CRYPT_SM4))

#define IS_CRYPT_AES256(Algm)   (Algm == AL_CIPHER_OPS_CRYPT_AES256)

#define IS_CRYPT_SM4(Algm)      (Algm == AL_CIPHER_OPS_CRYPT_SM4)

#define IS_CRYPT_MODE(Mode)     ((Mode == AL_CIPHER_CRYPT_MODE_ECB) || \
                                 (Mode == AL_CIPHER_CRYPT_MODE_CBC))

#define IS_CRYPT_OP(Val)        ((Val == AL_CIPHER_CRYPT_ENC) || \
                                 (Val == AL_CIPHER_CRYPT_DEC))

#define IS_HASH_MODE(Hash)      ((Hash == AL_CIPHER_OPS_HASH_SHA256) || \
                                 (Hash == AL_CIPHER_OPS_HASH_SM3) || \
                                 (Hash == AL_CIPHER_OPS_HASH_NONE))

#define IS_VALID_HASH_MODE(Hash)    ((Hash == AL_CIPHER_OPS_HASH_SHA256) || \
                                     (Hash == AL_CIPHER_OPS_HASH_SM3))

#define IS_HASH_SHA256(Hash)    (Hash == AL_CIPHER_OPS_HASH_SHA256)

#define IS_HASH_SM3(Hash)       (Hash == AL_CIPHER_OPS_HASH_SM3)

#define IS_HASH_BLK_MODE(Mode)  ((Mode == AL_CIPHER_BLK_WHOLE) || \
                                 (Mode == AL_CIPHER_BLK_FIRST) || \
                                 (Mode == AL_CIPHER_BLK_LAST) || \
                                 (Mode == AL_CIPHER_BLK_MID))

#define IS_KEY_SEL(Key)         ((Key == AL_CIPHER_KEY_BHDR) || \
                                 (Key == AL_CIPHER_KEY_USER))

#define IS_AUTH_MODE(Auth)      ((Auth == AL_CIPHER_OPS_AUTH_ECC256) || \
                                 (Auth == AL_CIPHER_OPS_AUTH_SM2))

#define IS_SIGN_MODE(Sign)      ((Sign == AL_CIPHER_OPS_AUTH_ECC256) || \
                                 (Sign == AL_CIPHER_OPS_AUTH_SM2))

#define IS_GENKEY_MODE(Key)     ((Key == AL_CIPHER_OPS_AUTH_ECC256) || \
                                 (Key == AL_CIPHER_OPS_AUTH_SM2))

#define IS_DATA_ALIGN(Length)   (!(Length % AL_CIPHER_DATA_ALIGN_SIZE))

#define AL_CIPHER_MEMSET    memset

#define AL_CIPHER_MEMCPY    memcpy

/************************** Variable Definitions *****************************/
/* Hardware config generated by TD */
extern AL_CIPHER_HwConfigStruct AlCipher_HwConfig[];

/************************** Function Prototypes ******************************/

/************************** Function Definitions ******************************/
/**
 * This function look up hardware config structure
 * @param   DeviceId is hardware module id
 * @return  hardware config structure with AL_CIPHER_HwConfigStruct
 * @note
*/
AL_CIPHER_HwConfigStruct *AlCipher_Dev_LookupConfig(AL_U32 DeviceId)
{
    AL_U32 Index;
    AL_CIPHER_HwConfigStruct *CfgPtr = AL_NULL;

    for (Index = 0; Index < AL_CIPHER_NUM_INSTANCE; Index++) {
        if (AlCipher_HwConfig[Index].DeviceId == DeviceId) {
            CfgPtr = &AlCipher_HwConfig[Index];
            break;
        }
    }

    return CfgPtr;
}

/**
 * This function get module status
 * @param   Dev is pointer to AL_CIPHER_DevStruct
 * @param   State is enum to AL_CIPHER_StateEnum
 * @return  is this state active or not
 * @note
*/
AL_BOOL AlCipher_Dev_GetState(AL_CIPHER_DevStruct *Dev, AL_CIPHER_StateEnum State)
{
    return ((Dev->State & State) ? AL_TRUE : AL_FALSE);
}

/**
 * This function set module status
 * @param   Dev is pointer to AL_CIPHER_DevStruct
 * @param   State is enum to AL_CIPHER_StateEnum
 * @return
 * @note
*/
AL_VOID AlCipher_Dev_SetState(AL_CIPHER_DevStruct *Dev, AL_CIPHER_StateEnum State)
{
    Dev->State |= State;
}

/**
 * This function clr module status
 * @param   Dev is pointer to AL_CIPHER_DevStruct
 * @param   State is enum to AL_CIPHER_StateEnum
 * @return
 * @note
*/
AL_VOID AlCipher_Dev_ClrState(AL_CIPHER_DevStruct *Dev, AL_CIPHER_StateEnum State)
{
    Dev->State &= ~State;
}

AL_S32 AlCipher_Dev_Init(AL_CIPHER_DevStruct *Dev, AL_CIPHER_HwConfigStruct *HwConfig)
{
    AL_S32 Ret = AL_OK;

    AL_CIPHER_MEMSET(Dev, 0, sizeof(AL_CIPHER_DevStruct));

    Dev->HwConfig = *HwConfig;

    AlCipher_Dev_SetState(Dev, AL_CIPHER_STATE_READY);

    return Ret;
}

/**
 * This function register interrupt call back function
 * @param   Dev is pointer to AL_CIPHER_DevStruct
 * @param   CallBack is call back struct with AL_CAN_CallBackStruct
 * @return
 *          - AL_OK is register correct
 * @note
*/
AL_S32 AlCipher_Dev_RegisterEventCallBack(AL_CIPHER_DevStruct *Dev, AL_CIPHER_CallBackStruct *CallBack)
{
    if (Dev == AL_NULL || CallBack == AL_NULL) {
        return AL_CIPHER_ERR_NULL_PTR;
    }

    if (Dev->EventCallBack.Func != AL_NULL) {

#ifdef CIPHER_DEBUG
        AL_LOG(AL_LOG_LEVEL_WARNING, "cipher=%p duplicate register callback: replace old:%p with New: %p\r\n",
               Dev, Dev->EventCallBack, CallBack);
#endif
    }

    Dev->EventCallBack.Func = CallBack->Func;
    Dev->EventCallBack.Ref  = CallBack->Ref;

    return AL_OK;
}

/**
 * This function unregister interrupt call back function
 * @param   Dev is pointer to AL_CIPHER_DevStruct
 * @return
 *          - AL_OK is unregister correct
 * @note
*/
AL_S32 AlCipher_Dev_UnRegisterEventCallBack(AL_CIPHER_DevStruct *Dev)
{
    if (Dev == AL_NULL) {
        return AL_CIPHER_ERR_NULL_PTR;
    }

    Dev->EventCallBack.Func = (AL_CIPHER_EventCallBack)AL_NULL;

    return AL_OK;
}

static AL_VOID AlCipher_Dev_GetAck(AL_CIPHER_DevStruct *Dev)
{
    AL_U32 *Ack = (AL_U32 *)&Dev->Ack;

    for (AL_U32 i = 0; i < AL_CIPHER_ACK_WORD_SIZE; i++) {
        *(Ack + i) = AlCipher_ll_GetAck(Dev->HwConfig.BaseAddress, i);
    }
}

// AL_S32 AlCipher_Dev_CheckAck(AL_CIPHER_DevStruct *Dev, AL_CIPHER_MsgAckEnum *AckVal)
// {
//     AL_S32 Ret = AL_OK;

//     AlCipher_Dev_GetAck(Dev);

//     if (Dev->Ack.Cmd != AL_CIPHER_CMD_ACK) {
//         return AL_CIPHER_ERR_CMD;
//     }

//     *AckVal = Dev->Ack.Option0.Low;

//     return Ret;
// }

static AL_VOID AlCipher_Dev_AckHandler(AL_CIPHER_DevStruct *Dev)
{
    AL_CIPHER_EventStruct Event = {0};

    AlCipher_Dev_ClrState(Dev, AL_CIPHER_STATE_BUSY);

    AlCipher_Dev_GetAck(Dev);

    Event.EventId = AL_CIPHER_EVENT_DONE;
    if (Dev->Ack.Cmd != AL_CIPHER_CMD_ACK) {
        Event.EventData = AL_CIPHER_ERR_CMD;
    } else {
        Event.EventData = Dev->Ack.Option0.Low;
    }
    Dev->EventCallBack.Func(&Event, Dev->EventCallBack.Ref);
}

/**
 * This function is intr call back
 * @param   Instance is pointer to intr call back reference
 * @return
 * @note
*/
AL_VOID AlCipher_Dev_IntrHandler(AL_VOID *Instance)
{
    AL_CIPHER_DevStruct *Dev = (AL_CIPHER_DevStruct *)Instance;

    AlCipher_Dev_AckHandler(Dev);
}

static AL_VOID AlCipher_Dev_SendMsg(AL_CIPHER_DevStruct *Dev)
{
    AL_U32 *Msg = (AL_U32 *)&Dev->Msg;

    for (AL_U32 i = 0; i < AL_CIPHER_MSG_WORD_SIZE; i++) {
        AlCipher_ll_SetMsg(Dev->HwConfig.BaseAddress, i, *(Msg + i));
    }

    AlCipher_ll_Req(Dev->HwConfig.ReqIntrAddr);
}

static AL_S32 AlCipher_Dev_CryptCheckParams(AL_CIPHER_ConfigUnion *Config)
{
    if (Config->Crypt.InputData == AL_NULL || Config->Crypt.OutputData == AL_NULL) {
        return AL_CIPHER_ERR_NULL_PTR;
    }

    if (!IS_CRYPT_ALGM(Config->Crypt.CryptAlgm)) {
        return AL_CIPHER_ERR_CRYPT_ALGM;
    }

    if (!IS_CRYPT_MODE(Config->Crypt.EcbCbc)) {
        return AL_CIPHER_ERR_CRYPT_MODE;
    }

    if (IS_VALID_CRYPT_ALGM(Config->Crypt.CryptAlgm) &&
        (!IS_CRYPT_OP(Config->Crypt.EncDec))) {
        return AL_CIPHER_ERR_ENCDEC_VALUE;
    }

    //Is hash mode not suit with encrypt method or error
    if ((!IS_CRYPT_AES256(Config->Crypt.CryptAlgm) &&
        IS_HASH_SHA256(Config->Crypt.HashMode)) ||
        (!IS_CRYPT_SM4(Config->Crypt.CryptAlgm) &&
        IS_HASH_SM3(Config->Crypt.HashMode)) ||
        (!IS_HASH_MODE(Config->Crypt.HashMode))) {
        return AL_CIPHER_ERR_HASH_MODE;
    }

    /* Is hash enable with hash out ptr null */
    if ((IS_VALID_HASH_MODE(Config->Crypt.HashMode)) && (Config->Crypt.HashOut == AL_NULL)) {
        return AL_CIPHER_ERR_NULL_PTR;
    }

    //Is key sel error
    if (IS_VALID_CRYPT_ALGM(Config->Crypt.CryptAlgm) &&
        !IS_KEY_SEL(Config->Crypt.KeySel)) {
        return AL_CIPHER_ERR_KEY_MODE;
    }

    //Is IV valid
    if ((Config->Crypt.EcbCbc == AL_CIPHER_CRYPT_MODE_CBC) && (Config->Crypt.Iv == AL_NULL)) {
        return AL_CIPHER_ERR_IV_VALUE;
    }

    //Is key valid
    if ((Config->Crypt.KeySel == AL_CIPHER_KEY_USER) && (Config->Crypt.Key == AL_NULL)) {
        return AL_CIPHER_ERR_KEY_VALUE;
    }

    //Is hash block mode valid
    if (!IS_HASH_BLK_MODE(Config->Crypt.HashBlkMode)) {
        return AL_CIPHER_ERR_BLOCK_MODE;
    }

    //Is dma increase mode valid
    if (!IS_HASH_BLK_MODE(Config->Crypt.DmaIncMode)) {
        return AL_CIPHER_ERR_DMA_INC_MODE;
    }

    //Is data length align
    if (!IS_DATA_ALIGN(Config->Crypt.DataLength)) {
        return AL_CIPHER_ERR_DATA_ALIGN;
    }

    return AL_OK;
}

static AL_VOID AlCipher_Dev_CryptSetParams(AL_CIPHER_DevStruct *Dev, AL_CIPHER_ConfigUnion *Config)
{
    AL_CIPHER_MEMSET(&Dev->Msg, 0, sizeof(AL_CIPHER_MsgStruct));

    Dev->Msg.Cmd                                        = AL_CIPHER_CMD_DMA;
    Dev->Msg.Option0.Low                                = Config->Crypt.CryptAlgm;
    Dev->Msg.Option0.High                               = Config->Crypt.HashMode;
    Dev->Msg.Option1.Low                                = Config->Crypt.KeySel;
    Dev->Msg.Option1.High                               = Config->Crypt.DmaIncMode;
    Dev->Msg.Option1.Extend                             = Config->Crypt.HashBlkMode;
    Dev->Msg.MsgData.DmaParam.CipherParam.OpMode.Reg    = AL_CIPHER_AES_256 | Config->Crypt.EncDec |
                                                          Config->Crypt.EcbCbc;
    Dev->Msg.MsgData.DmaParam.CipherParam.PbInput       = Config->Crypt.InputData;
    Dev->Msg.MsgData.DmaParam.CipherParam.PbOutput      = Config->Crypt.OutputData;
    Dev->Msg.MsgData.DmaParam.CipherParam.TotalLength   = Config->Crypt.DataLength;
    Dev->Msg.MsgData.DmaParam.CipherParam.PbIv          = Config->Crypt.Iv;
    Dev->Msg.MsgData.DmaParam.CipherParam.PbKey         = Config->Crypt.Key;
    Dev->Msg.MsgData.DmaParam.HashOut                   = Config->Crypt.HashOut;
}

static AL_S32 AlCipher_Dev_Crypt(AL_CIPHER_DevStruct *Dev, AL_CIPHER_ConfigUnion *Config)
{
    AL_S32 Ret = AL_OK;

    if (Dev == AL_NULL || Config == AL_NULL) {
        return AL_CIPHER_ERR_NULL_PTR;
    }

#if 1   //def CIPHER_PARAM_CHECK
    Ret = AlCipher_Dev_CryptCheckParams(Config);
    if (Ret != AL_OK) {
        return Ret;
    }
#endif

    AlCipher_Dev_CryptSetParams(Dev, Config);

    AlCipher_Dev_SendMsg(Dev);

    return Ret;
}

static AL_S32 AlCipher_Dev_HashCheckParams(AL_CIPHER_ConfigUnion *Config)
{
    if (!IS_VALID_HASH_MODE(Config->Hash.HashMode)) {
        return AL_CIPHER_ERR_HASH_MODE;
    }

    if (!IS_HASH_BLK_MODE(Config->Hash.HashBlkMode)) {
        return AL_CIPHER_ERR_BLOCK_MODE;
    }

    //Is data length align
    if (!IS_DATA_ALIGN(Config->Hash.DataLength)) {
        return AL_CIPHER_ERR_DATA_ALIGN;
    }

    return AL_OK;
}

static AL_VOID AlCipher_Dev_HashSetParams(AL_CIPHER_DevStruct *Dev, AL_CIPHER_ConfigUnion *Config)
{
    AL_CIPHER_MEMSET(&Dev->Msg, 0, sizeof(AL_CIPHER_MsgStruct));

    Dev->Msg.Cmd                            = AL_CIPHER_CMD_HASH;
    Dev->Msg.Option0.Low                    = Config->Hash.HashMode;
    Dev->Msg.Option1.Extend                 = Config->Hash.HashBlkMode;
    Dev->Msg.MsgData.HashParam.DataIn       = Config->Hash.InputData;
    Dev->Msg.MsgData.HashParam.DataLength   = Config->Hash.DataLength;
    Dev->Msg.MsgData.HashParam.HashOut      = Config->Hash.HashOut;
}

static AL_S32 AlCipher_Dev_Hash(AL_CIPHER_DevStruct *Dev, AL_CIPHER_ConfigUnion *Config)
{
    AL_S32 Ret = AL_OK;

    if (Dev == AL_NULL || Config == AL_NULL) {
        return AL_CIPHER_ERR_NULL_PTR;
    }

#if 1   //def CIPHER_PARAM_CHECK
    AlCipher_Dev_HashCheckParams(Config);
#endif

    AlCipher_Dev_HashSetParams(Dev, Config);

    AlCipher_Dev_SendMsg(Dev);

    return Ret;
}

static AL_S32 AlCipher_Dev_AuthCheckParams(AL_CIPHER_ConfigUnion *Config)
{
    if (!IS_AUTH_MODE(Config->Auth.AuthMode)) {
        return AL_CIPHER_ERR_AUTH_MODE;
    }

    if (Config->Auth.Digest == AL_NULL ||
        Config->Auth.PubKey == AL_NULL ||
        Config->Auth.Signature == AL_NULL) {
        return AL_CIPHER_ERR_NULL_PTR;
    }

    return AL_OK;
}

static AL_VOID AlCipher_Dev_AuthSetParams(AL_CIPHER_DevStruct *Dev, AL_CIPHER_ConfigUnion *Config)
{
    AL_CIPHER_MEMSET(&Dev->Msg, 0, sizeof(AL_CIPHER_MsgStruct));

    Dev->Msg.Cmd                            = AL_CIPHER_CMD_AUTH;
    Dev->Msg.Option0.Low                    = Config->Auth.AuthMode;
    Dev->Msg.MsgData.AuthParam.Pubkey       = Config->Auth.PubKey;
    Dev->Msg.MsgData.AuthParam.Digest       = Config->Auth.Digest;
    Dev->Msg.MsgData.AuthParam.Signature    = Config->Auth.Signature;
}

static AL_S32 AlCipher_Dev_Auth(AL_CIPHER_DevStruct *Dev, AL_CIPHER_ConfigUnion *Config)
{
    AL_S32 Ret = AL_OK;

    if (Dev == AL_NULL || Config == AL_NULL) {
        return AL_CIPHER_ERR_NULL_PTR;
    }

#if 1   //def CIPHER_PARAM_CHECK
    AlCipher_Dev_AuthCheckParams(Config);
#endif

    AlCipher_Dev_AuthSetParams(Dev, Config);

    AlCipher_Dev_SendMsg(Dev);

    return Ret;
}

static AL_S32 AlCipher_Dev_SignCheckParams(AL_CIPHER_ConfigUnion *Config)
{
    if (!IS_SIGN_MODE(Config->Sign.SignMode)) {
        return AL_CIPHER_ERR_SIGN_MODE;
    }

    if (Config->Sign.PriKey == AL_NULL ||
        Config->Sign.Digest == AL_NULL ||
        Config->Sign.Signature == AL_NULL) {
        return AL_CIPHER_ERR_NULL_PTR;
    }

    return AL_OK;
}

static AL_VOID AlCipher_Dev_SignSetParams(AL_CIPHER_DevStruct *Dev, AL_CIPHER_ConfigUnion *Config)
{
    AL_CIPHER_MEMSET(&Dev->Msg, 0, sizeof(AL_CIPHER_MsgStruct));

    Dev->Msg.Cmd                            = AL_CIPHER_CMD_SIGN;
    Dev->Msg.Option0.Low                    = Config->Sign.SignMode;
    Dev->Msg.MsgData.SignParam.PriKey       = Config->Sign.PriKey;
    Dev->Msg.MsgData.SignParam.Digest       = Config->Sign.Digest;
    Dev->Msg.MsgData.SignParam.Signature    = Config->Sign.Signature;
}

static AL_S32 AlCipher_Dev_Sign(AL_CIPHER_DevStruct *Dev, AL_CIPHER_ConfigUnion *Config)
{
    AL_S32 Ret = AL_OK;

    if (Dev == AL_NULL || Config == AL_NULL) {
        return AL_CIPHER_ERR_NULL_PTR;
    }

#if 1   //def CIPHER_PARAM_CHECK
    AlCipher_Dev_SignCheckParams(Config);
#endif

    AlCipher_Dev_SignSetParams(Dev, Config);

    AlCipher_Dev_SendMsg(Dev);

    return Ret;
}

static AL_S32 AlCipher_Dev_GenKeyCheckParams(AL_CIPHER_ConfigUnion *Config)
{
    if (!IS_GENKEY_MODE(Config->GenKey.KeyMode)) {
        return AL_CIPHER_ERR_KEY_MODE;
    }

    if (Config->GenKey.PriKey == AL_NULL ||
        Config->GenKey.PubKey == AL_NULL) {
        return AL_CIPHER_ERR_NULL_PTR;
    }

    return AL_OK;
}

static AL_VOID AlCipher_Dev_GenKeySetParams(AL_CIPHER_DevStruct *Dev, AL_CIPHER_ConfigUnion *Config)
{
    AL_CIPHER_MEMSET(&Dev->Msg, 0, sizeof(AL_CIPHER_MsgStruct));

    Dev->Msg.Cmd = AL_CIPHER_CMD_GENKEY;
    Dev->Msg.Option0.Low = Config->GenKey.KeyMode;
    Dev->Msg.MsgData.GenKeyParam.PubKey = Config->GenKey.PubKey;
    Dev->Msg.MsgData.GenKeyParam.PriKey = Config->GenKey.PriKey;
}

static AL_S32 AlCipher_Dev_GenKey(AL_CIPHER_DevStruct *Dev, AL_CIPHER_ConfigUnion *Config)
{
    AL_S32 Ret = AL_OK;

    if (Dev == AL_NULL || Config == AL_NULL) {
        return AL_CIPHER_ERR_NULL_PTR;
    }

#if 1   //def CIPHER_PARAM_CHECK
    AlCipher_Dev_GenKeyCheckParams(Config);
#endif

    AlCipher_Dev_GenKeySetParams(Dev, Config);

    AlCipher_Dev_SendMsg(Dev);

    return Ret;
}

static AL_S32 AlCipher_Dev_GetZCheckParams(AL_CIPHER_ConfigUnion *Config)
{
    if (Config->GetZ.PubKey == AL_NULL ||
        Config->GetZ.Ida == AL_NULL ||
        Config->GetZ.ZaOut == AL_NULL) {
        return AL_CIPHER_ERR_NULL_PTR;
    }

    return AL_OK;
}

static AL_S32 AlCipher_Dev_SwitchEndian(AL_U8 *Data, AL_U32 DataSize)
{
    AL_U8 SwitchData = 0;

    if (DataSize & 0x3) {
        return AL_CIPHER_ERR_DATA_ALIGN;
    } else {
        for (AL_U32 i = 0; i < DataSize; i+=4) {
            SwitchData = Data[i];
            Data[i] = Data[i+3];
            Data[i+3] = SwitchData;
            SwitchData = Data[i+1];
            Data[i+1] = Data[i+2];
            Data[i+2] = SwitchData;
        }
    }

    return AL_OK;
}

static AL_S32 AlCipher_Dev_GetZ(AL_CIPHER_DevStruct *Dev, AL_CIPHER_ConfigUnion *Config)
{
    AL_S32 Ret = AL_OK;
    AL_U32 RealDataSize = 0;
    AL_U32 AlignBufSize = 0;
    AL_CIPHER_ConfigUnion HashConfig;

    if (Dev == AL_NULL || Config == AL_NULL) {
        return AL_CIPHER_ERR_NULL_PTR;
    }

#if 1   //def CIPHER_PARAM_CHECK
    AlCipher_Dev_GetZCheckParams(Config);
#endif

    RealDataSize = 2 + Config->GetZ.IdaLen + AL_CIPHER_DATA_ALIGN_SIZE + sizeof(AL_CIPHER_EcCurveStruct);

    AlignBufSize = (RealDataSize & ~0x3F) + (IS_DATA_ALIGN(RealDataSize) ? 0 : AL_CIPHER_DATA_ALIGN_SIZE);

    if (AlignBufSize > AL_CIPHER_GETZ_HASH_BUF_SIZE) {
        // AL_LOG(AL_LOG_LEVEL_ERROR, "Get Z align size large than temp hash buf size,
        //                             please increase macro AL_CIPHER_GETZ_HASH_BUF_SIZE in %s\r\n", __FILE__);
        return AL_CIPHER_ERR_DATA_OVERFLOW;
    }

    AL_U8 AlignBuf[AL_CIPHER_GETZ_HASH_BUF_SIZE] = {0};

    /* IdLen -> 2 bytes */
    AlignBuf[0] = ((Config->GetZ.IdaLen << 3) >> 8) & 0xFF;
    AlignBuf[1] = (Config->GetZ.IdaLen << 3) & 0xFF;

    /* copy Id */
    AL_CIPHER_MEMCPY(&AlignBuf[2], Config->GetZ.Ida, Config->GetZ.IdaLen);

    /* copy PubKey, default big endian, so need switch endian */
    AL_CIPHER_MEMCPY(&AlignBuf[2 + Config->GetZ.IdaLen], Config->GetZ.PubKey, AL_CIPHER_DATA_ALIGN_SIZE);
    Ret = AlCipher_Dev_SwitchEndian(&AlignBuf[2 + Config->GetZ.IdaLen], AL_CIPHER_DATA_ALIGN_SIZE);
    if (Ret != AL_OK) {
        return Ret;
    }

    HashConfig.Hash.HashMode = AL_CIPHER_OPS_HASH_SM3;
    HashConfig.Hash.HashBlkMode = AL_CIPHER_BLK_WHOLE;
    HashConfig.Hash.InputData = AlignBuf;
    HashConfig.Hash.DataLength = AlignBufSize;
    HashConfig.Hash.HashOut = Config->GetZ.ZaOut;

    Ret = AlCipher_Dev_Hash(Dev, &HashConfig);
    if (Ret != AL_OK) {
        AL_LOG(AL_LOG_LEVEL_ERROR, "Get Z hash err: 0x%x\r\n", Ret);
        return Ret;
    }

    return Ret;
}

static AL_VOID AlCipher_Dev_SetStartBusy(AL_CIPHER_DevStruct *Dev)
{
    AL_CIPHER_EventStruct Event = {
        .EventId    = AL_CIPHER_EVENT_READY,
        .EventData  = 0
    };
    Dev->EventCallBack.Func(&Event, Dev->EventCallBack.Ref);

    AlCipher_Dev_SetState(Dev, AL_CIPHER_STATE_BUSY);
}

AL_S32 AlCipher_Dev_Start(AL_CIPHER_DevStruct *Dev, AL_CIPHER_CmdEnum Cmd, AL_CIPHER_ConfigUnion *Config)
{
    AL_S32 Ret = AL_OK;

    if (Dev == AL_NULL || Config == AL_NULL) {
        return AL_CIPHER_ERR_NULL_PTR;
    }

    if (!AlCipher_Dev_GetState(Dev, AL_CIPHER_STATE_READY)) {
        return AL_CIPHER_ERR_STATE_NOT_READY;
    }

    if (AlCipher_Dev_GetState(Dev, AL_CIPHER_STATE_BUSY)) {
        return AL_CIPHER_ERR_STATE_BUSY;
    }

    AlCipher_Dev_SetStartBusy(Dev);

    switch (Cmd)
    {
    case AL_CIPHER_CMD_DMA:
    case AL_CIPHER_CMD_ENCRYPT:
        Ret = AlCipher_Dev_Crypt(Dev, Config);
        break;
    case AL_CIPHER_CMD_HASH:
        Ret = AlCipher_Dev_Hash(Dev, Config);
        break;
    case AL_CIPHER_CMD_AUTH:
        Ret = AlCipher_Dev_Auth(Dev, Config);
        break;
    case AL_CIPHER_CMD_SIGN:
        Ret = AlCipher_Dev_Sign(Dev, Config);
        break;
    case AL_CIPHER_CMD_GENKEY:
        Ret = AlCipher_Dev_GenKey(Dev, Config);
        break;
    case AL_CIPHER_CMD_GETZ:
        Ret = AlCipher_Dev_GetZ(Dev, Config);
        break;
    default:
        Ret = AL_CIPHER_ERR_UNSUPPORT_CMD;
        break;
    }

    if (Ret != AL_OK) {
        AlCipher_Dev_ClrState(Dev, AL_CIPHER_STATE_BUSY);
    }

    return Ret;
}