/*
 * Copyright (c) 2023, Anlogic Inc. and Contributors. All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

/***************************** Include Files *********************************/
#include <string.h>
#include "al_mmc_dev.h"

/************************** Constant Definitions *****************************/
/* Default Init config */
static AL_MMC_InitStruct AlMmc_DefInitConfig = {
    .CardType           = AL_MMC_CARD_TYPE_AUTO_DETECT,
    .FreqKhz            = AL_MMC_FREQ_KHZ_10000,
    .DmaMode            = AL_MMC_DMA_MODE_SDMA,
    .BusWidth           = AL_MMC_BUS_WIDTH_8BIT,
    .Switch1v8          = AL_FUNC_ENABLE,
    .AutoGenAdmaTblEn   = AL_FUNC_DISABLE,
    .DmaBdary           = AL_MMC_BDARY_32K
};

/* For capacity print, only for debug */
static AL_U8 AlMmc_CapacityDot[16] = {0, 1, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9, 9};

/**************************** Type Definitions *******************************/

/***************** Macros (Inline Functions) Definitions *********************/
#define AL_MMC_CMD_COMP_INTR(Status)     (Status & AL_MMC_INTR_CMD_COMP_MASK)
#define AL_MMC_XFER_COMP_INTR(Status)   (Status & AL_MMC_INTR_XFER_COMP_MASK)
#define AL_MMC_DMA_INTR(Status)    (Status & AL_MMC_INTR_DMA_MASK)
#define AL_MMC_CARD_INTR(Status)    (Status & (AL_MMC_INTR_CARD_INSERT_MASK | AL_MMC_INTR_CARD_REMOVE_MASK |\
                                               AL_MMC_INTR_CARD_MASK))
#define AL_MMC_ERR_INTR(Status)     (Status & AL_MMC_INTR_ERR_MASK)

#define AL_MMC_LOOP_REG_DELAY   do {AlSys_UDelay(10);} while (0)
#define AL_MMC_CLK_SYNC_DELAY   do {AlSys_UDelay(100);} while (0)
#define AL_MMC_SWITCH_DELAY     do {AlSys_UDelay(1000);} while (0)

#define AL_MMC_CHK_TOUT_RST_HOST    (100)           /* 1ms */
#define AL_MMC_CHK_TOUT_LINE_IDLE   (1000000)       /* 10s */
#define AL_MMC_CHK_TOUT_XFER_DONE   (200000)         /* 2s */
#define AL_MMC_CHK_TOUT_XFER_NO_DMA (200000)        /* 2s */
#define AL_MMC_CHK_TOUT_BUFF_RDY    (100000)        /* 1s */

/* buf is aligned with 64byte */
#ifdef ENABLE_MMU
#define AL_MMC_BUF_ALIGN_MASK       (0x3F)
#else
#define AL_MMC_BUF_ALIGN_MASK       (0x3)
#endif

#define IS_SAME_INITCONFIGS(Dst, Src)   ((Dst).CardType == (Src).CardType && \
                                         (Dst).FreqKhz == (Src).FreqKhz && \
                                         (Dst).SpdMode == (Src).SpdMode && \
                                         (Dst).DmaMode == (Src).DmaMode && \
                                         (Dst).BusWidth == (Src).BusWidth && \
                                         (Dst).Switch1v8 == (Src).Switch1v8 && \
                                         (Dst).AutoGenAdmaTblEn == (Src).AutoGenAdmaTblEn && \
                                         (Dst).DmaBdary == (Src).DmaBdary)

/************************** Variable Definitions *****************************/
/* Hardware config generated by TD */
extern AL_MMC_HwConfigStruct AlMmc_HwConfig[];

/************************** Function Prototypes ******************************/

static AL_S32 AlMmc_Dev_DmaSetUp(AL_MMC_DevStruct *Dev, AL_U8 *Buf, AL_U32 BlkCnt);
static AL_S32 AlMmc_Dev_SetBlkSize(AL_MMC_DevStruct *Dev, AL_MMC_BlkLenEnum BlkLen);
static AL_S32 AlMmc_Dev_TransferData(AL_MMC_DevStruct *Dev, AL_U8 *Buf, AL_U32 BlkCnt);
static AL_VOID AlMmc_Dev_DisplayCsd(AL_MMC_DevStruct *Dev);
static AL_VOID AlMmc_Dev_DisplayScr(AL_MMC_DevStruct *Dev);
static AL_VOID AlMmc_Dev_DisplayAdmaDesc(AL_MMC_AdmaDescUnion *TablePtr, AL_U32 Size);
static AL_VOID AlMmc_Dev_DisplayAllReg(AL_MMC_DevStruct *Dev);
static AL_VOID AlMmc_Dev_DisplayCardInfo(AL_MMC_DevStruct *Dev);

/************************** Function Definitions ******************************/

AL_BOOL AlMmc_Dev_GetState(AL_MMC_DevStruct *Dev, AL_MMC_StateEnum State)
{
    return ((Dev->State & State) ? AL_TRUE : AL_FALSE);
}

AL_VOID AlMmc_Dev_SetState(AL_MMC_DevStruct *Dev, AL_MMC_StateEnum State)
{
    Dev->State |= State;
}

AL_VOID AlMmc_Dev_ClrState(AL_MMC_DevStruct *Dev, AL_MMC_StateEnum State)
{
    Dev->State &= ~State;
}

AL_S32 AlMmc_Dev_RstHostController(AL_MMC_DevStruct *Dev, AL_MMC_RstHostEnum Rst)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_U32 Timeout = AL_MMC_CHK_TOUT_RST_HOST;
    if (Rst & ~(AL_MMC_RST_HOST_ALL | AL_MMC_RST_HOST_CMD | AL_MMC_RST_HOST_DAT)) {
        AL_LOG(AL_LOG_LEVEL_ERROR, "Host reset enum error\r\n");
        return AL_MMC_ERR_HOST_RST;
    }

    AL_U32 Ctrl = AlMmc_ll_ReadSwRst_Ctrl_Tout_Clk(Dev->HwConfig.BaseAddress);
    Ctrl |= Rst;
    AlMmc_ll_WriteSwRst_Ctrl_Tout_Clk(Dev->HwConfig.BaseAddress, Ctrl);

    do {
        Ctrl = AlMmc_ll_ReadSwRst_Ctrl_Tout_Clk(Dev->HwConfig.BaseAddress);
        AL_MMC_LOOP_REG_DELAY;
        Timeout--;
    } while ((Ctrl & Rst) && Timeout);

    if (Timeout) {
        return AL_OK;
    } else {
        return AL_MMC_ERR_RST_LINE_TIMEOUT;
    }
}

static AL_VOID AlMmc_Dev_TopCfgInit(AL_MMC_DevStruct *Dev)
{
    AL_MMC_TopCfgUnion TmpReg;

    TmpReg.Reg = AlMmc_ll_ReadTopCfg(Dev->HwConfig.BaseAddress);
    TmpReg.Bit.ClkPhase         = Dev->HwConfig.ClkPhase;
    TmpReg.Bit.CfgCardDetectN   = Dev->HwConfig.CardDetect;
    TmpReg.Bit.CardDetectSig    = Dev->HwConfig.CardDetectSig;
    TmpReg.Bit.CfgCardProt      = Dev->HwConfig.WritePort;
    TmpReg.Bit.CardWrProtSig    = Dev->HwConfig.WritePortSig;
    AlMmc_ll_WriteTopCfg(Dev->HwConfig.BaseAddress, TmpReg.Reg);
}

static AL_S32 AlMmc_Dev_CheckLineIdle(AL_MMC_DevStruct *Dev, AL_MMC_StateMaskEnum Line)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_U32 TmpReg = {0};
    AL_U32 Timeout = AL_MMC_CHK_TOUT_LINE_IDLE;

    do {
        TmpReg = AlMmc_ll_ReadCurState(Dev->HwConfig.BaseAddress);
        AL_MMC_LOOP_REG_DELAY;
        Timeout--;
    } while ((TmpReg & Line) && Timeout);

    if (!Timeout) {
        AL_LOG(AL_LOG_LEVEL_ERROR, "Check line inhibit error, state: 0x%x\r\n", TmpReg);
        return AL_MMC_ERR_LINE_INHIBIT;
    }

    return AL_OK;
}

static AL_S32 AlMmc_Dev_CmdConfig(AL_MMC_DevStruct *Dev, AL_U32 Arg, AL_U32 BlkCnt)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    /* Write argument register */
    AlMmc_ll_WriteArgument(Dev->HwConfig.BaseAddress, Arg);

    if (BlkCnt > 1) {
        switch (Dev->Config.DmaMode)
        {
        case AL_MMC_DMA_MODE_NONE:
        case AL_MMC_DMA_MODE_SDMA:
        case AL_MMC_DMA_MODE_ADMA2:
            if (Dev->HostInfo.HostVer == AL_MMC_HOST_VER_4) {
                AlMmc_ll_SetBlkCnt(Dev->HwConfig.BaseAddress, 0);
                AlMmc_ll_WriteBlkCnt_SdmaSysAddr(Dev->HwConfig.BaseAddress, BlkCnt);
            } else {
                AlMmc_ll_SetBlkCnt(Dev->HwConfig.BaseAddress, BlkCnt);
            }
            break;
        case AL_MMC_DMA_MODE_ADMA3:
            break;
        default:
            break;
        }
    }

    return AL_OK;
}

static AL_U32 AlMmc_Dev_GetCmdRegParam(AL_MMC_DevStruct *Dev, AL_MMC_CmdIdxEnum Cmd)
{
    AL_MMC_CmdXferModeUnion TmpReg = {0};
    switch (Cmd)
    {
    /* No response, do nothing */
    case AL_MMC_CMD_IDX_0:
    case AL_MMC_CMD_IDX_4:
    case AL_MMC_CMD_IDX_15:
        break;
    /* R1 */
    case AL_MMC_CMD_IDX_11:
    case AL_MMC_CMD_IDX_13:
    case AL_MMC_CMD_IDX_14:
    case AL_MMC_CMD_IDX_16:
    case AL_MMC_CMD_IDX_23:
    case AL_MMC_CMD_IDX_26:
    case AL_MMC_CMD_IDX_27:
    case AL_MMC_CMD_IDX_30:
    case AL_MMC_CMD_IDX_31:
    case AL_MMC_CMD_IDX_32:
    case AL_MMC_CMD_IDX_33:
    case AL_MMC_CMD_IDX_35:
    case AL_MMC_CMD_IDX_36:
    case AL_MMC_CMD_IDX_42:
    case AL_MMC_CMD_IDX_44:
    case AL_MMC_CMD_IDX_45:
    case AL_MMC_CMD_IDX_46:
    case AL_MMC_CMD_IDX_47:
    case AL_MMC_CMD_IDX_49:
    case AL_MMC_CMD_IDX_53:
    case AL_MMC_CMD_IDX_54:
    case AL_MMC_CMD_IDX_55:
    case AL_MMC_CMD_IDX_56:
    case AL_MMC_ACMD_IDX_6:
    case AL_MMC_ACMD_IDX_22:
    case AL_MMC_ACMD_IDX_42:
        TmpReg.Bit.RespTypeSel = AL_MMC_RESP_TYPE_LEN_48;
        TmpReg.Bit.CmdCrcChkEn = AL_TRUE;
        TmpReg.Bit.CmdIdxChkEn = AL_TRUE;
        break;
    /* R1B */
    case AL_MMC_CMD_IDX_5:
    case AL_MMC_CMD_IDX_20:
    case AL_MMC_CMD_IDX_28:
    case AL_MMC_CMD_IDX_29:
    case AL_MMC_CMD_IDX_38:
    case AL_MMC_CMD_IDX_48:
        TmpReg.Bit.RespTypeSel = AL_MMC_RESP_TYPE_LEN_48B;
        TmpReg.Bit.CmdCrcChkEn = AL_TRUE;
        TmpReg.Bit.CmdIdxChkEn = AL_TRUE;
        break;
    /* R2 */
    case AL_MMC_CMD_IDX_2:
    case AL_MMC_CMD_IDX_9:
    case AL_MMC_CMD_IDX_10:
        TmpReg.Bit.RespTypeSel = AL_MMC_RESP_TYPE_LEN_136;
        TmpReg.Bit.CmdCrcChkEn = AL_TRUE;
        break;
    /* R3 */
    case AL_MMC_CMD_IDX_1:
    case AL_MMC_ACMD_IDX_41:
        TmpReg.Bit.RespTypeSel = AL_MMC_RESP_TYPE_LEN_48;
        break;
    /* R4 */
    case AL_MMC_CMD_IDX_39:
        TmpReg.Bit.RespTypeSel = AL_MMC_RESP_TYPE_LEN_48;
        TmpReg.Bit.CmdCrcChkEn = AL_TRUE;
        TmpReg.Bit.CmdIdxChkEn = AL_TRUE;
        break;
    /* R5 */
    case AL_MMC_CMD_IDX_40:
        TmpReg.Bit.RespTypeSel = AL_MMC_RESP_TYPE_LEN_48;
        TmpReg.Bit.CmdCrcChkEn = AL_TRUE;
        TmpReg.Bit.CmdIdxChkEn = AL_TRUE;
        break;
    /* SD R6, eMMC R3 */
    case AL_MMC_CMD_IDX_3:
        if (Dev->CardInfo.CardType == AL_MMC_CARD_TYPE_SD) {
            TmpReg.Bit.RespTypeSel = AL_MMC_RESP_TYPE_LEN_48;
        } else {
            TmpReg.Bit.RespTypeSel = AL_MMC_RESP_TYPE_LEN_48B;
        }
        TmpReg.Bit.CmdCrcChkEn = AL_TRUE;
        TmpReg.Bit.CmdIdxChkEn = AL_TRUE;
        break;
    /* SD R7, eMMC R1 */
    case AL_MMC_CMD_IDX_8:
        if (Dev->CardInfo.CardType == AL_MMC_CARD_TYPE_EMMC) {
            TmpReg.Bit.DatPresentSel    = AL_TRUE;
        }
        TmpReg.Bit.CmdIdxChkEn = AL_TRUE;
        TmpReg.Bit.CmdCrcChkEn = AL_TRUE;
        TmpReg.Bit.RespTypeSel = AL_MMC_RESP_TYPE_LEN_48;
        break;
    case AL_MMC_CMD_IDX_6:
        if (Dev->CardInfo.CardType == AL_MMC_CARD_TYPE_SD) {
            TmpReg.Bit.DatPresentSel    = AL_TRUE;
            TmpReg.Bit.RespTypeSel = AL_MMC_RESP_TYPE_LEN_48;
        } else {
            TmpReg.Bit.RespTypeSel = AL_MMC_RESP_TYPE_LEN_48B;
        }
        TmpReg.Bit.CmdCrcChkEn = AL_TRUE;
        TmpReg.Bit.CmdIdxChkEn = AL_TRUE;
        break;
    /* State stby/tran R1, conn/disconn R1B */
    case AL_MMC_CMD_IDX_7:
        Dev->CardState.Reg = AlMmc_ll_ReadCurState(Dev->HwConfig.BaseAddress);
        if ((Dev->CardState.Bit.CurState == AL_MMC_CARD_STAT_STBY) ||
            (Dev->CardState.Bit.CurState == AL_MMC_CARD_STAT_TRAN)) {
            TmpReg.Bit.RespTypeSel = AL_MMC_RESP_TYPE_LEN_48;
        } else {
            TmpReg.Bit.RespTypeSel = AL_MMC_RESP_TYPE_LEN_48B;
        }
        TmpReg.Bit.CmdCrcChkEn = AL_TRUE;
        TmpReg.Bit.CmdIdxChkEn = AL_TRUE;
        break;
    case AL_MMC_CMD_IDX_17:
    case AL_MMC_CMD_IDX_18:
    case AL_MMC_CMD_IDX_19:
    case AL_MMC_CMD_IDX_21:
    case AL_MMC_CMD_IDX_24:
    case AL_MMC_CMD_IDX_25:
    case AL_MMC_ACMD_IDX_13:
    case AL_MMC_ACMD_IDX_23:
    case AL_MMC_ACMD_IDX_51:
        TmpReg.Bit.RespTypeSel      = AL_MMC_RESP_TYPE_LEN_48;
        TmpReg.Bit.CmdCrcChkEn      = AL_TRUE;
        TmpReg.Bit.CmdIdxChkEn      = AL_TRUE;
        TmpReg.Bit.DatPresentSel    = AL_TRUE;
        break;
    /* SD R1B, eMMC read:R1, write:R1B */
    case AL_MMC_CMD_IDX_12: {
        AL_MMC_CmdXferModeUnion Ctrl;
        Ctrl.Reg = AlMmc_ll_ReadCmd_XferMode(Dev->HwConfig.BaseAddress);
        if ((Dev->CardInfo.CardType == AL_MMC_CARD_TYPE_EMMC && Ctrl.Bit.DatXferDir == AL_MMC_TRANS_DIR_READ)) {
            TmpReg.Bit.RespTypeSel = AL_MMC_RESP_TYPE_LEN_48;
        } else {
            TmpReg.Bit.RespTypeSel = AL_MMC_RESP_TYPE_LEN_48B;
        }
        TmpReg.Bit.CmdCrcChkEn      = AL_TRUE;
        TmpReg.Bit.CmdIdxChkEn      = AL_TRUE;
        break;
    }
    default:
        AL_LOG(AL_LOG_LEVEL_ERROR, "Invalid cmd index %d\r\n", Cmd);
        break;
    }

    return TmpReg.Reg;
}

static AL_S32 AlMmc_Dev_CmdSend(AL_MMC_DevStruct *Dev, AL_MMC_CmdIdxEnum Cmd, AL_U32 BlkCnt)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_MMC_CmdXferModeUnion TmpReg;
    TmpReg.Reg = AlMmc_Dev_GetCmdRegParam(Dev, Cmd);

    if (AlMmc_Dev_GetState(Dev, AL_MMC_STATE_READY) && (BlkCnt != 0) && (Dev->Config.DmaMode != AL_MMC_DMA_MODE_NONE)) {
        TmpReg.Bit.DmaEn    = AL_TRUE;
    }

    if (BlkCnt > 1) {
        TmpReg.Bit.BlkCntEn     = AL_TRUE;
        TmpReg.Bit.MultiBlkSel  = AL_TRUE;
    }

    /* Only read cmd set dir to read */
    if ((Cmd == AL_MMC_CMD_IDX_6) || (Cmd == AL_MMC_CMD_IDX_8) || (Cmd == AL_MMC_CMD_IDX_17) ||
        (Cmd == AL_MMC_CMD_IDX_18) || (Cmd == AL_MMC_ACMD_IDX_51)) {
        TmpReg.Bit.DatXferDir = AL_MMC_TRANS_DIR_READ;
        Dev->HostInfo.Dir = AL_MMC_TRANS_DIR_READ;
    } else {
        TmpReg.Bit.DatXferDir = AL_MMC_TRANS_DIR_WRITE;
        Dev->HostInfo.Dir = AL_MMC_TRANS_DIR_WRITE;
    }

    /* For infinite length */
    if ((Cmd == AL_MMC_CMD_IDX_18) || (Cmd == AL_MMC_CMD_IDX_25)) {
        if (Dev->HostInfo.HostVer == AL_MMC_HOST_VER_4) {
            TmpReg.Bit.AutoCmdEn = AL_MMC_AUTO_CMD_23;
        }
    }

    /*Enable resp intr for host driver to check response error */
    TmpReg.Bit.RespIntDisable   = AL_FALSE;
    TmpReg.Bit.RespErrChkEn     = AL_FALSE;

    /* Sub bit not use yet */

    /* ACMD offset if 0x100 */
    TmpReg.Bit.CmdType  = AL_MMC_CMD_TYPE_NORMAL;
    TmpReg.Bit.CmdIdx   = Cmd & 0xFF;

    AlMmc_ll_WriteCmd_XferMode(Dev->HwConfig.BaseAddress, TmpReg.Reg);

    return AL_OK;
}

static AL_S32 AlMmc_Dev_CheckErrStat(AL_MMC_DevStruct *Dev, AL_MMC_IntrUnion State)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AlMmc_Dev_DisplayAllReg(Dev);
    if (State.Bit.CmdToutErr) {
        return AL_MMC_ERR_CMD_TOUT;
    } else if (State.Bit.CmdCrcErr) {
        return AL_MMC_ERR_CMD_CRC;
    } else if (State.Bit.CmdEndBitErr) {
        return AL_MMC_ERR_CMD_END_BIT;
    } else if (State.Bit.CmdIdxErr) {
        return AL_MMC_ERR_CMD_IDX;
    } else if (State.Bit.DatToutErr) {
        return AL_MMC_ERR_DATA_TOUT;
    } else if (State.Bit.DatCrcErr) {
        return AL_MMC_ERR_DATA_CRC;
    } else if (State.Bit.DatEndBitErr) {
        return AL_MMC_ERR_DATA_END_BIT;
    } else if (State.Bit.CurLmtErr) {
        return AL_MMC_ERR_CUR_LMT;
    } else if (State.Bit.AutoCmdErr) {
        return AL_MMC_ERR_AUTO_CMD;
    } else if (State.Bit.AdmaErr) {
        return AL_MMC_ERR_ADMA;
    } else if (State.Bit.TuningErr) {
        return AL_MMC_ERR_TUNING;
    } else if (State.Bit.RespErr) {
        return AL_MMC_ERR_RESP;
    } else if (State.Bit.BootAckErr) {
        return AL_MMC_ERR_BOOT_ACK;
    } else {
        return AL_OK;
    }
}

static AL_S32 AlMmc_Dev_CheckCmdDone(AL_MMC_DevStruct *Dev, AL_MMC_CmdIdxEnum Cmd)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret      = AL_OK;
    AL_U32 Timeout  = 1000000;
    volatile AL_MMC_IntrUnion IntrStat   = {0};

    do {
        IntrStat.Reg = AlMmc_ll_ReadIntrStat(Dev->HwConfig.BaseAddress);

        if (IntrStat.Bit.ErrIntr) {
            AL_LOG(AL_LOG_LEVEL_ERROR, "Response: 0x%x\r\n", AlMmc_ll_ReadResp01(Dev->HwConfig.BaseAddress));
            AL_LOG(AL_LOG_LEVEL_ERROR, "%s %d send err, code: 0x%x\r\n", ((Cmd & 0x100) ? "ACMD" : "CMD"), (Cmd & 0xFF),
                                                                           IntrStat.Reg);
            return AlMmc_Dev_CheckErrStat(Dev, IntrStat);
        }
        AL_MMC_LOOP_REG_DELAY;
        Timeout--;
    } while ((!IntrStat.Bit.CmdComp) && Timeout);

    if (!Timeout) {
        AL_LOG(AL_LOG_LEVEL_ERROR, "%s %d send timeout\r\n", ((Cmd & 0x100) ? "ACMD" : "CMD"), (Cmd & 0xFF));
        return AL_MMC_ERR_CMD_COMP_TIMEOUT;
    }

    AL_LOG(AL_LOG_LEVEL_DEBUG, "Cmd done state: 0x%x\r\n", IntrStat.Reg);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "Resp[01]: 0x%x, Resp[23]: 0x%x, Resp[45]: 0x%x, Resp[67]: 0x%x\r\n",
                                AlMmc_ll_ReadResp01(Dev->HwConfig.BaseAddress),
                                AlMmc_ll_ReadResp23(Dev->HwConfig.BaseAddress),
                                AlMmc_ll_ReadResp45(Dev->HwConfig.BaseAddress),
                                AlMmc_ll_ReadResp67(Dev->HwConfig.BaseAddress));

    IntrStat.Reg = 0;
    IntrStat.Bit.CmdComp = AL_TRUE;
    AlMmc_ll_WriteIntrStat(Dev->HwConfig.BaseAddress, IntrStat.Reg);

    return Ret;
}

static AL_S32 AlMmc_Dev_CmdTransfer(AL_MMC_DevStruct *Dev, AL_MMC_CmdIdxEnum Cmd, AL_U32 Arg, AL_U32 BlkCnt)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    AL_LOG(AL_LOG_LEVEL_DEBUG, "Send: %s%d, Arg: 0x%x, BlkCnt: %d\r\n", ((Cmd & 0x100) ? "ACMD" : "CMD"), (Cmd & 0xFF),
                                                                        Arg, BlkCnt);

    Ret = AlMmc_Dev_CheckLineIdle(Dev, AL_MMC_STATE_MASK_LINE_BOTH);
    if (Ret != AL_OK) {
        return Ret;
    }

    /* Clear all intr state */
    AlMmc_ll_WriteIntrStat(Dev->HwConfig.BaseAddress, AL_MMC_INTR_ALL_MASK);

    Ret = AlMmc_Dev_CmdConfig(Dev, Arg, BlkCnt);
    if (Ret != AL_OK) {
        return Ret;
    }

    Ret = AlMmc_Dev_CmdSend(Dev, Cmd, BlkCnt);
    if (Ret != AL_OK) {
        return Ret;
    }

    Ret = AlMmc_Dev_CheckCmdDone(Dev, Cmd);
    if (Ret != AL_OK) {
        return Ret;
    }

    return Ret;
}

static AL_VOID AlMmc_Dev_SetToutCnt(AL_MMC_DevStruct *Dev, AL_MMC_ToutCntEnum Cnt)
{
    AL_MMC_CtrlSrToClkUnion TmpReg = {0};

    TmpReg.Reg = AlMmc_ll_ReadSwRst_Ctrl_Tout_Clk(Dev->HwConfig.BaseAddress);
    if (TmpReg.Bit.ToutCnt != Cnt) {
        TmpReg.Bit.ToutCnt = Cnt;
        AlMmc_ll_WriteSwRst_Ctrl_Tout_Clk(Dev->HwConfig.BaseAddress, TmpReg.Reg);
    }
}

static AL_VOID AlMmc_Dev_GetHostInfo(AL_MMC_DevStruct *Dev)
{
    Dev->HostInfo.Cap1.Reg   = AlMmc_ll_ReadCapability1(Dev->HwConfig.BaseAddress);
    Dev->HostInfo.Cap2.Reg   = AlMmc_ll_ReadCapability2(Dev->HwConfig.BaseAddress);
}

static AL_S32 AlMmc_Dev_SetClkFreq(AL_MMC_DevStruct *Dev, AL_MMC_FreqKhzEnum Freq)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;
    AL_MMC_CtrlSrToClkUnion TmpReg = {0};
    AL_U32 InputClkKhz = Dev->HwConfig.InputClk / 1000;
    AL_U32 FreqDiv = InputClkKhz / Freq;
    AL_U32 FreqMod = InputClkKhz % Freq;
    AL_U32 FreqSel = 0;

    AL_LOG(AL_LOG_LEVEL_DEBUG, "Req freq %d Khz, div: %d, mod: %d\r\n", Freq, FreqDiv, FreqMod);

    TmpReg.Reg = AlMmc_ll_ReadSwRst_Ctrl_Tout_Clk(Dev->HwConfig.BaseAddress);

    /* First init is default 400k, so do not need set defualt clk freq */
    if ((TmpReg.Bit.ClkGenSel == AL_MMC_CLK_GEN_DIV) && (Freq == AL_MMC_FREQ_KHZ_DEF)) {
        Dev->CardInfo.FreqKhz   = AL_MMC_FREQ_KHZ_DEF;
        AL_LOG(AL_LOG_LEVEL_DEBUG, "Cur freq is default 400Khz\r\n");
        return AL_OK;
    }

    if (Freq != AL_MMC_FREQ_KHZ_DEF) {
        if (0 == FreqDiv) {
            AL_LOG(AL_LOG_LEVEL_DEBUG, "Freq is large than input clk, set freq to input clk %d Khz\r\n", InputClkKhz);
            FreqSel = 0;
        } else if (FreqMod) {
            if (FreqDiv == TmpReg.Bit.FreqSel) {
                AL_LOG(AL_LOG_LEVEL_DEBUG, "Freq(not divisible by input clk) need to config %d Khz equeal to cur set\r\n", InputClkKhz / (FreqDiv + 1));
                return Ret;
            } else {
                AL_LOG(AL_LOG_LEVEL_DEBUG, "Freq is not divisible by input clk, floor this freq to %d Khz\r\n", InputClkKhz / (FreqDiv + 1));
                FreqSel = FreqDiv;
            }
        } else {
            FreqSel = FreqDiv - 1;
            AL_LOG(AL_LOG_LEVEL_DEBUG, "Set freq to %d Khz, divide is %d\r\n", Freq, FreqSel);
        }

        if ((TmpReg.Bit.ClkGenSel == AL_MMC_CLK_GEN_PROGRAM) && (TmpReg.Bit.FreqSel == FreqSel)) {
            AL_LOG(AL_LOG_LEVEL_DEBUG, "Request req %d Khz equeal to cur set\r\n", Freq);
            return Ret;
        }
    }

    /* Set sd_clk_on off */
    TmpReg.Bit.SdClkEn = AL_FALSE;
    AlMmc_ll_WriteSwRst_Ctrl_Tout_Clk(Dev->HwConfig.BaseAddress, TmpReg.Reg);

    /* Clk soft reset */
    AlMmc_ll_SetClkSoftRst(Dev->HwConfig.BaseAddress, AL_TRUE);

    /* Delay for clk sync */
    AL_MMC_CLK_SYNC_DELAY;

    if (Freq == AL_MMC_FREQ_KHZ_DEF) {
        TmpReg.Bit.ClkGenSel    = AL_MMC_CLK_GEN_DIV;
        TmpReg.Bit.FreqSel      = 0;
        Dev->CardInfo.FreqKhz   = AL_MMC_FREQ_KHZ_DEF;
    } else {
        TmpReg.Bit.ClkGenSel    = AL_MMC_CLK_GEN_PROGRAM;
        TmpReg.Bit.FreqSel      = FreqSel;
        /*Save cur card freq to card info*/
        Dev->CardInfo.FreqKhz   = InputClkKhz /(FreqSel + 1);
    }

    AlMmc_ll_WriteSwRst_Ctrl_Tout_Clk(Dev->HwConfig.BaseAddress, TmpReg.Reg);

    /* Clk soft reset release */
    AlMmc_ll_SetClkSoftRst(Dev->HwConfig.BaseAddress, AL_FALSE);

    /* Delay for clk sync */
    AL_MMC_CLK_SYNC_DELAY;

    /* Set sd_clk_on on */
    TmpReg.Bit.SdClkEn = AL_TRUE;
    AlMmc_ll_WriteSwRst_Ctrl_Tout_Clk(Dev->HwConfig.BaseAddress, TmpReg.Reg);

    /* Reset cmd line and data line to avoid the effect of any glitch on sampling clock */
    Ret = AlMmc_Dev_RstHostController(Dev, (AL_MMC_RST_HOST_CMD | AL_MMC_RST_HOST_DAT));
    if (Ret != AL_OK) {
        AL_LOG(AL_LOG_LEVEL_ERROR, "CMD line reset error\r\n");
        return Ret;
    }

    AL_LOG(AL_LOG_LEVEL_DEBUG, "Request: %d KHz, Set: %d KHz, Divide: %d \r\n", Freq, Dev->CardInfo.FreqKhz, TmpReg.Bit.FreqSel);
    TmpReg.Reg = AlMmc_ll_ReadSwRst_Ctrl_Tout_Clk(Dev->HwConfig.BaseAddress);
    AL_LOG(AL_LOG_LEVEL_DEBUG, " Clk mode is %s, Freq sel is %d\r\n",
                               ((TmpReg.Bit.ClkGenSel == AL_MMC_CLK_GEN_PROGRAM) ? "Program" : "Diveded"), TmpReg.Bit.FreqSel);

    return Ret;
}

static AL_S32 AlMmc_Dev_SetUpHostController(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_U32 Ret = AL_OK;

    Ret = AlMmc_Dev_RstHostController(Dev, AL_MMC_RST_HOST_CMD | AL_MMC_RST_HOST_DAT);
    if (Ret != AL_OK) {
        return Ret;
    }

    AL_MMC_CtrlWuBgPwHc1Union Ctrl1;
    Ctrl1.Reg = AlMmc_ll_ReadCtrl_Wup_Bgap_Pwr_Host1(Dev->HwConfig.BaseAddress);
    Ctrl1.Bit.DatXferWidth = 0;
    /* Set host dma mode */
    if (Dev->Config.DmaMode != AL_MMC_DMA_MODE_NONE) {
        Ctrl1.Bit.DmaSel = Dev->Config.DmaMode;
        /* Set dma buffer boundary */
        AlMmc_ll_SetSdmaBufBdary(Dev->HwConfig.BaseAddress, Dev->Config.DmaBdary);
    }
    AlMmc_ll_WriteCtrl_Wup_Bgap_Pwr_Host1(Dev->HwConfig.BaseAddress, Ctrl1.Reg);

    /* Set max timeout cnt, or some card touch tout error */
    AlMmc_Dev_SetToutCnt(Dev, AL_MMC_TOUT_CNT_27);

    /* Set clk freq to 400Khz for init */
    AlMmc_Dev_SetClkFreq(Dev, AL_MMC_FREQ_KHZ_DEF);

    return AL_OK;
}

static AL_S32 AlMmc_Dev_IdentifyCard(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_0, 0, 0);
    if (Ret != AL_OK) {
        return Ret;
    }

    AL_MMC_RegOcrUnion OcrReg = {0};
    OcrReg.Emmc.Volt27_36   = AL_MMC_OCR_VOLT_27_36;
    OcrReg.Emmc.AccessMode  = AL_MMC_ACC_MODE_SECTOR;
    Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_1, OcrReg.Reg, 0);
    if (Ret != AL_OK) {
        Dev->CardInfo.CardType = AL_MMC_CARD_TYPE_SD;
    } else {
        Dev->CardInfo.CardType = AL_MMC_CARD_TYPE_EMMC;
    }

    AlMmc_ll_WriteIntrStat(Dev->HwConfig.BaseAddress, AL_MMC_INTR_ALL_MASK);

    Ret = AlMmc_Dev_RstHostController(Dev, AL_MMC_RST_HOST_CMD);
    if (Ret != AL_OK) {
        AL_LOG(AL_LOG_LEVEL_ERROR, "CMD line reset error\r\n");
        return Ret;
    }

    return Ret;
}

static AL_S32 AlMmc_Dev_CheckCardDetect(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    if ((Dev->HostInfo.Cap1.Bit.SlotType == AL_MMC_SLOT_EMBEDDED) ||
        (Dev->HostInfo.Cap1.Bit.SlotType == AL_MMC_SLOT_UHS2_EMBEDDED)) {
        return AL_OK;
    }

    AL_MMC_TopCfgUnion TmpReg;
    TmpReg.Reg = AlMmc_ll_ReadTopCfg(Dev->HwConfig.BaseAddress);

    if (TmpReg.Bit.CardDetectSig == AL_MMC_SIG_EMIO_MIO) {
        AL_MMC_CurStatUnion CardState;
        CardState.Reg = AlMmc_ll_ReadCurState(Dev->HwConfig.BaseAddress);
        if (!CardState.Bit.CardInserted) {
            return AL_MMC_ERR_CARD_NOT_INSERTED;
        }
    } else {
        if (TmpReg.Bit.CfgCardDetectN) {
            return AL_MMC_ERR_CARD_NOT_INSERTED;
        }
    }

    return AL_OK;
}

static AL_S32 AlMmc_Dev_CardReset(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_0, 0, 0);
    if (Ret != AL_OK) {
        AL_LOG(AL_LOG_LEVEL_ERROR, "Card reset error, code 0x%x\r\n", Ret);
    }

    return Ret;
}

static AL_S32 AlMmc_Dev_CardIfCond(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_8, AL_MMC_CMD8_VOL_PATTERN, 0);
    if ((Ret != AL_OK) && (Ret != AL_MMC_ERR_CMD_TOUT)) {
        AL_LOG(AL_LOG_LEVEL_ERROR, "Card reset error, code 0x%x\r\n", Ret);
        return Ret;
    }

    if (Ret == AL_MMC_ERR_CMD_TOUT) {
        Ret = AlMmc_Dev_RstHostController(Dev, AL_MMC_RST_HOST_CMD);
        if (Ret != AL_OK) {
            AL_LOG(AL_LOG_LEVEL_ERROR, "CMD line reset error\r\n");
            return Ret;
        }
    }

    AL_MMC_RegOcrUnion Ocr;
    Ocr.Reg = AlMmc_ll_ReadResp01(Dev->HwConfig.BaseAddress);
    if (Ocr.Reg != AL_MMC_CMD8_VOL_PATTERN) {
        Dev->CardInfo.CardVer = AL_MMC_CARD_VER_101;
    } else {
        /* Equal or high than this ver, read scr register later for real ver */
        Dev->CardInfo.CardVer = AL_MMC_CARD_VER_110;
    }

    return Ret;
}

static inline AL_U32 AlMmc_Dev_GenArgAcmd41(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_MMC_RegOcrUnion Arg;

    Arg.Reg = 0;

    if (Dev->HostInfo.Cap1.Bit.Volt33) {
        Arg.Sd.Volt32_33    = AL_TRUE;
        Arg.Sd.Volt33_34    = AL_TRUE;
    }

    if (Dev->HostInfo.Cap1.Bit.Volt30) {
        Arg.Sd.Volt29_30    = AL_TRUE;
        Arg.Sd.Volt30_31    = AL_TRUE;
    }

    if (Dev->HostInfo.Cap2.Bit.Vdd218VSup) {
        Arg.Sd.Switch18A        = AL_TRUE;
    }

    Arg.Sd.HiCapSupport   = AL_TRUE;

    return Arg.Reg;
}

static AL_S32 AlMmc_Dev_CardOpCond(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;
    AL_MMC_RegOcrUnion Ocr;
    AL_MMC_RegOcrUnion RespOcr;

    if (Dev->CardInfo.CardType == AL_MMC_CARD_TYPE_SD) {
        Ocr.Reg = AlMmc_Dev_GenArgAcmd41(Dev);  //0x40FF8000;   //
    } else {
        Ocr.Emmc.Volt27_36  = AL_MMC_OCR_VOLT_27_36;
        Ocr.Emmc.AccessMode = AL_MMC_ACC_MODE_SECTOR;
    }

    do {
        if (Dev->CardInfo.CardType == AL_MMC_CARD_TYPE_SD) {
            Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_55, 0, 0);
            if (Ret != AL_OK) {
                return Ret;
            }

            Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_ACMD_IDX_41, Ocr.Reg, 0);
            if (Ret != AL_OK) {
                return Ret;
            }
        } else {
            Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_1, Ocr.Reg, 0);
            if (Ret != AL_OK) {
                return Ret;
            }
        }

        RespOcr.Reg = AlMmc_ll_ReadResp01(Dev->HwConfig.BaseAddress);

        AL_MMC_LOOP_REG_DELAY;
    } while (!RespOcr.Sd.CardPwrUpStatBit);

    Dev->CardInfo.HiCap = RespOcr.Sd.HiCapSupport;

    return Ret;
}

static AL_S32 AlMmc_Dev_GetCardCfg(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;
    AL_U32 Temp;
    AL_U32 RestoreBlkLen = Dev->CardInfo.BlkLen;

    AlMmc_Dev_SetBlkSize(Dev, AL_MMC_BLK_LEN_8B);
    Dev->CardInfo.BlkLen = AL_MMC_BLK_LEN_8B;

    Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_55, Dev->CardInfo.RealAddr, 0);
    if (Ret != AL_OK) {
        return Ret;
    }

    Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_ACMD_IDX_51, 0, 1);
    if (Ret != AL_OK) {
        return Ret;
    }

    Ret = AlMmc_Dev_TransferData(Dev, (AL_U8 *)&Dev->CardInfo.Scr.Reg[0], 1);
    if (Ret != AL_OK) {
        return Ret;
    }


    Dev->CardInfo.BlkLen = RestoreBlkLen;

    for (AL_U32 j = 0; j < 8; j++) {
        AL_LOG(AL_LOG_LEVEL_DEBUG, "[%d]:0x%02x ", j, *((AL_U8 *)&Dev->CardInfo.Scr.Reg[0] + j));
    }
    AL_LOG(AL_LOG_LEVEL_DEBUG, "\r\n");

    Temp = Dev->CardInfo.Scr.Reg[0];
    /* Reserve for manufacturer usage */
    Dev->CardInfo.Scr.Reg[0] = Dev->CardInfo.Scr.Reg[1];
    Dev->CardInfo.Scr.Reg[1] = (Temp >> 24) | ((Temp & 0xFF) << 24) | ((Temp & 0xFF00) << 8) | ((Temp & 0xFF0000) >> 8);

    AL_LOG(AL_LOG_LEVEL_DEBUG, "Scr: [0] 0x%08x, [1] 0x%08x\r\n", Dev->CardInfo.Scr.Reg[0], Dev->CardInfo.Scr.Reg[1]);
    AlMmc_Dev_DisplayScr(Dev);

    return Ret;
}

static AL_S32 AlMmc_Dev_GetCardId(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;
    AL_U32 Temp;

    Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_2, 0, 0);
    if (Ret != AL_OK) {
        return Ret;
    }

    Dev->CardInfo.Cid.Reg[0] = AlMmc_ll_ReadResp01(Dev->HwConfig.BaseAddress);
    Dev->CardInfo.Cid.Reg[1] = AlMmc_ll_ReadResp23(Dev->HwConfig.BaseAddress);
    Dev->CardInfo.Cid.Reg[2] = AlMmc_ll_ReadResp45(Dev->HwConfig.BaseAddress);
    Dev->CardInfo.Cid.Reg[3] = AlMmc_ll_ReadResp67(Dev->HwConfig.BaseAddress);

    Temp = (Dev->CardInfo.Cid.Reg[2] & 0xFF000000) >> 24;
    Dev->CardInfo.Cid.Reg[3] = (Dev->CardInfo.Cid.Reg[3] << 8) | Temp;
    Temp = (Dev->CardInfo.Cid.Reg[1] & 0xFF000000) >> 24;
    Dev->CardInfo.Cid.Reg[2] = (Dev->CardInfo.Cid.Reg[2] << 8) | Temp;
    Temp = (Dev->CardInfo.Cid.Reg[0] & 0xFF000000) >> 24;
    Dev->CardInfo.Cid.Reg[1] = (Dev->CardInfo.Cid.Reg[1] << 8) | Temp;
    Dev->CardInfo.Cid.Reg[0] = (Dev->CardInfo.Cid.Reg[0] << 8);

    return Ret;
}

static AL_S32 AlMmc_Dev_GetCardAddr(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    if (Dev->CardInfo.CardType == AL_MMC_CARD_TYPE_SD) {
        do {
            Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_3, 0, 0);
            if (Ret != AL_OK) {
                return Ret;
            }

            Dev->CardInfo.RealAddr = AlMmc_ll_ReadResp01(Dev->HwConfig.BaseAddress) & 0xFFFF0000;
            AL_MMC_LOOP_REG_DELAY;
        } while (!Dev->CardInfo.RealAddr);
    } else {
        Dev->CardInfo.RealAddr = 0x10000;
        Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_3, Dev->CardInfo.RealAddr, 0);
        if (Ret != AL_OK) {
            return Ret;
        }
    }

    return Ret;
}

static AL_S32 AlMmc_Dev_GetCsd(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;
    AL_U32 Temp;

    Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_9, Dev->CardInfo.RealAddr, 0);
    if (Ret != AL_OK) {
        return Ret;
    }

    Dev->CardInfo.Csd.Reg[0] = AlMmc_ll_ReadResp01(Dev->HwConfig.BaseAddress);
    Dev->CardInfo.Csd.Reg[1] = AlMmc_ll_ReadResp23(Dev->HwConfig.BaseAddress);
    Dev->CardInfo.Csd.Reg[2] = AlMmc_ll_ReadResp45(Dev->HwConfig.BaseAddress);
    Dev->CardInfo.Csd.Reg[3] = AlMmc_ll_ReadResp67(Dev->HwConfig.BaseAddress);

    AL_LOG(AL_LOG_LEVEL_DEBUG,"CSD [135:8]\r\n");
    AL_LOG(AL_LOG_LEVEL_DEBUG, "CSD: [3] 0X%08x, [2] 0x%08x, [1] 0x%08x, [0] 0x%08x\r\n",
                                     Dev->CardInfo.Csd.Reg[3],
                                     Dev->CardInfo.Csd.Reg[2],
                                     Dev->CardInfo.Csd.Reg[1],
                                     Dev->CardInfo.Csd.Reg[0]);

    Temp = (Dev->CardInfo.Csd.Reg[2] & 0xFF000000) >> 24;
    Dev->CardInfo.Csd.Reg[3] = (Dev->CardInfo.Csd.Reg[3] << 8) | Temp;
    Temp = (Dev->CardInfo.Csd.Reg[1] & 0xFF000000) >> 24;
    Dev->CardInfo.Csd.Reg[2] = (Dev->CardInfo.Csd.Reg[2] << 8) | Temp;
    Temp = (Dev->CardInfo.Csd.Reg[0] & 0xFF000000) >> 24;
    Dev->CardInfo.Csd.Reg[1] = (Dev->CardInfo.Csd.Reg[1] << 8) | Temp;
    Dev->CardInfo.Csd.Reg[0] = (Dev->CardInfo.Csd.Reg[0] << 8);

    AL_LOG(AL_LOG_LEVEL_DEBUG,"CSD [127:0]\r\n");
    AL_LOG(AL_LOG_LEVEL_DEBUG, "CSD: [3] 0X%08x, [2] 0x%08x, [1] 0x%08x, [0] 0x%08x\r\n",
                                     Dev->CardInfo.Csd.Reg[3],
                                     Dev->CardInfo.Csd.Reg[2],
                                     Dev->CardInfo.Csd.Reg[1],
                                     Dev->CardInfo.Csd.Reg[0]);
    AlMmc_Dev_DisplayCsd(Dev);

    return Ret;
}

static AL_S32 AlMmc_Dev_GetCardCap(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;
    AL_U32 DevSize;

    if (Dev->CardInfo.CardType == AL_MMC_CARD_TYPE_SD) {
        AL_LOG(AL_LOG_LEVEL_DEBUG, "Sd CSD struct is ver %d \r\n",Dev->CardInfo.Csd.SdV1.CsdStruct+1);
        if (Dev->CardInfo.Csd.SdV1.CsdStruct == AL_MMC_CSD_VER_SD10_EMMC10) {
            /* Memory capacity = BLOCKNR * BLOCK_LEN */
            /* BLOCKNR = (C_SIZE+1) * MULT */
            /* MULT = 2 ^ (C_SIZE_MULT+2)       ,(C_SIZE_MULT < 8) */
            /* BLOCK_LEN = 2 ^ (READ_BL_LEN)    ,(READ_BL_LEN < 12) */
            DevSize = (Dev->CardInfo.Csd.SdV1.DevSize73_64 << 2) + Dev->CardInfo.Csd.SdV1.DevSize63_62;
            Dev->CardInfo.CardCap   = (DevSize + 1) << ((Dev->CardInfo.Csd.SdV1.DevSizeMulti + 2) +
                                                        Dev->CardInfo.Csd.SdV1.RdBlkLen - 10);
            Dev->CardInfo.BlkLen    = 2 << Dev->CardInfo.Csd.SdV1.RdBlkLen;
        } else {
            /* SDHC/SDXC Memory capacity = (C_SIZE+1) * 512KByte */
            DevSize = (Dev->CardInfo.Csd.SdV2.DevSize69_64 << 16) + Dev->CardInfo.Csd.SdV2.DevSize63_48;
            Dev->CardInfo.CardCap   = (DevSize + 1) << 9;
            Dev->CardInfo.BlkLen    = 2 << Dev->CardInfo.Csd.SdV2.RdBlkLen;
        }
    } else {
        DevSize = (Dev->CardInfo.Csd.Emmc.DevSize73_64 << 2) + Dev->CardInfo.Csd.Emmc.DevSize63_62;
        if (DevSize != 0xFFF) {
            /* Memory capacity = BLOCKNR * BLOCK_LEN */
            /* BLOCKNR = (C_SIZE+1) * MULT */
            /* MULT = 2 ^ (C_SIZE_MULT+2)       ,(C_SIZE_MULT < 8) */
            /* BLOCK_LEN = 2 ^ (READ_BL_LEN)    ,(READ_BL_LEN < 12) */
            Dev->CardInfo.CardCap   = ((DevSize + 1) *
                                       (2 << (Dev->CardInfo.Csd.Emmc.DevSizeMulti + 2)) *
                                       (2 << Dev->CardInfo.Csd.Emmc.RdBlkLen)) >> 10;
        } else {
            /* large than 2GB, capacity store in EXT_CSD */
            AL_LOG(AL_LOG_LEVEL_DEBUG, "Emmc capacity large than 2GB\r\n");
        }
        Dev->CardInfo.BlkLen    = 2 << Dev->CardInfo.Csd.Emmc.RdBlkLen;
    }

    Dev->CardInfo.DevSize   = DevSize;
    Dev->CardInfo.BlkLen    = AL_MMC_FIXED_BLK_LEN;

    AL_LOG(AL_LOG_LEVEL_DEBUG, "Card capacity is %d KByte, blk len is %d\r\n", Dev->CardInfo.CardCap,
                                                                                Dev->CardInfo.BlkLen);

    return Ret;
}

static AL_S32 AlMmc_Dev_SetCardVer(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    if (Dev->CardInfo.CardType == AL_MMC_CARD_TYPE_SD) {
        if (Dev->CardInfo.Scr.Sd.SdSpec4) {
            Dev->CardInfo.CardVer = AL_MMC_CARD_VER_4XX;
        } else if (Dev->CardInfo.Scr.Sd.SdSpec3) {
            Dev->CardInfo.CardVer = AL_MMC_CARD_VER_30X;
        } else if (Dev->CardInfo.Scr.Sd.SdSpec == 0x2) {
            Dev->CardInfo.CardVer = AL_MMC_CARD_VER_200;
        } else {
            /* CMD8 has check v1.01 and v1.10, so do nothing here */
        }
    } else {
        Dev->CardInfo.CardVer = Dev->CardInfo.Csd.Emmc.SpecVers;
    }

    AL_LOG(AL_LOG_LEVEL_DEBUG, "Card version is %d\r\n", Dev->CardInfo.CardVer);

    return Ret;
}

static AL_S32 AlMmc_Dev_SetHostVer(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    if (Dev->CardInfo.CardVer >= AL_MMC_CARD_VER_4XX) {
        /* Auto cmd 23 support */
        AL_MMC_Hc2AcUnion Ctrl2;
        Ctrl2.Reg = AlMmc_ll_ReadAutoCmdStat_CtrlHost2(Dev->HwConfig.BaseAddress);
        Ctrl2.Bit.Cmd23En       = AL_TRUE;
        Ctrl2.Bit.HostVer4En    = AL_TRUE;
        Ctrl2.Bit.Amda2LenMode  = AL_TRUE;  /* For ADMA2 26-bit length mode, extened from ver 4.1 */
        AlMmc_ll_WriteAutoCmdStat_CtrlHost2(Dev->HwConfig.BaseAddress, Ctrl2.Reg);
        Dev->HostInfo.HostVer = AL_MMC_HOST_VER_4;
    } else {
        Dev->HostInfo.HostVer = AL_MMC_HOST_VER_3;
    }

    return AL_OK;
}

static AL_S32 AlMmc_Dev_GetCardInfo(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    Ret = AlMmc_Dev_GetCsd(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    Ret = AlMmc_Dev_GetCardCap(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    return Ret;
}

static AL_S32 AlMmc_Dev_SelDesCard(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_7, Dev->CardInfo.RealAddr, 0);
    if (Ret != AL_OK) {
        return Ret;
    }

    return Ret;
}

static AL_S32 AlMmc_Dev_GetExtCsd(AL_MMC_DevStruct *Dev, AL_U8 *ExtCsd)
{
    AL_ASSERT((Dev != AL_NULL) && (ExtCsd != AL_NULL), AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    Ret = AlMmc_Dev_SetBlkSize(Dev, Dev->CardInfo.BlkLen);
    if (Ret != AL_OK) {
        return Ret;
    }

    Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_8, 0, 1);
    if (Ret != AL_OK) {
        return Ret;
    }

    Ret = AlMmc_Dev_TransferData(Dev, ExtCsd, 1);
    if (Ret != AL_OK) {
        return Ret;
    }

    return Ret;
}

static AL_S32 AlMmc_Dev_GetExtCardCap(AL_MMC_DevStruct *Dev, AL_MMC_RegExtCsdUnion *ExtCsd)
{
    AL_ASSERT((Dev != AL_NULL) && (ExtCsd != AL_NULL), AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;
    AL_U32 SecCount = 0;

    SecCount = *(AL_U32 *)ExtCsd->Emmc.SecCount;

    /* KBytes, fixed 512B blk len */
    Dev->CardInfo.CardCap = SecCount >> 1;

    AL_LOG(AL_LOG_LEVEL_DEBUG, "SecCount: 0x%x, Sec[0]: 0x%x, Sec[1]: 0x%x, Sec[2]: 0x%x, Sec[3]: 0x%x\r\n",
                               SecCount, ExtCsd->Emmc.SecCount[0], ExtCsd->Emmc.SecCount[1], ExtCsd->Emmc.SecCount[2],
                               ExtCsd->Emmc.SecCount[3]);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "Card capacity is %u KByte, blk len is %d\r\n", Dev->CardInfo.CardCap, Dev->CardInfo.BlkLen);

    return Ret;
}

static AL_S32 AlMmc_Dev_GetExtCardInfo(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;
    AL_MMC_RegExtCsdUnion ExtCsd;

    Ret = AlMmc_Dev_GetExtCsd(Dev, (AL_U8 *)&ExtCsd);
    if (Ret != AL_OK) {
        return Ret;
    }

    /* Decode Card capacity */
    Ret = AlMmc_Dev_GetExtCardCap(Dev, &ExtCsd);
    if (Ret != AL_OK) {
        return Ret;
    }

    return Ret;
}

static AL_S32 AlMmc_Dev_SdCardEnum(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    /* Check card detect method, and check is card detected */
    Ret = AlMmc_Dev_CheckCardDetect(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    /*Write cmd 0 to reset card to idle state*/
    Ret = AlMmc_Dev_CardReset(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    /* CMD8 */
    Ret = AlMmc_Dev_CardIfCond(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    /* CMD55/ACMD41, Get the card operating condition */
    Ret = AlMmc_Dev_CardOpCond(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    /* CMD2 */
    Ret = AlMmc_Dev_GetCardId(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    /* CMD3 */
    Ret = AlMmc_Dev_GetCardAddr(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    /* CMD9 and decode CSD register */
    Ret = AlMmc_Dev_GetCardInfo(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    /* CMD7 */
    Ret = AlMmc_Dev_SelDesCard(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    /* CMD55/ACMD51, Read Scr register */
    Ret = AlMmc_Dev_GetCardCfg(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    Ret = AlMmc_Dev_SetCardVer(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    return Ret;
}

static AL_S32 AlMmc_Dev_SetExtCsd(AL_MMC_DevStruct *Dev, AL_U32 Arg)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_6, Arg, 0);
    if (Ret != AL_OK) {
        return Ret;
    }

    return Ret;
}

static AL_S32 AlMmc_Dev_GenCmd6Param(AL_MMC_DevStruct *Dev, AL_MMC_Cmd6FuncEnum Func, AL_MMC_Cmd6ArgUnion *Arg)
{
    AL_ASSERT((Dev != AL_NULL) && (Arg != AL_NULL), AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    if (Dev->CardInfo.CardType == AL_MMC_CARD_TYPE_SD) {
        if (Func == AL_MMC_CMD6_SD_SPD_MODE) {
            switch (Dev->Config.SpdMode)
            {
            case AL_MMC_SPD_DS_SDR12:
                Arg->Reg             = 0x0;
                Arg->Sd.Mode         = 0x1;
                Arg->Sd.Rsvd30_24    = 0x0;
                Arg->Sd.RsvdGrp6     = 0xF;
                Arg->Sd.RsvdGrp5     = 0xF;
                Arg->Sd.RsvdGrp4     = 0xF;
                Arg->Sd.RsvdGrp3     = 0xF;
                Arg->Sd.Grp2Cmd      = 0xF;
                Arg->Sd.Grp1AccMode  = AL_MMC_SPD_DS_SDR12;
                break;
            case AL_MMC_SPD_HS_SDR25:
                Arg->Reg             = 0x0;
                Arg->Sd.Mode         = 0x1;
                Arg->Sd.Rsvd30_24    = 0x0;
                Arg->Sd.RsvdGrp6     = 0xF;
                Arg->Sd.RsvdGrp5     = 0xF;
                Arg->Sd.RsvdGrp4     = 0xF;
                Arg->Sd.RsvdGrp3     = 0xF;
                Arg->Sd.Grp2Cmd      = 0xF;
                Arg->Sd.Grp1AccMode  = AL_MMC_SPD_HS_SDR25;
                break;
            default:
                Ret = AL_MMC_ERR_UNSPT_SPD_MODE;
                break;
            }
        } else {
            AL_LOG(AL_LOG_LEVEL_DEBUG, "Unsupport SD Cmd6 func\r\n");
            Ret = AL_MMC_ERR_UNSPT_CMD6_FUNC;
        }
    } else {
        if (Func == AL_MMC_CMD6_EMMC_FUNC_BUS_WIDTH) {
            Arg->Reg         = 0;
            Arg->Emmc.Index  = AL_MMC_CMD6_EMMC_FUNC_BUS_WIDTH;
            /* 1-bit enum 1 >> 2 -> 0b00, 4-bit enum 4 >> 2 -> 0b01, 8-bit enum 8 >> 2 -> 0b10 */
            Arg->Emmc.Value  = Dev->Config.BusWidth >> 2;
            Arg->Emmc.Access = AL_MMC_CMD6_EMMC_ACCESS_WR_BYTE;
        } else if (Func == AL_MMC_CMD6_EMMC_FUNC_HS_TIMING) {
            switch (Dev->Config.SpdMode)
            {
            case AL_MMC_SPD_DS_SDR12:
                Arg->Reg                = 0x0;
                Arg->Emmc.SetZero31_26  = 0x0;
                Arg->Emmc.Access        = AL_MMC_CMD6_EMMC_ACCESS_WR_BYTE;
                Arg->Emmc.Index         = AL_MMC_CMD6_EMMC_FUNC_HS_TIMING;
                Arg->Emmc.Value         = AL_MMC_SPD_DS_SDR12;
                Arg->Emmc.SetZero7_3    = 0x0;
                Arg->Emmc.CmdSet        = 0x0;
                break;
            case AL_MMC_SPD_HS_SDR25:
                Arg->Reg                = 0x0;
                Arg->Emmc.SetZero31_26  = 0x0;
                Arg->Emmc.Access        = AL_MMC_CMD6_EMMC_ACCESS_WR_BYTE;
                Arg->Emmc.Index         = AL_MMC_CMD6_EMMC_FUNC_HS_TIMING;
                Arg->Emmc.Value         = AL_MMC_SPD_HS_SDR25;
                Arg->Emmc.SetZero7_3    = 0x0;
                Arg->Emmc.CmdSet        = 0x0;
                break;
            default:
                Ret = AL_MMC_ERR_UNSPT_SPD_MODE;
                break;
            }
        } else {
            AL_LOG(AL_LOG_LEVEL_DEBUG, "Unsupport eMMC Cmd6 func\r\n");
            Ret = AL_MMC_ERR_UNSPT_CMD6_FUNC;
        }
    }

    return Ret;
}

static AL_S32 AlMmc_Dev_SetBusWidth(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    if (Dev->CardInfo.CardType == AL_MMC_CARD_TYPE_SD) {
        if (Dev->CardInfo.Scr.Sd.SdBusWidth & AL_MMC_BUS_WIDTH_4BIT) {
            /* Card support 1-bit and 4-bit bus width */
            if (Dev->Config.BusWidth > AL_MMC_BUS_WIDTH_4BIT) {
                AL_LOG(AL_LOG_LEVEL_INFO, "Config bus width %d-bit not support, modify to %d-bit\r\n", Dev->Config.BusWidth,
                    AL_MMC_BUS_WIDTH_4BIT);
                Dev->Config.BusWidth = AL_MMC_BUS_WIDTH_4BIT;
            } else {
                AL_LOG(AL_LOG_LEVEL_INFO, "Bus width is 4-bit\r\n");
            }
        } else {
            /* Card only support 1-bit bus width */
            AL_LOG(AL_LOG_LEVEL_INFO, "Card only support bus width %d-bit, bus width:0x%x\r\n",
                                      AL_MMC_BUS_WIDTH_1BIT, Dev->CardInfo.Scr.Sd.SdBusWidth);
            Dev->Config.BusWidth = AL_MMC_BUS_WIDTH_1BIT;
        }

        Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_55, Dev->CardInfo.RealAddr, 0);
        if (Ret != AL_OK) {
            return Ret;
        }

        /* 1-bit enum 1 >> 1 -> 0b00, 4-bit enum 4 >> 1 -> 0b10 */
        Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_ACMD_IDX_6, (Dev->Config.BusWidth >> 1), 0);
        if (Ret != AL_OK) {
            return Ret;
        }
    } else {
        if ((!Dev->HostInfo.Cap1.Bit.Embedded8Bit) && (Dev->Config.BusWidth == AL_MMC_BUS_WIDTH_8BIT)) {
            AL_LOG(AL_LOG_LEVEL_INFO, "Host not support 8-bit, set to 4-bit\r\n");
            Dev->Config.BusWidth = AL_MMC_BUS_WIDTH_4BIT;
        }

        AL_MMC_Cmd6ArgUnion Arg = {.Reg = 0};
        AlMmc_Dev_GenCmd6Param(Dev, AL_MMC_CMD6_EMMC_FUNC_BUS_WIDTH, &Arg);

        Ret = AlMmc_Dev_SetExtCsd(Dev, Arg.Reg);
        if (Ret != AL_OK) {
            return Ret;
        }
    }

    /* Delay for switch complete */
    AL_MMC_SWITCH_DELAY;

    /* Set host bus width */
    if (Dev->Config.BusWidth != AL_MMC_BUS_WIDTH_1BIT) {
        AL_MMC_CtrlWuBgPwHc1Union Ctrl;
        Ctrl.Reg = AlMmc_ll_ReadCtrl_Wup_Bgap_Pwr_Host1(Dev->HwConfig.BaseAddress);

        Ctrl.Bit.DatXferWidth = AL_TRUE;

        if (Dev->Config.BusWidth == AL_MMC_BUS_WIDTH_8BIT) {
            Ctrl.Bit.ExtDatXfer = AL_TRUE;
        }

        AlMmc_ll_WriteCtrl_Wup_Bgap_Pwr_Host1(Dev->HwConfig.BaseAddress, Ctrl.Reg);
    }

    Dev->CardInfo.BusWidth = Dev->Config.BusWidth;

    return Ret;
}

static AL_S32 AlMmc_Dev_GetBusSpeed(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;
    /* TODO: */
    return Ret;
}

static AL_S32 AlMmc_Dev_SetBusSpeed(AL_MMC_DevStruct *Dev)
{
    AL_S32 Ret = AL_OK;
    AL_MMC_Cmd6ArgUnion Arg;

    if (Dev->CardInfo.CardType == AL_MMC_CARD_TYPE_SD) {
        AL_U32 RestoreBlkLen = Dev->CardInfo.BlkLen;
        AL_U8 Temp[64] = {0};

        AlMmc_Dev_SetBlkSize(Dev, AL_MMC_BLK_LEN_64B);
        Dev->CardInfo.BlkLen = AL_MMC_BLK_LEN_64B;

        Ret = AlMmc_Dev_GenCmd6Param(Dev, AL_MMC_CMD6_SD_SPD_MODE, &Arg);
        if (Ret != AL_OK) {
            return Ret;
        }

        Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_6, Arg.Reg, 1);
        if (Ret != AL_OK) {
            return Ret;
        }

        Ret = AlMmc_Dev_TransferData(Dev, &Temp[0], 1);
        if (Ret != AL_OK) {
            return Ret;
        }

        Dev->CardInfo.BlkLen = RestoreBlkLen;

        /* Check bus speed bit set result */
        if (!(Temp[16] & 0x1)) {
            return AL_MMC_ERR_SET_BUS_SPEED;
        }

        for (AL_U32 j = 0; j < AL_MMC_BLK_LEN_64B; j++) {
            AL_LOG(AL_LOG_LEVEL_DEBUG, "[%d]:0x%02x ", j, Temp[j]);
        }
        AL_LOG(AL_LOG_LEVEL_DEBUG, "\r\n");
    } else {
        Ret = AlMmc_Dev_GenCmd6Param(Dev, AL_MMC_CMD6_EMMC_FUNC_HS_TIMING, &Arg);
        if (Ret != AL_OK) {
            return Ret;
        }

        Ret = AlMmc_Dev_SetExtCsd(Dev, Arg.Reg);
        if (Ret != AL_OK) {
            return Ret;
        }

        AL_MMC_RegExtCsdUnion ExtCsd;
        Ret = AlMmc_Dev_GetExtCsd(Dev, (AL_U8 *)&ExtCsd);
        if (Ret != AL_OK) {
            return Ret;
        }

        if (Dev->Config.SpdMode == AL_MMC_SPD_HS_SDR25) {
            if (ExtCsd.Emmc.HsTiming != AL_MMC_SPD_HS_SDR25) {
                AL_LOG(AL_LOG_LEVEL_DEBUG, "eMMC set bus high speed err\r\n");
                return MMC_ERR_SET_BUS_SPEED;
            }
        }
    }

    /* Delay for switch complete */
    AL_MMC_SWITCH_DELAY;

    AL_MMC_CtrlWuBgPwHc1Union Ctrl1;
    Ctrl1.Reg = AlMmc_ll_ReadCtrl_Wup_Bgap_Pwr_Host1(Dev->HwConfig.BaseAddress);
    Ctrl1.Bit.HiSpdEn = 0x1;
    AlMmc_ll_WriteCtrl_Wup_Bgap_Pwr_Host1(Dev->HwConfig.BaseAddress, Ctrl1.Reg);

    /* Delay for switch complete */
    AL_MMC_SWITCH_DELAY;

    return Ret;
}

static AL_S32 AlMmc_Dev_SetBlkSize(AL_MMC_DevStruct *Dev, AL_MMC_BlkLenEnum BlkLen)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    Ret = AlMmc_Dev_CheckLineIdle(Dev, AL_MMC_STATE_MASK_CMD_LINE_BOTH |
                                       AL_MMC_STATE_MASK_WR_ACTIVE |
                                       AL_MMC_STATE_MASK_RD_ACTIVE);
    if (Ret != AL_OK) {
        AL_LOG(AL_LOG_LEVEL_ERROR, "Set blk size check line idle error\r\n");
        return Ret;
    }

    Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_16, BlkLen, 0);
    if (Ret != AL_OK) {
        AL_LOG(AL_LOG_LEVEL_ERROR, "Set blk size CMD 16 error\r\n");
        return Ret;
    }

    AlMmc_ll_SetTransBlkSize(Dev->HwConfig.BaseAddress, BlkLen);

    return Ret;
}

static AL_S32 AlMmc_Dev_SdModeInit(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    /* Already read scr register in AlMmc_Dev_GetCardCfg */
    Ret = AlMmc_Dev_SetBusWidth(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    if (Dev->Config.SpdMode != AL_MMC_SPD_DS_SDR12 && Dev->CardInfo.HiCap == AL_TRUE) {
        Ret = AlMmc_Dev_GetBusSpeed(Dev);

        /* Support CMD6 */
        if (Dev->CardInfo.CardVer != AL_MMC_CARD_VER_101) {
            Ret = AlMmc_Dev_SetBusSpeed(Dev);
            if (Ret != AL_OK) {
                AL_LOG(AL_LOG_LEVEL_DEBUG, "Request high speed mode error, set default mode\r\n");
                Dev->CardInfo.SpdMode = AL_MMC_SPD_DS_SDR12;
                /* Modify speed for default mode */
                if (Dev->Config.FreqKhz > AL_MMC_FREQ_KHZ_25000) {
                    Dev->Config.FreqKhz = AL_MMC_FREQ_KHZ_25000;
                }
            } else {
                Dev->CardInfo.SpdMode = AL_MMC_SPD_HS_SDR25;
            }
        }
    } else {
        Dev->CardInfo.SpdMode = AL_MMC_SPD_DS_SDR12;
        /* Modify speed for default mode */
        if (Dev->Config.FreqKhz > AL_MMC_FREQ_KHZ_25000) {
            Dev->Config.FreqKhz = AL_MMC_FREQ_KHZ_25000;
        }
    }

    /* Change host controller freq */
    Ret = AlMmc_Dev_SetClkFreq(Dev, Dev->Config.FreqKhz);
    if (Ret != AL_OK) {
        return Ret;
    }

    Ret = AlMmc_Dev_SetBlkSize(Dev, Dev->CardInfo.BlkLen);
    if (Ret != AL_OK) {
        return Ret;
    }

    return Ret;
}

AL_S32 AlMmc_Dev_SdCardInit(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    Ret = AlMmc_Dev_SdCardEnum(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    Ret = AlMmc_Dev_SdModeInit(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    return Ret;
}

static AL_S32 AlMmc_Dev_EmmcCardEnum(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    /* Check card detect method, and check is card detected */
    Ret = AlMmc_Dev_CheckCardDetect(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    /*Write cmd 0 to reset card to idle state*/
    Ret = AlMmc_Dev_CardReset(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    /* CMD1 */
    Ret = AlMmc_Dev_CardOpCond(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    /* CMD2 */
    Ret = AlMmc_Dev_GetCardId(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    /* CMD3 */
    Ret = AlMmc_Dev_GetCardAddr(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    /* CMD9 and decode CSD register */
    Ret = AlMmc_Dev_GetCardInfo(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    /* CMD7 */
    Ret = AlMmc_Dev_SelDesCard(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    if (Dev->CardInfo.DevSize == 0xFFF) {
        /* CMD8, get EXT_CSD for card capacity */
        Ret = AlMmc_Dev_GetExtCardInfo(Dev);
        if (Ret != AL_OK) {
            return Ret;
        }
    }

    Ret = AlMmc_Dev_SetCardVer(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    return Ret;
}

static AL_S32 AlMmc_Dev_EmmcModeInit(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;
    AL_MMC_RegExtCsdUnion ExtCsd;

    Ret = AlMmc_Dev_SetBusWidth(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    if (Dev->Config.SpdMode != AL_MMC_SPD_DS_SDR12) {
        Ret = AlMmc_Dev_GetBusSpeed(Dev);

        if (Dev->Config.Switch1v8) {

        }

        Ret = AlMmc_Dev_SetBusSpeed(Dev);
        if (Ret != AL_OK) {
            return Ret;
        }
        Dev->CardInfo.SpdMode = AL_MMC_SPD_HS_SDR25;
    } else {
        Dev->CardInfo.SpdMode = AL_MMC_SPD_DS_SDR12;
    }

    /* Change host controller freq */
    Ret = AlMmc_Dev_SetClkFreq(Dev, Dev->Config.FreqKhz);
    if (Ret != AL_OK) {
        return Ret;
    }

    /* Do a transfer to check the configuration */
    if ((Dev->Config.BusWidth != AL_MMC_BUS_WIDTH_1BIT) && (Dev->CardInfo.SpdMode != AL_MMC_SPD_DS_SDR12)) {
        Ret = AlMmc_Dev_GetExtCsd(Dev, (AL_U8 *)&ExtCsd);
        if (Ret != AL_OK) {
            AL_LOG(AL_LOG_LEVEL_ERROR, "eMMC error after set high speed mode, need set mio speed mode to fast mode\r\n");
            return Ret;
        }
    }

    Ret = AlMmc_Dev_SetBlkSize(Dev, Dev->CardInfo.BlkLen);
    if (Ret != AL_OK) {
        return Ret;
    }

    return Ret;
}

AL_S32 AlMmc_Dev_EmmcCardInit(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    Ret = AlMmc_Dev_EmmcCardEnum(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    Ret = AlMmc_Dev_EmmcModeInit(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    return Ret;
}

AL_S32 AlMmc_Dev_Init(AL_MMC_DevStruct *Dev, AL_MMC_HwConfigStruct *HwConfig, AL_MMC_InitStruct *InitConfig)
{
    AL_ASSERT((Dev != AL_NULL) && (HwConfig != AL_NULL), AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    if (AlMmc_Dev_GetState(Dev, AL_MMC_STATE_READY)) {
        if (InitConfig == AL_NULL || IS_SAME_INITCONFIGS(Dev->Config, *InitConfig)) {
            return AL_OK;
        }
    }

    Dev->Config     = (InitConfig == AL_NULL) ? AlMmc_DefInitConfig : (*InitConfig);
    Dev->HwConfig   = *HwConfig;

    /* Clear all state */
    AlMmc_Dev_ClrState(Dev, AL_MMC_STATE_ALL_MASK);

    /* Init top config register from TD */
    AlMmc_Dev_TopCfgInit(Dev);

    /* Get host controller supported function */
    AlMmc_Dev_GetHostInfo(Dev);

    /* Set up host controller */
    AlMmc_Dev_SetUpHostController(Dev);

    /* Set intr state en and intr signal en(if USE_RTOS) */
    AlMmc_ll_WriteIntrStatEn(Dev->HwConfig.BaseAddress, 0xFFFFFEFF);
    // AlMmc_ll_WriteIntrSigEn(Dev->HwConfig.BaseAddress, 0xFFFFFFFF);

    if (Dev->Config.CardType >= AL_MMC_CARD_TYPE_MAX) {
        AL_LOG(AL_LOG_LEVEL_ERROR, "Invalid card type config\r\n");
        return AL_MMC_ERR_INVALID_CARD;
    } else if (Dev->Config.CardType == AL_MMC_CARD_TYPE_AUTO_DETECT) {
        /* Identify detected card is SD or eMMC */
        Ret = AlMmc_Dev_IdentifyCard(Dev);
        if (Ret != AL_OK) {
            AL_LOG(AL_LOG_LEVEL_ERROR, "Identify Card failed, err code 0x%x\r\n", Ret);
            return Ret;
        }
    } else {
        Dev->CardInfo.CardType = Dev->Config.CardType;
    }

    if (Dev->CardInfo.CardType == AL_MMC_CARD_TYPE_SD) {
        Ret = AlMmc_Dev_SdCardInit(Dev);
    } else if (Dev->CardInfo.CardType == AL_MMC_CARD_TYPE_EMMC) {
        Ret = AlMmc_Dev_EmmcCardInit(Dev);
    } else {
        AL_LOG(AL_LOG_LEVEL_ERROR, "Invalid or not support card\r\n");
        return AL_MMC_ERR_INVALID_CARD;
    }

    if (Ret != AL_OK) {
        AL_LOG(AL_LOG_LEVEL_ERROR, "Card %s Init error, err code 0x%x\r\n",
               (Dev->CardInfo.CardType == AL_MMC_CARD_TYPE_SD) ? "SD" : "eMMC", Ret);
        return Ret;
    }

    AlMmc_Dev_SetHostVer(Dev);

    AlMmc_Dev_DisplayCardInfo(Dev);
    AlMmc_Dev_SetState(Dev, AL_MMC_STATE_READY);

    return Ret;
}

/**
 * This function register interrupt call back function
 * @param   Dev is pointer to AL_MMC_DevStruct
 * @param   CallBack is call back struct with AL_MMC_EventCallBack
 * @return
 *          - AL_OK is register correct
 * @note
*/
AL_S32 AlMmc_Dev_RegisterEventCallBack(AL_MMC_DevStruct *Dev, AL_MMC_EventCallBack CallBack, AL_VOID *CallBackRef)
{
    AL_ASSERT((Dev != AL_NULL) && (CallBack != AL_NULL), AL_MMC_ERR_NULL_PTR);

    if (Dev->EventCallBack != AL_NULL) {
        AL_LOG(AL_LOG_LEVEL_WARNING, "mmc=%p duplicate register callback: replace old:%p with New: %p\r\n",
               Dev, Dev->EventCallBack, CallBack);
    }

    Dev->EventCallBack = CallBack;
    Dev->EventCallBackRef  = CallBackRef;

    return AL_OK;
}

/**
 * This function unregister interrupt call back function
 * @param   Dev is pointer to AL_MMC_DevStruct
 * @return
 *          - AL_OK is unregister correct
 * @note
*/
AL_S32 AlMmc_Dev_UnRegisterEventCallBack(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    Dev->EventCallBack = (AL_MMC_EventCallBack)AL_NULL;

    return AL_OK;
}

/**
 * This function look up hardware config structure
 * @param   DeviceId is hardware module id
 * @return  hardware config structure with AL_MMC_HwConfigStruct
 * @note
*/
AL_MMC_HwConfigStruct *AlMmc_Dev_LookupConfig(AL_U32 DeviceId)
{
    AL_U32 Index;
    AL_MMC_HwConfigStruct *CfgPtr = AL_NULL;

    for (Index = 0; Index < AL_MMC_NUM_INSTANCE; Index++) {
        if (AlMmc_HwConfig[Index].DeviceId == DeviceId) {
            CfgPtr = &AlMmc_HwConfig[Index];
            break;
        }
    }

    return CfgPtr;
}

static AL_S32 AlMmc_Dev_TransferConfig(AL_MMC_DevStruct *Dev)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    /* TODO: Check is card inserted and blk size if set */

    return Ret;
}

static AL_S32 AlMmc_Dev_SetUpAdma2DescTable(AL_MMC_DevStruct *Dev, AL_U8 *Buf, AL_U32 BlkCnt)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;
    AL_MMC_AdmaDescUnion *Desc = &Dev->AdmaDesc[0];
    AL_U32 TotalDescSize;
    AL_U32 TotalByteSize = Dev->CardInfo.BlkLen * BlkCnt;
    AL_U32 DescMaxLength;
    AL_U32 DescLengthSize;
    AL_U32 DescLengthSizeLo;
    AL_U32 DescLengthSizeHi;

    if (Dev->HostInfo.HostVer == AL_MMC_HOST_VER_4) {
        DescMaxLength       = AL_MMC_ADMA2_DESC_26BIT_LENGTH;
        DescLengthSize      = AL_MMC_ADMA2_26BIT_LENGTH_SIZE;
        DescLengthSizeLo    = AL_MMC_ADMA2_26BIT_LENGTH_SIZE_LO;
        DescLengthSizeHi    = AL_MMC_ADMA2_26BIT_LENGTH_SIZE_HI;
    } else {
        DescMaxLength       = AL_MMC_ADMA2_DESC_16BIT_LENGTH;
        DescLengthSize      = AL_MMC_ADMA2_16BIT_LENGTH_SIZE;
        DescLengthSizeLo    = AL_MMC_ADMA2_16BIT_LENGTH_SIZE_LO;
        DescLengthSizeHi    = AL_MMC_ADMA2_16BIT_LENGTH_SIZE_HI;
    }

    if (TotalByteSize <= DescMaxLength) {
        TotalDescSize = 1;
    } else {
        TotalDescSize = (TotalByteSize >> DescLengthSize);
        if (TotalByteSize & DescMaxLength) {
            TotalDescSize += 1;
        }

        if (TotalDescSize > AL_MMC_ADMA_TABLE_SIZE) {
            AL_LOG(AL_LOG_LEVEL_ERROR, "Trans size out of range, need increase AL_MMC_ADMA_TABLE_SIZE\r\n");
        }
    }

    for (AL_UINTPTR i = 0; i < TotalDescSize; i++) {
        Desc->Bit.AddrArgPtr    = (AL_U32)((AL_UINTPTR)Buf + (i << DescLengthSize));
        Desc->Bit.Valid         = AL_TRUE;
        // Desc->Bit.Int           = AL_TRUE;
        Desc->Bit.Act           = AL_MMC_ADMA_ACT_TRANS;

        if (i == (TotalDescSize - 1)) {
            Desc->Bit.End       = AL_TRUE;
            Desc->Bit.LowerLen  = (TotalByteSize & ((1 << DescLengthSizeLo) - 1));
            Desc->Bit.UpperLen  = ((TotalByteSize & DescMaxLength) >> DescLengthSizeLo);
        } else {
            Desc->Bit.End       = AL_FALSE;
            Desc->Bit.LowerLen  = ((1 << DescLengthSizeLo) - 1);
            Desc->Bit.UpperLen  = ((1 << DescLengthSizeHi) - 1);
        }
    }

#ifdef ENABLE_MMU
    AlCache_FlushDcacheRange((AL_UINTPTR)Desc, (AL_UINTPTR)(Desc + sizeof(AL_MMC_AdmaDescUnion) * AL_MMC_ADMA_TABLE_SIZE));
#endif

    AlMmc_Dev_DisplayAdmaDesc(Desc, TotalDescSize);

    return Ret;
}

static AL_S32 AlMmc_Dev_DmaSetUp(AL_MMC_DevStruct *Dev, AL_U8 *Buf, AL_U32 BlkCnt)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    /* Attention: Block cnt move to cmd config */
    switch (Dev->Config.DmaMode)
    {
    case AL_MMC_DMA_MODE_NONE:
        break;
    case AL_MMC_DMA_MODE_SDMA:
        if (Dev->HostInfo.HostVer == AL_MMC_HOST_VER_3) {
            AlMmc_ll_WriteBlkCnt_SdmaSysAddr(Dev->HwConfig.BaseAddress, (AL_U32)(AL_UINTPTR)Buf);
        } else {
            AlMmc_ll_WriteAdmaSysAddrLow(Dev->HwConfig.BaseAddress, (AL_U32)(AL_UINTPTR)Buf);
        }
        break;
    case AL_MMC_DMA_MODE_ADMA2:
        if (Dev->Config.AutoGenAdmaTblEn) {
            Ret = AlMmc_Dev_SetUpAdma2DescTable(Dev, Buf, BlkCnt);
            if (Ret != AL_OK) {
                return Ret;
            }
            AlMmc_ll_WriteAdmaSysAddrLow(Dev->HwConfig.BaseAddress, (AL_U32)(AL_UINTPTR)&Dev->AdmaDesc[0]);
        } else {
            #ifdef ENABLE_MMU
            /* TODO: need check every desc and flush write or invalidate read memory range here */
            #endif
            AlMmc_ll_WriteAdmaSysAddrLow(Dev->HwConfig.BaseAddress, (AL_U32)(AL_UINTPTR)Buf);
        }
        break;
    case AL_MMC_DMA_MODE_ADMA3:
        AlMmc_ll_WriteAdmaIdLow(Dev->HwConfig.BaseAddress, (AL_U32)(AL_UINTPTR)Buf);
        break;
    default:
        break;
    }

    return Ret;
}

static AL_S32 AlMmc_Dev_CheckTransferDone(AL_MMC_DevStruct *Dev, AL_U32 BlkCnt)
{
    AL_S32 Ret = AL_OK;
    volatile AL_MMC_IntrUnion IntrStat   = {0};
    /* Set Max for large blk cnt transfer */
    AL_U32 Timeout = AL_MMC_CHK_TOUT_XFER_DONE * BlkCnt;

    do {
        IntrStat.Reg = AlMmc_ll_ReadIntrStat(Dev->HwConfig.BaseAddress);


        if (IntrStat.Reg != 0)
            AL_LOG(AL_LOG_LEVEL_DEBUG, "Transfer state: 0x%x\r\n", IntrStat.Reg);

        if (IntrStat.Bit.ErrIntr) {
            if (IntrStat.Bit.AdmaErr && ((Dev->Config.DmaMode == AL_MMC_DMA_MODE_SDMA) ||
                                         (Dev->Config.DmaMode == AL_MMC_DMA_MODE_ADMA2) ||
                                         (Dev->Config.DmaMode == AL_MMC_DMA_MODE_ADMA3))) {
                /* TODO: ADMA abort operation */
                AL_LOG(AL_LOG_LEVEL_ERROR, "Adma error\r\n");
            }

            return AlMmc_Dev_CheckErrStat(Dev, IntrStat);
        }

        if ((AlMmc_Dev_GetState(Dev, AL_MMC_STATE_READY)) && (Dev->Config.DmaMode == AL_MMC_DMA_MODE_SDMA) &&
            IntrStat.Bit.DmaIntr && (!IntrStat.Bit.XferComp)) {
            volatile AL_U32 SdmaAddr = AlMmc_ll_ReadAdmaSysAddrLow(Dev->HwConfig.BaseAddress);
            IntrStat.Reg = 0;
            IntrStat.Bit.DmaIntr = AL_TRUE;
            AlMmc_ll_WriteIntrStat(Dev->HwConfig.BaseAddress, IntrStat.Reg);

            AL_LOG(AL_LOG_LEVEL_DEBUG, "Sdma intr Addr: 0x%x\r\n", SdmaAddr);

            AlMmc_ll_WriteAdmaSysAddrLow(Dev->HwConfig.BaseAddress, SdmaAddr);
        }

        AL_MMC_LOOP_REG_DELAY;
        Timeout--;
    } while ((!IntrStat.Bit.XferComp) && Timeout);

    if (!Timeout) {
        return AL_MMC_ERR_XFER_COMP_TIMEOUT;
    }

    AL_LOG(AL_LOG_LEVEL_DEBUG, "Cur timeout: %d\r\n", Timeout);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "Transfer done state: 0x%x\r\n", IntrStat.Reg);

    IntrStat.Reg            = 0;
    IntrStat.Bit.XferComp   = AL_TRUE;
    IntrStat.Bit.DmaIntr    = AL_TRUE;
    AlMmc_ll_WriteIntrStat(Dev->HwConfig.BaseAddress, IntrStat.Reg);

    return Ret;
}

static AL_VOID AlMmc_Dev_CarryBlkData(AL_MMC_DevStruct *Dev, AL_U8 *Mem)
{
    AL_U32 WordBlkLen = Dev->CardInfo.BlkLen >> 2;
    AL_U32 *Addr = (AL_U32 *)Mem;

    if (Dev->HostInfo.Dir == AL_MMC_TRANS_DIR_WRITE) {
        for (AL_U32 i = 0; i < WordBlkLen; i++) {
            AlMmc_ll_WriteBufferData(Dev->HwConfig.BaseAddress, *Addr);
            Addr++;
        }
    } else {
        for (AL_U32 i = 0; i < WordBlkLen; i++) {
            *Addr = AlMmc_ll_ReadBufferData(Dev->HwConfig.BaseAddress);
            Addr++;
        }
    }
}

static AL_S32 AlMmc_Dev_TransferNoDma(AL_MMC_DevStruct *Dev, AL_U8 *Buf, AL_U32 BlkCnt)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;
    volatile AL_MMC_IntrUnion IntrStat   = {0};
    volatile AL_MMC_CurStatUnion CurStat = {0};
    AL_U32 Timeout = AL_MMC_CHK_TOUT_XFER_NO_DMA;
    AL_U8 *MemAddr = Buf;
    AL_BOOL Done = AL_FALSE;
    AL_U32 Cnt = 0;

    do {
        IntrStat.Reg = AlMmc_ll_ReadIntrStat(Dev->HwConfig.BaseAddress);

        if (IntrStat.Reg) {
            AL_LOG(AL_LOG_LEVEL_DEBUG, "No dma state 0x%x\r\n", IntrStat.Reg);
        }

        if (IntrStat.Bit.ErrIntr) {
            return AlMmc_Dev_CheckErrStat(Dev, IntrStat);
        }

        if (!Done && (IntrStat.Bit.BuffRdRdy || IntrStat.Bit.BuffWrRdy)) {
            CurStat.Reg = AlMmc_ll_ReadCurState(Dev->HwConfig.BaseAddress);
            if (!(CurStat.Bit.BuffRdEn || CurStat.Bit.BuffWrEn)) {
                continue;
            }
            IntrStat.Reg = 0;
            IntrStat.Bit.BuffRdRdy = AL_TRUE;
            IntrStat.Bit.BuffWrRdy = AL_TRUE;
            AlMmc_ll_WriteIntrStat(Dev->HwConfig.BaseAddress, IntrStat.Reg);

            AlMmc_Dev_CarryBlkData(Dev, MemAddr);

            MemAddr += Dev->CardInfo.BlkLen;
            Timeout = AL_MMC_CHK_TOUT_XFER_NO_DMA;
            if (++Cnt >= BlkCnt) {
                Done = AL_TRUE;
                continue;
            }
        }

        AL_MMC_LOOP_REG_DELAY;
    } while ((!IntrStat.Bit.XferComp) && (--Timeout));

    AL_LOG(AL_LOG_LEVEL_DEBUG, "No dma blk cnt %d, mem addr  %p\r\n", Cnt, MemAddr);
    if (!Timeout) {
        AL_LOG(AL_LOG_LEVEL_ERROR, "Transfer no dma timeout\r\n");
        return AL_MMC_ERR_XFER_COMP_TIMEOUT;
    }

    return Ret;
}

static AL_S32 AlMmc_Dev_TransferData(AL_MMC_DevStruct *Dev, AL_U8 *Buf, AL_U32 BlkCnt)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    if ((Dev->Config.DmaMode == AL_MMC_DMA_MODE_NONE) || (!AlMmc_Dev_GetState(Dev, AL_MMC_STATE_READY))) {
        Ret = AlMmc_Dev_TransferNoDma(Dev, Buf, BlkCnt);
        if (Ret != AL_OK) {
            AL_LOG(AL_LOG_LEVEL_ERROR, "Transfer no dma error\r\n");
            return Ret;
        }
    }

    Ret = AlMmc_Dev_CheckTransferDone(Dev, BlkCnt);
    if (Ret != AL_OK) {
        AL_LOG(AL_LOG_LEVEL_ERROR, "Check transfer done error\r\n");
        return Ret;
    }

    return Ret;
}

static AL_S32 AlMmc_Dev_WriteData(AL_MMC_DevStruct *Dev, AL_U8 *Buf, AL_U32 Arg, AL_U32 BlkCnt)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    if (!AlMmc_Dev_GetState(Dev, AL_MMC_STATE_READY)) {
        return AL_MMC_ERR_STATE_NOT_READY;
    }

    if (AlMmc_Dev_GetState(Dev, AL_MMC_STATE_READ_BUSY | AL_MMC_STATE_WRITE_BUSY)) {
        return AL_MMC_ERR_TRANS_BUSY;
    }

    AlMmc_Dev_SetState(Dev, AL_MMC_STATE_WRITE_BUSY);

    Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_16, Dev->CardInfo.BlkLen, 0);
    if (Ret != AL_OK) {
        return Ret;
    }

    Ret = AlMmc_Dev_DmaSetUp(Dev, Buf, BlkCnt);
    if (Ret != AL_OK) {
        return Ret;
    }

#ifdef ENABLE_MMU
    if (Dev->Config.AutoGenAdmaTblEn || Dev->Config.DmaMode != AL_MMC_DMA_MODE_ADMA2) {
        AlCache_FlushDcacheRange((AL_UINTPTR)Buf, (AL_UINTPTR)(Buf + BlkCnt * Dev->CardInfo.BlkLen));
        AL_LOG(AL_LOG_LEVEL_DEBUG, "Flush start: 0x%lx, end: 0x%lx\r\n",
               (AL_UINTPTR)Buf, (AL_UINTPTR)(Buf + BlkCnt * Dev->CardInfo.BlkLen));
    }
#endif

    if (Dev->Config.DmaMode != AL_MMC_DMA_MODE_ADMA3) {
        if ((Dev->CardInfo.CardVer < AL_MMC_CARD_VER_200) && (Dev->CardInfo.CardType == AL_MMC_CARD_TYPE_SD)) {
            Arg *= AL_MMC_BLK_LEN_512B;
        }

        if (BlkCnt > 1) {
            Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_25, Arg, BlkCnt);
        } else {
            Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_24, Arg, BlkCnt);
        }

        if (Ret != AL_OK) {
            return Ret;
        }
    }

    Ret = AlMmc_Dev_TransferData(Dev, Buf, BlkCnt);
    if (Ret != AL_OK) {
        return Ret;
    }

    if (Dev->HostInfo.HostVer == AL_MMC_HOST_VER_3 && BlkCnt > 1) {
        Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_12, 0, 0);
        if (Ret != AL_OK) {
            return Ret;
        }
    }

    AlMmc_Dev_ClrState(Dev, AL_MMC_STATE_WRITE_BUSY);

    return Ret;
}

/* When ADMA2 mode and auto gen desc is false, buf is pointer of desc list */
AL_S32 AlMmc_Dev_Write(AL_MMC_DevStruct *Dev, AL_U8 *Buf, AL_U32 BlkOffset, AL_U32 BlkCnt)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);
    AL_ASSERT(!((AL_UINTPTR)Buf & AL_MMC_BUF_ALIGN_MASK), AL_MMC_ERR_BUF_NOT_ALIGN);

    AL_S32 Ret = AL_OK;

    /* Maybe real address in ddr */
    if (Buf == AL_NULL) {
        AL_LOG(AL_LOG_LEVEL_WARNING, "WARNING: Write addr %p\r\n", Buf);
    }
    AL_LOG(AL_LOG_LEVEL_DEBUG, "Write addr: %p, Offset: %d, BlkCnt = %d\r\n", Buf, BlkOffset, BlkCnt);

    Ret = AlMmc_Dev_TransferConfig(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    Ret = AlMmc_Dev_WriteData(Dev, Buf, BlkOffset, BlkCnt);
    if (Ret != AL_OK) {
        return Ret;
    }

    return Ret;
}

AL_S32 AlMmc_Dev_ReadData(AL_MMC_DevStruct *Dev, AL_U8 *Buf, AL_U32 Arg, AL_U32 BlkCnt)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;

    if (!AlMmc_Dev_GetState(Dev, AL_MMC_STATE_READY)) {
        return AL_MMC_ERR_STATE_NOT_READY;
    }

    if (AlMmc_Dev_GetState(Dev, AL_MMC_STATE_READ_BUSY | AL_MMC_STATE_WRITE_BUSY)) {
        return AL_MMC_ERR_TRANS_BUSY;
    }

    AlMmc_Dev_SetState(Dev, AL_MMC_STATE_READ_BUSY);

    Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_16, Dev->CardInfo.BlkLen, 0);
    if (Ret != AL_OK) {
        return Ret;
    }

    Ret = AlMmc_Dev_DmaSetUp(Dev, Buf, BlkCnt);
    if (Ret != AL_OK) {
        return Ret;
    }

#ifdef ENABLE_MMU
    if (Dev->Config.AutoGenAdmaTblEn || Dev->Config.DmaMode != AL_MMC_DMA_MODE_ADMA2) {
        AlCache_InvalidateDcacheRange((AL_UINTPTR)Buf, (AL_UINTPTR)(Buf + BlkCnt * Dev->CardInfo.BlkLen));
        AL_LOG(AL_LOG_LEVEL_DEBUG, "Invalidate start: 0x%lx, end: 0x%lx\r\n",
               (AL_UINTPTR)Buf, (AL_UINTPTR)(Buf + BlkCnt * Dev->CardInfo.BlkLen));
    }
#endif

    if (Dev->Config.DmaMode != AL_MMC_DMA_MODE_ADMA3) {
        if ((Dev->CardInfo.CardVer < AL_MMC_CARD_VER_200) && (Dev->CardInfo.CardType == AL_MMC_CARD_TYPE_SD)) {
            Arg *= AL_MMC_BLK_LEN_512B;
        }

        if (BlkCnt > 1) {
            Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_18, Arg, BlkCnt);
        } else {
            Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_17, Arg, BlkCnt);
        }

        if (Ret != AL_OK) {
            return Ret;
        }
    }

    Ret = AlMmc_Dev_TransferData(Dev, Buf, BlkCnt);
    if (Ret != AL_OK) {
        return Ret;
    }

    if (Dev->HostInfo.HostVer == AL_MMC_HOST_VER_3 && BlkCnt > 1) {
        Ret = AlMmc_Dev_CmdTransfer(Dev, AL_MMC_CMD_IDX_12, 0, 0);
        if (Ret != AL_OK) {
            return Ret;
        }
    }

    AlMmc_Dev_ClrState(Dev, AL_MMC_STATE_READ_BUSY);

    return Ret;
}

/* When ADMA2 mode and auto gen desc is false, buf is pointer of desc list */
AL_S32 AlMmc_Dev_Read(AL_MMC_DevStruct *Dev, AL_U8 *Buf, AL_U32 BlkOffset, AL_U32 BlkCnt)
{
    AL_ASSERT(Dev != AL_NULL, AL_MMC_ERR_NULL_PTR);
    AL_ASSERT(!((AL_UINTPTR)Buf & AL_MMC_BUF_ALIGN_MASK), AL_MMC_ERR_BUF_NOT_ALIGN);

    AL_S32 Ret = AL_OK;

    /* Maybe real address in ddr */
    if (Buf == AL_NULL) {
        AL_LOG(AL_LOG_LEVEL_WARNING, "WARNING: Read addr %p\r\n", Buf);
    }
    AL_LOG(AL_LOG_LEVEL_DEBUG, "Read addr: %p, Offset: 0x%x, BlkCnt = %d\r\n", Buf, BlkOffset, BlkCnt);

    Ret = AlMmc_Dev_TransferConfig(Dev);
    if (Ret != AL_OK) {
        return Ret;
    }

    Ret = AlMmc_Dev_ReadData(Dev, Buf, BlkOffset, BlkCnt);
    if (Ret != AL_OK) {
        return Ret;
    }

    return Ret;
}

/**
 * This function is intr call back
 * @param   Instance is pointer to intr call back reference
 * @return
 * @note
*/
AL_VOID AlMmc_Dev_IntrHandler(void *Instance)
{
    AL_MMC_DevStruct *Dev = Instance;
    AL_U32 IntrSigEn = AlMmc_ll_ReadIntrSigEn(Dev->HwConfig.BaseAddress);
    AL_U32 IntrState = AlMmc_ll_ReadIntrStat(Dev->HwConfig.BaseAddress);

    /* TODO: support after osal interface done */
    if (AL_MMC_CMD_COMP_INTR(IntrSigEn & IntrState)) {

    }

    if (AL_MMC_XFER_COMP_INTR(IntrSigEn & IntrState)) {

    }

    if (AL_MMC_DMA_INTR(IntrSigEn & IntrState)) {

    }

    if (AL_MMC_CARD_INTR(IntrSigEn & IntrState)) {

    }

    if (AL_MMC_ERR_INTR(IntrSigEn & IntrState)) {

    }
}

AL_S32 AlMmc_Dev_IoCtl(AL_MMC_DevStruct *Dev, AL_MMC_IoCtlCmdEnum Cmd, AL_VOID *Data)
{
    return AL_OK;
}

static AL_VOID AlMmc_Dev_DisplayCsd(AL_MMC_DevStruct *Dev)
{
    AL_LOG(AL_LOG_LEVEL_DEBUG, "-----CSD-----\r\n");
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-Rsvd0: %d\r\n", Dev->CardInfo.Csd.SdV1.Rsvd0);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-Crc: %d\r\n", Dev->CardInfo.Csd.SdV1.Crc);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-Rsvd9_8: %d\r\n", Dev->CardInfo.Csd.SdV1.Rsvd9_8);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-FileFormat: %d\r\n", Dev->CardInfo.Csd.SdV1.FileFormat);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-TmpWrProt: %d\r\n", Dev->CardInfo.Csd.SdV1.TmpWrProt);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-PermWrProt: %d\r\n", Dev->CardInfo.Csd.SdV1.PermWrProt);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-CpyFlag: %d\r\n", Dev->CardInfo.Csd.SdV1.CpyFlag);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-FileFormatGrp: %d\r\n", Dev->CardInfo.Csd.SdV1.FileFormatGrp);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-Rsvd20_16: %d\r\n", Dev->CardInfo.Csd.SdV1.Rsvd20_16);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-WrBlkPartial: %d\r\n", Dev->CardInfo.Csd.SdV1.WrBlkPartial);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-WrBlkLen: %d\r\n", Dev->CardInfo.Csd.SdV1.WrBlkLen);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-WrSpdFactor: %d\r\n", Dev->CardInfo.Csd.SdV1.WrSpdFactor);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-Rsvd30_29: %d\r\n", Dev->CardInfo.Csd.SdV1.Rsvd30_29);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-WrProtGrpEn: %d\r\n", Dev->CardInfo.Csd.SdV1.WrProtGrpEn);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-WrProtGrpSize: %d\r\n", Dev->CardInfo.Csd.SdV1.WrProtGrpSize);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-EraseSectorSize: %d\r\n", Dev->CardInfo.Csd.SdV1.EraseSectorSize);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-EraseBlkEn: %d\r\n", Dev->CardInfo.Csd.SdV1.EraseBlkEn);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-DevSizeMulti: %d\r\n", Dev->CardInfo.Csd.SdV1.DevSizeMulti);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-VddWrCurMax: %d\r\n", Dev->CardInfo.Csd.SdV1.VddWrCurMax);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-VddWrCurMin: %d\r\n", Dev->CardInfo.Csd.SdV1.VddWrCurMin);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-VddRdCurMax: %d\r\n", Dev->CardInfo.Csd.SdV1.VddRdCurMax);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-VddRdCurMin: %d\r\n", Dev->CardInfo.Csd.SdV1.VddRdCurMin);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-DevSize63_62: %d\r\n", Dev->CardInfo.Csd.SdV1.DevSize63_62);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-DevSize73_64: %d\r\n", Dev->CardInfo.Csd.SdV1.DevSize73_64);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-Rsvd75_74: %d\r\n", Dev->CardInfo.Csd.SdV1.Rsvd75_74);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-DsrImp: %d\r\n", Dev->CardInfo.Csd.SdV1.DsrImp);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-RdBlkMisalign: %d\r\n", Dev->CardInfo.Csd.SdV1.RdBlkMisalign);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-WrBlkMisalign: %d\r\n", Dev->CardInfo.Csd.SdV1.WrBlkMisalign);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-RdBlkPartial: %d\r\n", Dev->CardInfo.Csd.SdV1.RdBlkPartial);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-RdBlkLen: %d\r\n", Dev->CardInfo.Csd.SdV1.RdBlkLen);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-CardCmdClass: %d\r\n", Dev->CardInfo.Csd.SdV1.CardCmdClass);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-TransSpd: %d\r\n", Dev->CardInfo.Csd.SdV1.TransSpd);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-Nsac: %d\r\n", Dev->CardInfo.Csd.SdV1.Nsac);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-Taac: %d\r\n", Dev->CardInfo.Csd.SdV1.Taac);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-Rsvd125_120: %d\r\n", Dev->CardInfo.Csd.SdV1.Rsvd125_120);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-CsdStruct: %d\r\n", Dev->CardInfo.Csd.SdV1.CsdStruct);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "-----CSD-----\r\n");
}

static AL_VOID AlMmc_Dev_DisplayScr(AL_MMC_DevStruct *Dev)
{
    AL_LOG(AL_LOG_LEVEL_DEBUG, "-----SCR-----\r\n");
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-Rsvd31_0: %d\r\n", Dev->CardInfo.Scr.Sd.Rsvd31_0);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-CmdSupport: %d\r\n", Dev->CardInfo.Scr.Sd.CmdSupport);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-Rsvd41_36: %d\r\n", Dev->CardInfo.Scr.Sd.Rsvd41_36);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-SdSpec4: %d\r\n", Dev->CardInfo.Scr.Sd.SdSpec4);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-ExSecurity: %d\r\n", Dev->CardInfo.Scr.Sd.ExSecurity);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-SdSpec3: %d\r\n", Dev->CardInfo.Scr.Sd.SdSpec3);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-SdBusWidth: %d\r\n", Dev->CardInfo.Scr.Sd.SdBusWidth);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-SdSecurity: %d\r\n", Dev->CardInfo.Scr.Sd.SdSecurity);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-DatStatAfterErase: %d\r\n", Dev->CardInfo.Scr.Sd.DatStatAfterErase);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-SdSpec: %d\r\n", Dev->CardInfo.Scr.Sd.SdSpec);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-ScrStructure: %d\r\n", Dev->CardInfo.Scr.Sd.ScrStructure);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "-----SCR-----\r\n");
}

static AL_VOID AlMmc_Dev_DisplayAdmaDesc(AL_MMC_AdmaDescUnion *TablePtr, AL_U32 Size)
{
    for (AL_U32 i = 0; i < Size; i++) {
        AL_LOG(AL_LOG_LEVEL_DEBUG, "-----Table[%d]-----\r\n", i);
        AL_LOG(AL_LOG_LEVEL_DEBUG, "|-Desc[0]: 0x%x\r\n", TablePtr[i].Desc[0]);
        AL_LOG(AL_LOG_LEVEL_DEBUG, "|-Desc[1]: 0x%x\r\n", TablePtr[i].Desc[1]);
        AL_LOG(AL_LOG_LEVEL_DEBUG, "|-Addr: 0x%x\r\n", TablePtr[i].Bit.AddrArgPtr);
        AL_LOG(AL_LOG_LEVEL_DEBUG, "|-LowerLen: 0x%x\r\n", TablePtr[i].Bit.LowerLen);
        AL_LOG(AL_LOG_LEVEL_DEBUG, "|-UpperLen: 0x%x\r\n", TablePtr[i].Bit.UpperLen);
        AL_LOG(AL_LOG_LEVEL_DEBUG, "|-Act: 0x%x\r\n", TablePtr[i].Bit.Act);
        AL_LOG(AL_LOG_LEVEL_DEBUG, "|-Int: 0x%x\r\n", TablePtr[i].Bit.Int);
        AL_LOG(AL_LOG_LEVEL_DEBUG, "|-End: 0x%x\r\n", TablePtr[i].Bit.End);
        AL_LOG(AL_LOG_LEVEL_DEBUG, "|-Valid: 0x%x\r\n", TablePtr[i].Bit.Valid);
        AL_LOG(AL_LOG_LEVEL_DEBUG, "-----Table[%d] end-----\r\n", i);
    }
}

static AL_VOID AlMmc_Dev_DisplayAllReg(AL_MMC_DevStruct *Dev)
{
    AL_LOG(AL_LOG_LEVEL_DEBUG, "----------Host Controller Register----------\r\n");
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-BlkCnt_SdmaSysAddr: 0x%x\r\n", AlMmc_ll_ReadBlkCnt_SdmaSysAddr(Dev->HwConfig.BaseAddress));
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-BlkCnt_BlkSize: 0x%x\r\n", AlMmc_ll_ReadBlkCnt_BlkSize(Dev->HwConfig.BaseAddress));
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-Argument: 0x%x\r\n", AlMmc_ll_ReadArgument(Dev->HwConfig.BaseAddress));
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-Cmd_XferMode: 0x%x\r\n", AlMmc_ll_ReadCmd_XferMode(Dev->HwConfig.BaseAddress));
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-ReadResp01: 0x%x\r\n", AlMmc_ll_ReadResp01(Dev->HwConfig.BaseAddress));
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-ReadResp23: 0x%x\r\n", AlMmc_ll_ReadResp23(Dev->HwConfig.BaseAddress));
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-ReadResp45: 0x%x\r\n", AlMmc_ll_ReadResp45(Dev->HwConfig.BaseAddress));
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-ReadResp67: 0x%x\r\n", AlMmc_ll_ReadResp67(Dev->HwConfig.BaseAddress));
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-BufferData: 0x%x\r\n", AlMmc_ll_ReadBufferData(Dev->HwConfig.BaseAddress));
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-CurState: 0x%x\r\n", AlMmc_ll_ReadCurState(Dev->HwConfig.BaseAddress));
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-Ctrl_Wup_Bgap_Pwr_Host1: 0x%x\r\n", AlMmc_ll_ReadCtrl_Wup_Bgap_Pwr_Host1(Dev->HwConfig.BaseAddress));
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-SwRst_Ctrl_Tout_Clk: 0x%x\r\n", AlMmc_ll_ReadSwRst_Ctrl_Tout_Clk(Dev->HwConfig.BaseAddress));
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-IntrStat: 0x%x\r\n", AlMmc_ll_ReadIntrStat(Dev->HwConfig.BaseAddress));
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-IntrStatEn: 0x%x\r\n", AlMmc_ll_ReadIntrStatEn(Dev->HwConfig.BaseAddress));
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-IntrSigEn: 0x%x\r\n", AlMmc_ll_ReadIntrSigEn(Dev->HwConfig.BaseAddress));
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-AutoCmdStat_CtrlHost2: 0x%x\r\n", AlMmc_ll_ReadAutoCmdStat_CtrlHost2(Dev->HwConfig.BaseAddress));
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-AdmaErrStat: 0x%x\r\n", AlMmc_ll_ReadAdmaErrStat(Dev->HwConfig.BaseAddress));
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-AdmaSysAddrLow: 0x%x\r\n", AlMmc_ll_ReadAdmaSysAddrLow(Dev->HwConfig.BaseAddress));
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-Capability1: 0x%x\r\n", AlMmc_ll_ReadCapability1(Dev->HwConfig.BaseAddress));
    AL_LOG(AL_LOG_LEVEL_DEBUG, "|-Capability2: 0x%x\r\n", AlMmc_ll_ReadCapability2(Dev->HwConfig.BaseAddress));
    AL_LOG(AL_LOG_LEVEL_DEBUG, "----------Host Controller Register Done----------\r\n");
}

static AL_VOID AlMmc_Dev_DisplayCardInfo(AL_MMC_DevStruct *Dev)
{
    AL_LOG(AL_LOG_LEVEL_INFO, "----------Card Info----------\r\n");
    AL_LOG(AL_LOG_LEVEL_INFO, "|-Device: mmc@0x%x\r\n", Dev->HwConfig.BaseAddress);
    AL_LOG(AL_LOG_LEVEL_INFO, "|-Manufacturer ID: 0x%x\r\n", Dev->CardInfo.Cid.Sd.Mid);
    if (Dev->CardInfo.CardType == AL_MMC_CARD_TYPE_SD) {
        AL_LOG(AL_LOG_LEVEL_INFO, "|-OEM: 0x%x\r\n", Dev->CardInfo.Cid.Sd.Oid);
        AL_LOG(AL_LOG_LEVEL_INFO, "|-Name: %c%c%c%c%c\r\n", Dev->CardInfo.Cid.Sd.Pnm103_96,
                                                        Dev->CardInfo.Cid.Sd.Pnm95_88,
                                                        Dev->CardInfo.Cid.Sd.Pnm87_80,
                                                        Dev->CardInfo.Cid.Sd.Pnm79_72,
                                                        Dev->CardInfo.Cid.Sd.Pnm71_64);
    } else {
        AL_LOG(AL_LOG_LEVEL_INFO, "|-OEM: 0x%x\r\n", Dev->CardInfo.Cid.Emmc.Oid);
        AL_LOG(AL_LOG_LEVEL_INFO, "|-Name: %c%c%c%c%c%c\r\n", Dev->CardInfo.Cid.Emmc.Pnm103_96,
                                                              Dev->CardInfo.Cid.Emmc.Pnm95_88,
                                                              Dev->CardInfo.Cid.Emmc.Pnm87_80,
                                                              Dev->CardInfo.Cid.Emmc.Pnm79_72,
                                                              Dev->CardInfo.Cid.Emmc.Pnm71_64,
                                                              Dev->CardInfo.Cid.Emmc.Pnm63_56);
    }
    AL_LOG(AL_LOG_LEVEL_INFO, "|-Bus Speed: %d KHz\r\n", Dev->CardInfo.FreqKhz);
    AL_LOG(AL_LOG_LEVEL_INFO, "|-Mode: %s\r\n", (Dev->CardInfo.SpdMode == 0) ? "Default Speed" : "High Speed");
    AL_LOG(AL_LOG_LEVEL_INFO, "|-Rd Block Len: %d\r\n", Dev->CardInfo.BlkLen);
    AL_LOG(AL_LOG_LEVEL_INFO, "|-Version: %d\r\n", Dev->CardInfo.CardVer);
    AL_LOG(AL_LOG_LEVEL_INFO, "|-High Capacity: %s\r\n", Dev->CardInfo.HiCap ? "YES" : "NO");
    AL_LOG(AL_LOG_LEVEL_INFO, "|-Capacity: %d.%dGB\r\n", (Dev->CardInfo.CardCap >> 20), AlMmc_CapacityDot[(Dev->CardInfo.CardCap >> 16) & 0xF]);
    AL_LOG(AL_LOG_LEVEL_INFO, "|-Bus Width: %d-bit\r\n", Dev->CardInfo.BusWidth);
    AL_LOG(AL_LOG_LEVEL_INFO, "-----------------------------\r\n");
}
