/*
 * Copyright (c) 2023, Anlogic Inc. and Contributors. All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */
/***************************** Include Files *********************************/
#include "al_adc_dev.h"

/************************** Variable Definitions *****************************/
/* Hardware config generated by TD */
extern AL_ADC_HwConfigStruct AlAdc_HwConfig[AL_ADC_NUM_INSTANCE];


/**
 *
 * This function searches for the hardware configuration structure associated with the specified ADC device ID.
 *
 * @param DevId The ADC device ID to look up.
 *
 * @return A pointer to the hardware configuration structure if found, or NULL if not found.
 *
 */
AL_ADC_HwConfigStruct *AlAdc_Dev_LookupConfig(AL_U32 DevId)
{
    AL_U32 Index;
    AL_ADC_HwConfigStruct *ConfigPtr = AL_NULL;

    for (Index = 0; Index < AL_ADC_NUM_INSTANCE; Index++) {
        if (AlAdc_HwConfig[Index].DeviceId == DevId) {
            ConfigPtr = &AlAdc_HwConfig[Index];
            break;
        }
    }
    return ConfigPtr;
}

/************************** Constant Definitions *****************************/

static AL_ADC_InitStruct AdcDefInitConfig = {
    .InputSingal                = AL_ADC_UNIPOLAR,
    .Resolution                 = AL_ADC_10BIT_MODE,
    .RefVoltag                  = AL_ADC_REF_INTER_REF,
    .ConvMode                   = AL_ADC_CONTINUOUS_MODE,
    .ConvChanNum                = 7,
    .ClkSource                  = AL_ADC_CLK_PS_50MHz,
    .AdcClkDiv                  = 0,
    .PlIntrCfg.IntrDoneMask     = AL_FALSE,
    .PlIntrCfg.IntrGthMask      = AL_TRUE,
    .PlIntrCfg.IntrLthMask      = AL_TRUE,
    .PlIntrCfg.IntrErrorMask    = AL_TRUE,
};

static AL_ADC_ChanCfg ChanDefConfig[8] = {
    {   .ChanNum            = AL_ADC_CHAN0,
        .MuxForChan         = AL_ADC_MUX_VPVN,
        .LthVal             = 0x0,
        .GthVal             = 0xFFF,
    },
    {   .ChanNum            = AL_ADC_CHAN1,
        .MuxForChan         = AL_ADC_MUX_0,
        .LthVal             = 0x0,
        .GthVal             = 0xFFF,
    },
    {   .ChanNum            = AL_ADC_CHAN2,
        .MuxForChan         = AL_ADC_MUX_8,
        .LthVal             = 0x0,
        .GthVal             = 0xFFF,
    },
    {   .ChanNum            = AL_ADC_CHAN3,
        .MuxForChan         = AL_ADC_MUX_11,
        .LthVal             = 0x0,
        .GthVal             = 0xFFF,
    },
    {   .ChanNum            = AL_ADC_CHAN4,
        .MuxForChan         = AL_ADC_MUX_12,
        .LthVal             = 0x0,
        .GthVal             = 0xFFF,
    },
    {   .ChanNum            = AL_ADC_CHAN5,
        .MuxForChan         = AL_ADC_MUX_13,
        .LthVal             = 0x0,
        .GthVal             = 0xFFF,
    },
    {   .ChanNum            = AL_ADC_CHAN6,
        .MuxForChan         = AL_ADC_MUX_14,
        .LthVal             = 0x0,
        .GthVal             = 0xFFF,
    },
    {   .ChanNum            = AL_ADC_CHAN7,
        .MuxForChan         = AL_ADC_MUX_15,
        .LthVal             = 0x0,
        .GthVal             = 0xFFF,
    }
};

/************************** Function Prototypes ******************************/

/************************** Function Definitions ******************************/


/**
 *
 * This function initializes the ADC device with the specified configuration.
 *
 * @param Adc Pointer to the ADC device structure.
 * @param DevId The ID of the ADC device.
 * @param InitConfig Pointer to the ADC initialization configuration.
 * @param ChanConfig Pointer to the ADC channel configuration.
 *
 * @return
 *       - AL_OK for function success
 *       - Other for function failure
 *
 */
AL_S32 AlAdc_Dev_Init(AL_ADC_DevStruct *Adc, AL_U32 DevId, AL_ADC_InitStruct *InitConfig, AL_ADC_ChanCfg *ChanConfig)
{
    AL_ADC_HwConfigStruct *AdcHwConfig;
    AL_U8 Index;

    AL_ASSERT((Adc != AL_NULL && DevId < AL_ADC_NUM_INSTANCE), AL_ADC_ERR_ILLEGAL_PARAM);

    AdcHwConfig          = AlAdc_Dev_LookupConfig(DevId);
    Adc->DevId           = DevId;
    Adc->AdcBaseAddr     = AdcHwConfig->AdcBaseAddress;
    Adc->IntrNum         = AdcHwConfig->IntrNum;
    Adc->Configs         = (InitConfig == AL_NULL) ? AdcDefInitConfig : (*InitConfig);

    if (ChanConfig == AL_NULL) {
        if (Adc->Configs.ConvMode == AL_ADC_SINGLE_CHANNEL_MODE) {
            Adc->ChanCfg[0] = ChanDefConfig[0];
        } else {
            for (Index = 0; Index <= Adc->Configs.ConvChanNum; Index++) {
            Adc->ChanCfg[Index] = ChanDefConfig[Index];
            }
        }
    } else {
        if (Adc->Configs.ConvMode == AL_ADC_SINGLE_CHANNEL_MODE) {
            Adc->ChanCfg[0] = ChanConfig[0];
        } else {
            for (Index = 0; Index <= Adc->Configs.ConvChanNum; Index++) {
                Adc->ChanCfg[Index] = ChanConfig[Index];
            }
        }
    }

    /**************** Init PS-ADC ****************/
    AlAdc_ll_ResetPsAdc(Adc->AdcBaseAddr);
    AlAdc_ll_FlushCmdFifo(Adc->AdcBaseAddr);
    AlAdc_ll_FlushDataFifo(Adc->AdcBaseAddr);

    AlAdc_ll_ClrAllPsAdcIntr(Adc->AdcBaseAddr);
    AlAdc_ll_EnablePsAdc(Adc->AdcBaseAddr, AL_TRUE);

    /**************** Init PL-ADC ****************/

    /* reset PL-ADC */
    AlAdc_ll_ResetPlAdc(Adc->AdcBaseAddr);
    AlAdc_ll_MaskAllPlIntr(Adc->AdcBaseAddr);

    AL_ADC_PlReg_Cfg0 Cfg0;
    Cfg0.AdcSwReset = AL_ADC_SW_RELEASE;
    Cfg0.Enctr = 0;
    Cfg0.RefSel = Adc->Configs.RefVoltag;
    Cfg0.ResSel = Adc->Configs.Resolution;
    Cfg0.DiffEnable = Adc->Configs.InputSingal;
    Cfg0.PhyExternalMux = 0;
    Cfg0.AnalogMuxEn = AL_TRUE;
    Cfg0.RegAdcSocSel = 0;
    Cfg0.PhyExternalMuxGap = 0;
    AlAdc_ll_SetAdcCfg0Reg(Adc->AdcBaseAddr, Cfg0.RegData);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "AdcCfg0 is 0x%x\r\n", AlAdc_ll_ReadPlAdcReg(Adc->AdcBaseAddr, ADC_CONFIG0_OFFSET));

    /* Clear and Mask intr for for ADC channel */
    AL_ADC_PlReg_Cfg1 Cfg1;
    Cfg1.IntrDoneMask = Adc->Configs.PlIntrCfg.IntrDoneMask;
    Cfg1.IntrGthMask = Adc->Configs.PlIntrCfg.IntrGthMask;
    Cfg1.IntrLthMask = Adc->Configs.PlIntrCfg.IntrLthMask;
    Cfg1.IntrErrorMask = Adc->Configs.PlIntrCfg.IntrErrorMask;
    Cfg1.IntrDone = AL_TRUE;
    Cfg1.IntrGth = AL_TRUE;
    Cfg1.IntrLth = AL_TRUE;
    Cfg1.IntrError = AL_TRUE;
    AlAdc_ll_SetAdcCfg1Reg(Adc->AdcBaseAddr, Cfg1.RegData);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "AdcCfg1 is 0x%x\r\n", AlAdc_ll_ReadPlAdcReg(Adc->AdcBaseAddr, ADC_CONFIG1_OFFSET));

    /* Set ADC Clock */
    AL_ADC_PlReg_Cfg2 Cfg2;
    Cfg2.RegAdcEnable = 0;
    Cfg2.RegAdcDislvl = 0;
    Cfg2.AdcClkSel = Adc->Configs.ClkSource;
    Cfg2.AdcClkGate = 0;
    Cfg2.AdcClkDiv = Adc->Configs.AdcClkDiv;
    AlAdc_ll_SetAdcCfg2Reg(Adc->AdcBaseAddr, Cfg2.RegData);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "AdcCfg2 is 0x%x\r\n", AlAdc_ll_ReadPlAdcReg(Adc->AdcBaseAddr, ADC_CONFIG2_OFFSET));

    /* Set ADC Conv Mode */
    AL_ADC_PlReg_Cfg3 Cfg3;
    Cfg3.ModeSel = Adc->Configs.ConvMode;
    Cfg3.ChanSel = Adc->Configs.ConvChanNum;
    Cfg3.ExternalChanSel = 0;
    Cfg3.RegAdcSoc = 0;
    AlAdc_ll_SetAdcCfg3Reg(Adc->AdcBaseAddr, Cfg3.RegData);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "AdcCfg3 is 0x%x\r\n", AlAdc_ll_ReadPlAdcReg(Adc->AdcBaseAddr, ADC_CONFIG3_OFFSET));

    /* Set adc mux for channels */
    if (Adc->Configs.ConvMode == AL_ADC_SINGLE_CHANNEL_MODE) {
        AlAdc_Dev_SetMuxForChan(Adc, &Adc->ChanCfg[0]);
    } else {
        for (Index = 0; Index <= Adc->Configs.ConvChanNum; Index++) {
            AlAdc_Dev_SetMuxForChan(Adc, &Adc->ChanCfg[Index]);
        }
    }

    /* Set high and low threshold for channels */
    if (Adc->Configs.ConvMode == AL_ADC_SINGLE_CHANNEL_MODE) {
        AlAdc_Dev_SetThreForChan(Adc, &Adc->ChanCfg[0]);
    } else {
        for (Index = 0; Index <= Adc->Configs.ConvChanNum; Index++) {
            AlAdc_Dev_SetThreForChan(Adc, &Adc->ChanCfg[Index]);
        }
    }

    return AL_OK;
}

/**
 *
 * This function enables or disables the interrupt for the specified ADC peripheral based on the given state.
 *
 * @param   Adc Pointer to a AL_ADC_DevStruct structure that contains adc dev instance
 * @param   IntrType is interrupt type
 * @param   State is the working state
 *
 * @return
 *       - AL_OK for function success
 *       - Other for function failure
 *
 */
AL_S32 AlAdc_Dev_EnablePsAdcIntr(AL_ADC_DevStruct *Adc, AL_ADC_PsIntrTypeEnum IntrType, AL_BOOL State)
{
    AL_ASSERT((Adc != AL_NULL), AL_ADC_ERR_ILLEGAL_PARAM);

    if (State == AL_TRUE) {
        AlAdc_ll_MaskPsAdcIntr(Adc->AdcBaseAddr, IntrType, AL_FALSE);
    } else {
        AlAdc_ll_MaskPsAdcIntr(Adc->AdcBaseAddr, IntrType, AL_TRUE);
    }

    return AL_OK;
}


/**
 *
 * This function converts the ADC data based on the ADC resolution configured in the Adc structure.
 *
 * @param Adc Pointer to the AL_ADC_DevStruct structure.
 * @param ChanNum The ADC channel number.
 *
 * @return The converted ADC data.
 *
 */
AL_S16 AlAdc_Dev_AdcConvData(AL_ADC_DevStruct *Adc, AL_ADC_ChanEnum ChanNum)
{
    AL_S16 AdcConvData = 0;
    switch (Adc->Configs.Resolution)
    {
    case AL_ADC_6BIT_MODE:
        AdcConvData = (AlAdc_ll_GetAdcData(Adc->AdcBaseAddr, ChanNum) >> 6);
        break;
    case AL_ADC_8BIT_MODE:
        AdcConvData = (AlAdc_ll_GetAdcData(Adc->AdcBaseAddr, ChanNum) >> 4);
        break;
    case AL_ADC_10BIT_MODE:
        AdcConvData = (AlAdc_ll_GetAdcData(Adc->AdcBaseAddr, ChanNum) >> 2);
        break;
    case AL_ADC_12BIT_MODE:
        AdcConvData = AlAdc_ll_GetAdcData(Adc->AdcBaseAddr, ChanNum);
        break;
    default:
        break;
    }

    return AdcConvData;
}


/**
 *
 * This function waits for the ADC conversion to complete and then returns the ADC data for the specified channel.
 *
 * @param Adc Pointer to the ADC device structure.
 * @param ChanNum The channel number for which to retrieve the ADC data.
 *
 * @return The ADC data for the specified channel.
 *
 */
AL_S16 AlAdc_Dev_GetAdcData(AL_ADC_DevStruct *Adc, AL_ADC_ChanEnum ChanNum)
{
    while (!(AlAdc_ll_GetPlAdcIntrType(Adc->AdcBaseAddr) & BIT(AL_ADC_PL_INTR_DONE)));
    return (AlAdc_Dev_AdcConvData(Adc, ChanNum));
}

/**
 *
 * This function sets the mux configuration for the specified ADC channel.
 *
 * @param Adc Pointer to the AL_ADC_DevStruct representing the ADC device.
 * @param ChanCfg Pointer to the AL_ADC_ChanCfg structure containing the channel configuration.
 *
 * @return
 *       - AL_OK if the mux configuration was set successfully
 *       - Other for an error code.
 *
 */
AL_S32 AlAdc_Dev_SetMuxForChan(AL_ADC_DevStruct *Adc, AL_ADC_ChanCfg *ChanCfg)
{
    AL_ASSERT(((Adc != AL_NULL) && (ChanCfg != AL_NULL)), AL_ADC_ERR_ILLEGAL_PARAM);

    switch (ChanCfg->ChanNum)
    {
    case AL_ADC_CHAN0:
        AlAdc_ll_SetMuxForChan0(Adc->AdcBaseAddr, ChanCfg->MuxForChan);
        break;
    case AL_ADC_CHAN1:
        AlAdc_ll_SetMuxForChan1(Adc->AdcBaseAddr, ChanCfg->MuxForChan);
        break;
    case AL_ADC_CHAN2:
        AlAdc_ll_SetMuxForChan2(Adc->AdcBaseAddr, ChanCfg->MuxForChan);
        break;
    case AL_ADC_CHAN3:
        AlAdc_ll_SetMuxForChan3(Adc->AdcBaseAddr, ChanCfg->MuxForChan);
        break;
    case AL_ADC_CHAN4:
        AlAdc_ll_SetMuxForChan4(Adc->AdcBaseAddr, ChanCfg->MuxForChan);
        break;
    case AL_ADC_CHAN5:
        AlAdc_ll_SetMuxForChan5(Adc->AdcBaseAddr, ChanCfg->MuxForChan);
        break;
    case AL_ADC_CHAN6:
        AlAdc_ll_SetMuxForChan6(Adc->AdcBaseAddr, ChanCfg->MuxForChan);
        break;
    case AL_ADC_CHAN7:
        AlAdc_ll_SetMuxForChan7(Adc->AdcBaseAddr, ChanCfg->MuxForChan);
        break;
    default:
        break;
    }

    return AL_OK;
}

/**
 *
 * This function is used to set high and low thresholds for channel.
 *
 * @param   Adc Pointer to a AL_ADC_DevStruct structure that contains adc dev instance
 * @param   ChanCfg Pointer to the AL_ADC_ChanCfg structure containing the channel configuration.
 *
 * @return
 *       - AL_OK for function success
 *       - Other for function failure
 *
 */
AL_S32 AlAdc_Dev_SetThreForChan(AL_ADC_DevStruct *Adc, AL_ADC_ChanCfg *ChanCfg)
{
    AL_ASSERT(((Adc != AL_NULL) && (ChanCfg != AL_NULL)), AL_ADC_ERR_ILLEGAL_PARAM);

    AlAdc_ll_SetAdcChanXLth(Adc->AdcBaseAddr, ChanCfg->ChanNum, ChanCfg->LthVal);
    AlAdc_ll_SetAdcChanXGth(Adc->AdcBaseAddr, ChanCfg->ChanNum, ChanCfg->GthVal);

    return AL_OK;
}

/**
 *
 * This function allows the user to mask or unmask the specified interrupt type for the PL ADC module.
 *
 * @param Adc Pointer to the AL_ADC_DevStruct structure representing the ADC device.
 * @param IntrType The interrupt type to be masked or unmasked. It can be one of the following values:
 *                 - AL_ADC_PL_INTR_DONE: Mask or unmask the "done" interrupt.
 *                 - AL_ADC_PL_INTR_GTH: Mask or unmask the "greater than high threshold" interrupt.
 *                 - AL_ADC_PL_INTR_LTH: Mask or unmask the "less than low threshold" interrupt.
 *                 - AL_ADC_PL_INTR_ERROR: Mask or unmask the "error" interrupt.
 * @param State The state to set for the interrupt. AL_TRUE to mask the interrupt, AL_FALSE to unmask it.
 *
 * @return
 *       - AL_OK if the operation is successful
 *       - Other for function failure
 *
 */
AL_S32 AlAdc_Dev_MaskPlAdcIntr(AL_ADC_DevStruct *Adc, AL_ADC_PlIntrTypeEnum IntrType, AL_BOOL State)
{
    AL_ASSERT((Adc != AL_NULL), AL_ADC_ERR_ILLEGAL_PARAM);

    switch (IntrType)
    {
    case AL_ADC_PL_INTR_DONE:
        AlAdc_ll_MaskPlAdcIntrDone(Adc->AdcBaseAddr, State);
        break;
    case AL_ADC_PL_INTR_GTH:
        AlAdc_ll_MaskPlAdcIntrGth(Adc->AdcBaseAddr, State);
        break;
    case AL_ADC_PL_INTR_LTH:
        AlAdc_ll_MaskPlAdcIntrLth(Adc->AdcBaseAddr, State);
        break;
    case AL_ADC_PL_INTR_ERROR:
        AlAdc_ll_MaskPlAdcIntrError(Adc->AdcBaseAddr, State);
        break;
    default:
        break;
    }

    return AL_OK;
}

/**
 *
 * This function clears the specified interrupt for the PL ADC device.
 *
 * @param Adc Pointer to the AL_ADC_DevStruct representing the ADC device.
 * @param IntrType The type of interrupt to be cleared. It can be one of the following values:
 *                 - AL_ADC_PL_INTR_DONE: Clears the "done" interrupt.
 *                 - AL_ADC_PL_INTR_GTH: Clears the "greater than high threshold" interrupt.
 *                 - AL_ADC_PL_INTR_LTH: Clears the "less than low threshold" interrupt.
 *                 - AL_ADC_PL_INTR_ERROR: Clears the "error" interrupt.
 *
 * @return AL_OK if the interrupt was cleared successfully, otherwise an error code.
 *
 */
AL_S32 AlAdc_Dev_ClrPlAdcIntr(AL_ADC_DevStruct *Adc, AL_ADC_PlIntrTypeEnum IntrType)
{
    AL_ASSERT((Adc != AL_NULL), AL_ADC_ERR_ILLEGAL_PARAM);

    switch (IntrType)
    {
    case AL_ADC_PL_INTR_DONE:
        AlAdc_ll_ClrPlAdcIntrDone(Adc->AdcBaseAddr);
        break;
    case AL_ADC_PL_INTR_GTH:
        AlAdc_ll_ClrPlAdcIntrGth(Adc->AdcBaseAddr);
        break;
    case AL_ADC_PL_INTR_LTH:
        AlAdc_ll_ClrPlAdcIntrLth(Adc->AdcBaseAddr);
        break;
    case AL_ADC_PL_INTR_ERROR:
        AlAdc_ll_ClrPlAdcIntrError(Adc->AdcBaseAddr);
        break;
    default:
        break;
    }

    return AL_OK;
}


/**
 *
 * This function is called when ADC interrupts are completed. It retrieves the ADC data
 * and triggers the event callback if it is set. It also clears the ADC interrupt.
 *
 * @param Adc Pointer to the AL_ADC_DevStruct representing the ADC device.
 *
 * @return None.
 *
 */
static AL_VOID AlAdc_Dev_IntrDoneHandler(AL_ADC_DevStruct *Adc)
{
    AL_U32 Index;
    AL_ADC_EventStruct AdcEvent = {0};

    if (Adc->Configs.ConvMode == AL_ADC_SINGLE_CHANNEL_MODE) {
        Adc->AdcData[0].ChanNum = Adc->ChanCfg[0].ChanNum;
        Adc->AdcData[0].ChanData = AlAdc_Dev_AdcConvData(Adc, Adc->AdcData[0].ChanNum);
        AdcEvent.EventData |= BIT(Adc->AdcData[0].ChanNum);
    } else {
        for (Index = 0; Index <= Adc->Configs.ConvChanNum; Index++) {
            Adc->AdcData[Index].ChanNum = Index;
            Adc->AdcData[Index].ChanData = AlAdc_Dev_AdcConvData(Adc, Index);
            AdcEvent.EventData |= BIT(Index);
        }
    }

    AdcEvent.Events = AL_ADC_EVENT_DATA_DONE;
    if (Adc->EventCallBack) {
        (*Adc->EventCallBack)(AdcEvent, Adc->EventCallBackRef);
    }

    AlAdc_ll_ClrPlAdcIntrDone(Adc->AdcBaseAddr);
}

/**
 *
 * This function is called when an ADC interrupt is triggered. It handles the interrupt
 * by checking the ADC flags and processing the ADC data accordingly.
 *
 * @param Adc Pointer to the ADC device structure.
 *
 * @return None.
 *
 */
static AL_VOID AlAdc_Dev_IntrGthHandler(AL_ADC_DevStruct *Adc)
{
    AL_U32 Index;
    AL_ADC_EventStruct AdcEvent = {0};

    AL_U16 AdcFlag = AlAdc_ll_GetAdcFlag(Adc->AdcBaseAddr);

    if (Adc->Configs.ConvMode == AL_ADC_SINGLE_CHANNEL_MODE) {
        if (AdcFlag & BIT(AL_ADC_FLAG_COMP_VC0 + Adc->ChanCfg[0].ChanNum)) {
            Adc->AdcData[0].ChanNum = Adc->ChanCfg[0].ChanNum;
            Adc->AdcData[0].ChanData = AlAdc_Dev_AdcConvData(Adc, Adc->AdcData[0].ChanNum);
            AdcEvent.EventData |= BIT(Adc->ChanCfg[0].ChanNum);
        }
    } else {
        for (Index = 0; Index <= Adc->Configs.ConvChanNum; Index++) {
            if (AdcFlag & (BIT(Index + AL_ADC_FLAG_COMP_VC0))) {
                Adc->AdcData[Index].ChanNum = Index;
                Adc->AdcData[Index].ChanData = AlAdc_Dev_AdcConvData(Adc, Index);
                AdcEvent.EventData |= BIT(Index);
            }
        }
    }

    AdcEvent.Events = AL_ADC_EVENT_DATA_GTH;
    if (Adc->EventCallBack) {
        (*Adc->EventCallBack)(AdcEvent, Adc->EventCallBackRef);
    }

    AlAdc_ll_ClrPlAdcIntrGth(Adc->AdcBaseAddr);
}

/**
 *
 * This function is called when the ADC device's data length threshold interrupt is triggered.
 * It retrieves the ADC flags and checks if any of the channels have reached the threshold.
 * If a channel has reached the threshold, it retrieves the ADC conversion data for that channel
 * and updates the corresponding ADC data structure. It also sets the event data bit for the
 * corresponding channel in the ADC event structure. Finally, it calls the event callback function
 * if it is registered and clears the interrupt.
 *
 * @param Adc Pointer to the ADC device structure.
 *
 * @return None.
 *
 */
static AL_VOID AlAdc_Dev_IntrLthHandler(AL_ADC_DevStruct *Adc)
{
    AL_U32 Index;
    AL_ADC_EventStruct AdcEvent = {0};

    AL_U16 AdcFlag = AlAdc_ll_GetAdcFlag(Adc->AdcBaseAddr);

    if (Adc->Configs.ConvMode == AL_ADC_SINGLE_CHANNEL_MODE) {
        if (AdcFlag & BIT(AL_ADC_FLAG_COMP_VC0 + Adc->ChanCfg[0].ChanNum)) {
            Adc->AdcData[0].ChanNum = Adc->ChanCfg[0].ChanNum;
            Adc->AdcData[0].ChanData = AlAdc_Dev_AdcConvData(Adc, Adc->AdcData[0].ChanNum);
            AdcEvent.EventData |= BIT(Adc->ChanCfg[0].ChanNum);
        }
    } else {
        for (Index = 0; Index <= Adc->Configs.ConvChanNum; Index++) {
            if (AdcFlag & (BIT(Index + AL_ADC_FLAG_COMP_VC0))) {
                Adc->AdcData[Index].ChanNum = Index;
                Adc->AdcData[Index].ChanData = AlAdc_Dev_AdcConvData(Adc, Index);
                AdcEvent.EventData |= BIT(Index);
            }
        }
    }

    AdcEvent.Events = AL_ADC_EVENT_DATA_LTH;
    if (Adc->EventCallBack) {
        (*Adc->EventCallBack)(AdcEvent, Adc->EventCallBackRef);
    }

    AlAdc_ll_ClrPlAdcIntrLth(Adc->AdcBaseAddr);
}

/**
 *
 * This function is responsible for handling the interrupt error for the ADC device.
 * It notifies the event callback function if one is registered, and clears the interrupt error.
 *
 * @param Adc Pointer to the ADC device structure.
 *
 * @return None.
 *
 */
static AL_VOID AlAdc_Dev_IntrErrorHandler(AL_ADC_DevStruct *Adc)
{
    AL_ADC_EventStruct AdcEvent = {0};

    AdcEvent.Events = AL_ADC_EVENT_DATA_ERROR;
    if (Adc->EventCallBack) {
        (*Adc->EventCallBack)(AdcEvent, Adc->EventCallBackRef);
    }

    AlAdc_ll_ClrPlAdcIntrError(Adc->AdcBaseAddr);
}

/**
 *
 * This function is the interrupt handler for the ADC device. It handles the
 * interrupt events generated by the ADC device and calls the corresponding
 * handler functions based on the interrupt type.
 *
 * @param Instance Pointer to the ADC device instance.
 *
 * @return None.
 *
 */
AL_VOID AlAdc_Dev_IntrHandler(AL_VOID *Instance)
{
    AL_ADC_DevStruct *Adc = (AL_ADC_DevStruct *)Instance;
    AL_U32 PsAdcIntrStatus;
    AL_U16 PlAdcIntrStatus;

    /* Get PsAdc interrupts status */
    PsAdcIntrStatus = AlAdc_ll_GetPsAdcIntrType(Adc->AdcBaseAddr);

    if (PsAdcIntrStatus & BIT(AL_ADC_PLADC_INTR)) {

        /* The interrupt about PlAdc */
        PlAdcIntrStatus = AlAdc_ll_GetPlAdcIntrType(Adc->AdcBaseAddr);

        /* Determine the interrupt type of PlAdc */
        if (PlAdcIntrStatus & BIT(AL_ADC_PL_INTR_DONE)) {
            AlAdc_Dev_IntrDoneHandler(Adc);
        }
        if (PlAdcIntrStatus & BIT(AL_ADC_PL_INTR_GTH)) {
            AlAdc_Dev_IntrGthHandler(Adc);
        }
        if (PlAdcIntrStatus & BIT(AL_ADC_PL_INTR_LTH)) {
            AlAdc_Dev_IntrLthHandler(Adc);
        }
        if (PlAdcIntrStatus & BIT(AL_ADC_PL_INTR_ERROR)) {
            AlAdc_Dev_IntrErrorHandler(Adc);
        }

        AlAdc_ll_ClrPsAdcIntr(Adc->AdcBaseAddr, AL_ADC_PLADC_INTR);
    }
}

/**
 *
 * This function excute operations to set or get adc status.
 *
 * @param Adc Pointer to the ADC device structure.
 * @param Cmd The control command to be executed.
 * @param IoctlParam Pointer to the parameter structure for the control command.
 *
 * @return AL_S32 Returns the status of the control operation.
 *
 */
AL_S32 AlAdc_Dev_IoCtl(AL_ADC_DevStruct *Adc, AL_ADC_IoCtlCmdEnum Cmd, AL_ADC_IoctlParamUnion *IoctlParam)
{
    AL_S32 Ret = AL_OK;

    AL_ASSERT((Adc != AL_NULL), AL_ADC_ERR_ILLEGAL_PARAM);

    switch (Cmd)
    {
    case AL_ADC_IOCTL_SET_REFVOLTAG: {
        AL_U8 RefVoltag = IoctlParam->RefVoltag;
        AlAdc_ll_SetRefVoltag(Adc->AdcBaseAddr, RefVoltag);
        break;
    }
    case AL_ADC_IOCTL_SET_RESOLUTION: {
        AL_U8 Resolution = IoctlParam->Resolution;
        AlAdc_ll_SetResolution(Adc->AdcBaseAddr, Resolution);
        break;
    }
    case AL_ADC_IOCTL_SET_INPUTSINGAL: {
        AL_U8 InuputSignal = IoctlParam->InputSingal;
        AlAdc_ll_SetInputSingal(Adc->AdcBaseAddr, InuputSignal);
        break;
    }
    case AL_ADC_IOCTL_SET_CLK_GATE: {
        AL_U8 ClkGateState = IoctlParam->ClkGateState;
        AlAdc_ll_SetInputSingal(Adc->AdcBaseAddr, ClkGateState);
        break;
    }
    case AL_ADC_IOCTL_POWER_DOWN: {
        AL_U8 PowerDownState = IoctlParam->PowerDownState;
        AlAdc_ll_SetInputSingal(Adc->AdcBaseAddr, PowerDownState);
        break;
    }
    case AL_ADC_IOCTL_ENABLE_PLADC_INTR: {
        AL_U8 EnablePlAdcIntrType = IoctlParam->EnablePlAdcIntrType;
        AlAdc_Dev_MaskPlAdcIntr(Adc, EnablePlAdcIntrType, AL_FALSE);
        break;
    }
    case AL_ADC_IOCTL_DISABLE_PLADC_INTR: {
        AL_U8 DisablePlAdcIntrType = IoctlParam->DisablePlAdcIntrType;
        AlAdc_Dev_MaskPlAdcIntr(Adc, DisablePlAdcIntrType, AL_TRUE);
        break;
    }
    case AL_ADC_IOCTL_CLR_PLADC_INTR: {
        AL_U8 ClrPlAdcIntrType = IoctlParam->ClrPlAdcIntrType;
        AlAdc_Dev_ClrPlAdcIntr(Adc, ClrPlAdcIntrType);
        break;
    }
    default:
        break;
    }

    return Ret;
}

/**
 * This function register a User Adc Callback To be used when send or receive done.
 * @param   Adc Pointer to a AL_ADC_DevStruct structure that contains adc device instance
 * @param   CallBack pointer to the Callback function
 * @param   CallbackRef pointer to the Callback function params
 * @return
 *       - AL_OK for function success
 *       - Other for function failure
 *
 */
AL_S32 AlAdc_Dev_RegisterEventCallBack(AL_ADC_DevStruct *Adc, AL_ADC_EventCallBack Callback, AL_VOID *CallbackRef)
{
    AL_ASSERT(((Adc != AL_NULL) && (Callback != AL_NULL)), AL_ADC_ERR_ILLEGAL_PARAM);

    Adc->EventCallBack        = Callback;
    Adc->EventCallBackRef     = CallbackRef;

    return AL_OK;
}

/**
 *
 * This function unregister a User Adc Callback To be used when send or receive done.
 *
 * @param   Adc Pointer to a AL_ADC_DevStruct structure that contains adc device instance
 *
 * @return
 *       - AL_OK for function success
 *       - Other for function failure
 *
 */
AL_S32 AlAdc_Dev_UnRegisterEventCallBack(AL_ADC_DevStruct *Adc)
{
    AL_ASSERT((Adc != AL_NULL), AL_ADC_ERR_ILLEGAL_PARAM);

    Adc->EventCallBack = (AL_ADC_EventCallBack)AL_NULL;

    return AL_OK;
}
