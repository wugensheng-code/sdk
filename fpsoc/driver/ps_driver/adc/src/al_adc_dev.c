/*
 * Copyright (c) 2023, Anlogic Inc. and Contributors. All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */
/***************************** Include Files *********************************/
#include "al_adc_dev.h"

/************************** Variable Definitions *****************************/
/* Hardware config generated by TD */
extern AL_ADC_HwConfigStruct AlAdc_HwConfig[AL_ADC_NUM_INSTANCE];
/**
 * This function look up hardware config structure.
 * @param   DeviceId is hardware module id
 * @return
 *          - AL_ADC_HwConfigStruct for hardware config
 * @note
*/
AL_ADC_HwConfigStruct *AlAdc_Dev_LookupConfig(AL_U32 DevId)
{
    AL_U32 Index;
    AL_ADC_HwConfigStruct *ConfigPtr = AL_NULL;

    for (Index = 0; Index < AL_ADC_NUM_INSTANCE; Index++) {
        if (AlAdc_HwConfig[Index].DeviceId == DevId) {
            ConfigPtr = &AlAdc_HwConfig[Index];
            break;
        }
    }
    return ConfigPtr;
}

/************************** Constant Definitions *****************************/

static AL_ADC_InitStruct AdcDefInitConfigs = {

    .InputSingal             = AL_ADC_UNIPOLAR,
    .Resolution              = AL_ADC_12BIT_MODE,
    .RefVoltag               = AL_ADC_REF_INTER_REF,
    .ClkSource               = AL_ADC_CLK_PL_70MHz,
    .ConvMode                = AL_ADC_CONTINUE_MODE,
    .ExternalMux             = AL_ADC_NORMAL_MODE,
    .MaxConvChanNum          = 7
};

/************************** Function Prototypes ******************************/

/************************** Function Definitions ******************************/

AL_S32 AlAdc_Dev_Init(AL_ADC_DevStruct *Adc, AL_U32 DevId, AL_ADC_InitStruct *InitConfig)
{
    AL_ADC_HwConfigStruct *AdcHwConfig;

    AL_ASSERT((Adc != AL_NULL && DevId < AL_ADC_NUM_INSTANCE), AL_ADC_ERR_ILLEGAL_PARAM);

    AdcHwConfig          = AlAdc_Dev_LookupConfig(DevId);
    Adc->DevId           = DevId;
    Adc->AdcBaseAddr     = AdcHwConfig->AdcBaseAddress;
    Adc->GpBaseAddr      = AdcHwConfig->GpBaseAddress;
    Adc->IntrNum         = AdcHwConfig->IntrNum;
    Adc->Configs         = (InitConfig == AL_NULL) ? AdcDefInitConfigs : (*InitConfig);

    /* Init PS-ADC Channel*/
    AlAdc_ll_FlushCmdFifo(Adc->AdcBaseAddr);
    AlAdc_ll_FlushDataFifo(Adc->AdcBaseAddr);
    AlAdc_ll_ResetPsAdc(Adc->AdcBaseAddr);

    AlAdc_ll_ClrPsAdcIntr(Adc->AdcBaseAddr);
    AlAdc_ll_ClrDataFifoLth(Adc->AdcBaseAddr);
    AlAdc_ll_ClrCmdFifoLth(Adc->AdcBaseAddr);
    AlAdc_ll_ClrDataFifoGth(Adc->AdcBaseAddr);
    AlAdc_ll_ClrCmdFifoGth(Adc->AdcBaseAddr);

    AlAdc_ll_MaskAdcIntr(Adc->AdcBaseAddr, AL_FALSE);
    AlAdc_ll_SetTckRate(Adc->AdcBaseAddr, 0);
    AlAdc_ll_EnablePsAdc(Adc->AdcBaseAddr, AL_TRUE);

    /* Init adc module through the PS-ADC Channel*/
    AL_ADC_PlReg_Cfg0 Cfg0;
    Cfg0.AdcSwReset = AL_ADC_SW_RELEASE;
    Cfg0.RefSel = Adc->Configs.RefVoltag;
    Cfg0.ResSel = Adc->Configs.Resolution;
    Cfg0.DiffEnable = Adc->Configs.InputSingal;
    Cfg0.PhyExternalMux = Adc->Configs.ExternalMux;
    Cfg0.AnalogMuxEn = AL_TRUE;
    AlAdc_ll_SetAdcCfg0Reg(Adc->AdcBaseAddr, Cfg0.RegData);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "AdcCfg0 is %x\r\n", AlAdc_ll_ReadPlAdcReg(Adc->AdcBaseAddr, ADC_CONFIG0_OFFSET));

    /* Clear and Mask intr for for ADC channel */
    AL_ADC_PlReg_Cfg1 Cfg1;
    Cfg1.IntrDoneMask = AL_TRUE;
    Cfg1.IntrGthMask = AL_TRUE;
    Cfg1.IntrLthMask = AL_TRUE;
    Cfg1.IntrErrorMask = AL_TRUE;
    Cfg1.IntrDone = AL_TRUE;
    Cfg1.IntrGth = AL_TRUE;
    Cfg1.IntrLth = AL_TRUE;
    Cfg1.IntrError = AL_TRUE;
    AlAdc_ll_SetAdcCfg1Reg(Adc->AdcBaseAddr, Cfg1.RegData);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "AdcCfg1 is %x\r\n", AlAdc_ll_ReadPlAdcReg(Adc->AdcBaseAddr, ADC_CONFIG1_OFFSET));

    /* Set ADC Clock */
    AL_ADC_PlReg_Cfg2 Cfg2;
    Cfg2.RegAdcEnable = 1;
    Cfg2.AdcClkSel = Adc->Configs.ClkSource;
    Cfg2.AdcClkGate = 0;
    AlAdc_ll_SetAdcCfg2Reg(Adc->AdcBaseAddr, Cfg2.RegData);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "AdcCfg2 is %x\r\n", AlAdc_ll_ReadPlAdcReg(Adc->AdcBaseAddr, ADC_CONFIG2_OFFSET));

    /* Set ADC Conv Mode */
    AL_ADC_PlReg_Cfg3 Cfg3;
    Cfg3.ModeSel = Adc->Configs.ConvMode;
    Cfg3.ChannelSel =Adc->Configs.MaxConvChanNum;
    AlAdc_ll_SetAdcCfg3Reg(Adc->AdcBaseAddr, Cfg3.RegData);
    AL_LOG(AL_LOG_LEVEL_DEBUG, "AdcCfg3 is %x\r\n", AlAdc_ll_ReadPlAdcReg(Adc->AdcBaseAddr, ADC_CONFIG3_OFFSET));

    return AL_OK;
}

AL_S32 AlAdc_Dev_SetIomuxForChan(AL_ADC_DevStruct *Adc, AL_ADC_ChannelCfg *ChannelCfg)
{
    AL_ASSERT(((Adc != AL_NULL) && (ChannelCfg != AL_NULL)), AL_ADC_ERR_ILLEGAL_PARAM);

    switch (ChannelCfg->ChanNum)
    {
    case AL_ADC_CHAN0:
        AlAdc_ll_SetIomuxForChan0(Adc->AdcBaseAddr, ChannelCfg->ChanIomux);
        break;
    case AL_ADC_CHAN1:
        AlAdc_ll_SetIomuxForChan1(Adc->AdcBaseAddr, ChannelCfg->ChanIomux);
        break;
    case AL_ADC_CHAN2:
        AlAdc_ll_SetIomuxForChan2(Adc->AdcBaseAddr, ChannelCfg->ChanIomux);
        break;
    case AL_ADC_CHAN3:
        AlAdc_ll_SetIomuxForChan3(Adc->AdcBaseAddr, ChannelCfg->ChanIomux);
        break;
    case AL_ADC_CHAN4:
        AlAdc_ll_SetIomuxForChan4(Adc->AdcBaseAddr, ChannelCfg->ChanIomux);
        break;
    case AL_ADC_CHAN5:
        AlAdc_ll_SetIomuxForChan5(Adc->AdcBaseAddr, ChannelCfg->ChanIomux);
        break;
    case AL_ADC_CHAN6:
        AlAdc_ll_SetIomuxForChan6(Adc->AdcBaseAddr, ChannelCfg->ChanIomux);
        break;
    case AL_ADC_CHAN7:
        AlAdc_ll_SetIomuxForChan7(Adc->AdcBaseAddr, ChannelCfg->ChanIomux);
        break;
    default:
        return AL_ADC_ERR_NOT_SUPPORT;
        break;
    }
    return AL_OK;
}

AL_S32 AlAdc_Dev_SetChanThre(AL_ADC_DevStruct *Adc, AL_ADC_ChannelCfg *ChannelCfg)
{
    AL_ASSERT(((Adc != AL_NULL) && (ChannelCfg != AL_NULL)), AL_ADC_ERR_ILLEGAL_PARAM);

    AlAdc_ll_SetAdcChanXLth(Adc->AdcBaseAddr, ChannelCfg->ChanNum, ChannelCfg->LthVal);
    AlAdc_ll_SetAdcChanXGth(Adc->AdcBaseAddr, ChannelCfg->ChanNum, ChannelCfg->GthVal);

    return AL_OK;
}

AL_S32 AlAdc_Dev_ClrAdcChanIntr(AL_ADC_DevStruct *Adc, AL_ADC_IntrtypeEnum IntrType)
{
    AL_ASSERT((Adc != AL_NULL), AL_ADC_ERR_ILLEGAL_PARAM);
    AL_ASSERT((IntrType == AL_ADC_INTR_DONE ||
               IntrType == AL_ADC_INTR_GTH ||
               IntrType == AL_ADC_INTR_LTH ||
               IntrType == AL_ADC_INTR_ERROR), AL_ADC_ERR_ILLEGAL_PARAM);

    AlAdc_ll_ClrChanIntr(Adc->AdcBaseAddr, IntrType);

    return AL_OK;
}

AL_S32 AlAdc_Dev_EnableChanIntr(AL_ADC_DevStruct *Adc, AL_ADC_IntrtypeEnum IntrType, AL_BOOL State)
{
    AL_ASSERT((Adc != AL_NULL), AL_ADC_ERR_ILLEGAL_PARAM);
    AL_ASSERT((IntrType == AL_ADC_INTR_DONE ||
               IntrType == AL_ADC_INTR_GTH ||
               IntrType == AL_ADC_INTR_LTH ||
               IntrType == AL_ADC_INTR_ERROR), AL_ADC_ERR_ILLEGAL_PARAM);

    if (State == AL_TRUE) {
        AlAdc_ll_EnableChanIntr(Adc->AdcBaseAddr, IntrType);
    } else {
        AlAdc_ll_DisableChanIntr(Adc->AdcBaseAddr, IntrType);
    }


    return AL_OK;
}

AL_VOID AlAdc_Dev_EnableAdc(AL_ADC_DevStruct *Adc)
{
    AlAdc_ll_EnableAdc(Adc->AdcBaseAddr);
}

AL_VOID AlAdc_Dev_DisableAdc(AL_ADC_DevStruct *Adc)
{
    AlAdc_ll_DisableAdc(Adc->AdcBaseAddr);
}

AL_VOID AlAdc_Dev_StartConv(AL_ADC_DevStruct *Adc)
{
    AlAdc_ll_StartConv(Adc->AdcBaseAddr);
}

AL_VOID AlAdc_Dev_StopConv(AL_ADC_DevStruct *Adc)
{
    AlAdc_ll_StopConv(Adc->AdcBaseAddr);
}

AL_U16 AlAdc_Dev_GetAdcData(AL_ADC_DevStruct *Adc, AL_ADC_ChanEnum ChanNum)
{
    while (1) {
        AL_U16 tmp = AlAdc_ll_GetAdcFlag(Adc->AdcBaseAddr);
        if(tmp & (1 << AL_ADC_FLAG_DONE)) {
            Adc->AdcData->ChanNum = ChanNum;
            Adc->AdcData->ChanData = AlAdc_ll_GetAdcData(Adc->AdcBaseAddr, ChanNum);
            break;
        }
    }
    return Adc->AdcData->ChanData;
}


static AL_VOID AlAdc_Dev_IntrDoneHandler(AL_ADC_DevStruct *Adc)
{
    AL_U32 Index;
    AL_ADC_EventStruct AdcEvent = {0};

    AL_U16 AdcFlag = AlAdc_ll_GetAdcFlag(Adc->AdcBaseAddr);
    for (Index = 0; Index <= Adc->Configs.MaxConvChanNum; Index++) {
        if (AdcFlag & (1 << (Index + AL_ADC_FLAG_COMP_VC0))) {
            Adc->AdcData[Index].ChanNum = Index;
            Adc->AdcData[Index].ChanData = AlAdc_ll_GetAdcData(Adc->AdcBaseAddr, Index);
            AdcEvent.EventData |= BIT(Index);
        }
    }

    AdcEvent.Events = AL_ADC_EVENT_GETDATA_DONE;
    if (Adc->EventCallBack) {
        (*Adc->EventCallBack)(AdcEvent, Adc->EventCallBackRef);
    }

    AlAdc_ll_ClrChanIntr(Adc->AdcBaseAddr, AL_ADC_INTR_DONE);
}

static AL_VOID AlAdc_Dev_IntrGthHandler(AL_ADC_DevStruct *Adc)
{
    AL_U32 Index;
    AL_ADC_EventStruct AdcEvent = {0};

    AL_U16 AdcFlag = AlAdc_ll_GetAdcFlag(Adc->AdcBaseAddr);
    for (Index = 0; Index <= Adc->Configs.MaxConvChanNum; Index++) {
        if (AdcFlag & (1 << (Index + AL_ADC_FLAG_COMP_VC0))) {
            Adc->AdcData[Index].ChanNum = Index;
            Adc->AdcData[Index].ChanData = AlAdc_ll_GetAdcData(Adc->AdcBaseAddr, Index);
            AdcEvent.EventData |= BIT(Index);
        }
    }

    AdcEvent.Events = AL_ADC_EVENT_GETDATA_GTH;
    if (Adc->EventCallBack) {
        (*Adc->EventCallBack)(AdcEvent, Adc->EventCallBackRef);
    }

    AlAdc_ll_ClrChanIntr(Adc->AdcBaseAddr, AL_ADC_INTR_GTH);
}

static AL_VOID AlAdc_Dev_IntrLthHandler(AL_ADC_DevStruct *Adc)
{
    AL_U32 Index;
    AL_ADC_EventStruct AdcEvent = {0};

    AL_U16 AdcFlag = AlAdc_ll_GetAdcFlag(Adc->AdcBaseAddr);
    for (Index = 0; Index <= Adc->Configs.MaxConvChanNum; Index++) {
        if (AdcFlag & (1 << (Index + AL_ADC_FLAG_COMP_VC0))) {
            Adc->AdcData[Index].ChanNum = Index;
            Adc->AdcData[Index].ChanData = AlAdc_ll_GetAdcData(Adc->AdcBaseAddr, Index);
            AdcEvent.EventData |= BIT(Index);
        }
    }

    AdcEvent.Events = AL_ADC_EVENT_GETDATA_LTH;
    if (Adc->EventCallBack) {
        (*Adc->EventCallBack)(AdcEvent, Adc->EventCallBackRef);
    }
    AlAdc_ll_ClrChanIntr(Adc->AdcBaseAddr, AL_ADC_INTR_LTH);
}

static AL_VOID AlAdc_Dev_IntrErrorHandler(AL_ADC_DevStruct *Adc)
{
    AL_U32 Index;
    AL_ADC_EventStruct AdcEvent = {0};

    AL_U16 AdcFlag = AlAdc_ll_GetAdcFlag(Adc->AdcBaseAddr);
    for (Index = 0; Index <= Adc->Configs.MaxConvChanNum; Index++) {
        if (AdcFlag & (1 << (Index + AL_ADC_FLAG_COMP_VC0))) {
            AdcEvent.EventData |= BIT(Index);
        }
    }

    AdcEvent.Events = AL_ADC_EVENT_ERROR;
    if (Adc->EventCallBack) {
        (*Adc->EventCallBack)(AdcEvent, Adc->EventCallBackRef);
    }
    AlAdc_ll_ClrChanIntr(Adc->AdcBaseAddr, AL_ADC_INTR_ERROR);
}


#define AL_ADC_IS_INTR_DONE(Status)            (Status & (AL_ADC_INTR_DONE_BIT))
#define AL_ADC_IS_INTR_GTH(Status)             (Status & (AL_ADC_INTR_GTH_BIT))
#define AL_ADC_IS_INTR_LTH(Status)             (Status & (AL_ADC_INTR_LTH_BIT))
#define AL_ADC_IS_INTR_ERROR(Status)           (Status & (AL_ADC_INTR_ERROR_BIT))

AL_VOID AlAdc_Dev_IntrHandler(AL_VOID *Instance)
{
    AL_ADC_DevStruct *Adc = (AL_ADC_DevStruct *)Instance;
    AL_U16 IntrStatus = AlAdc_ll_GetAdcChanIntrType(Adc->AdcBaseAddr);
    if (AL_ADC_IS_INTR_DONE(IntrStatus)) {
        AlAdc_Dev_IntrDoneHandler(Adc);
    }
    if (AL_ADC_IS_INTR_GTH(IntrStatus)) {
        AlAdc_Dev_IntrGthHandler(Adc);
    }
    if (AL_ADC_IS_INTR_LTH(IntrStatus)) {
        AlAdc_Dev_IntrLthHandler(Adc);
    }
    if (AL_ADC_IS_INTR_ERROR(IntrStatus)) {
        AlAdc_Dev_IntrErrorHandler(Adc);
    }
}

AL_S32 AlAdc_Dev_IoCtl(AL_ADC_DevStruct *Adc, AL_ADC_IoCtlCmdEnum Cmd, AL_ADC_IoctlParamUnion *IoctlParam)
{
    AL_S32 Ret = AL_OK;

    AL_ASSERT((Adc != AL_NULL), AL_ADC_ERR_ILLEGAL_PARAM);

    switch (Cmd)
    {
    case AL_ADC_IOCTL_SET_REFVOLTAG: {
        AL_U8 RefVoltag = IoctlParam->RefVoltag;
        AlAdc_ll_SetRefVoltag(Adc->AdcBaseAddr, RefVoltag);
        break;
    }
    case AL_ADC_IOCTL_SET_RESOLUTION: {
        AL_U8 Resolution = IoctlParam->Resolution;
        AlAdc_ll_SetResolution(Adc->AdcBaseAddr, Resolution);
        break;
    }
    case AL_ADC_IOCTL_SET_INPUTSINGAL: {
        AL_U8 InuputSignal = IoctlParam->InputSingal;
        AlAdc_ll_SetInputSingal(Adc->AdcBaseAddr, InuputSignal);
        break;
    }
    default:
        break;
    }

    return Ret;
}

AL_S32 AlAdc_Dev_RegisterEventCallBack(AL_ADC_DevStruct *Adc, AL_ADC_EventCallBack Callback, AL_VOID *CallbackRef)
{
    AL_ASSERT(((Adc != AL_NULL) && (Callback != AL_NULL)), AL_ADC_ERR_ILLEGAL_PARAM);

    Adc->EventCallBack        = Callback;
    Adc->EventCallBackRef     = CallbackRef;

    return AL_OK;
}

AL_S32 AlAdc_Dev_UnRegisterEventCallBack(AL_ADC_DevStruct *Adc)
{
    AL_ASSERT((Adc != AL_NULL), AL_ADC_ERR_ILLEGAL_PARAM);

    Adc->EventCallBack = (AL_ADC_EventCallBack)AL_NULL;

    return AL_OK;
}
