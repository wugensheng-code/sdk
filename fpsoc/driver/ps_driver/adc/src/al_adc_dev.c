/*
 * Copyright (c) 2023, Anlogic Inc. and Contributors. All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */
/***************************** Include Files *********************************/
#include "al_adc_dev.h"

/************************** Variable Definitions *****************************/
/* Hardware config generated by TD */
extern AL_ADC_HwConfigStruct AlAdc_HwConfig[AL_ADC_NUM_INSTANCE];
/**
 * This function look up hardware config structure.
 * @param   DeviceId is hardware module id
 * @return
 *          - AL_ADC_HwConfigStruct for hardware config
 * @note
*/
AL_ADC_HwConfigStruct *AlAdc_Dev_LookupConfig(AL_U32 DevId)
{
    AL_U32 Index;
    AL_ADC_HwConfigStruct *ConfigPtr = AL_NULL;

    for (Index = 0; Index < AL_ADC_NUM_INSTANCE; Index++) {
        if (AlAdc_HwConfig[Index].DeviceId == DevId) {
            ConfigPtr = &AlAdc_HwConfig[Index];
            break;
        }
    }
    return ConfigPtr;
}

/************************** Constant Definitions *****************************/

static AL_ADC_InitStruct AdcDefInitConfigs = {
    .InputSingal             = AL_ADC_UNIPOLAR,
    .Resolution              = AL_ADC_10BIT_MODE,
    .RefVoltag               = AL_ADC_REF_INTER_REF,
    .ClkSource               = AL_ADC_CLK_OSC_44MHz,
    .ConvMode                = AL_ADC_CONTINUOUS_MODE,
    .ConvChanNum             = 7,
};

/************************** Function Prototypes ******************************/

/************************** Function Definitions ******************************/

AL_S32 AlAdc_Dev_Init(AL_ADC_DevStruct *Adc, AL_U32 DevId, AL_ADC_InitStruct *InitConfig)
{
    AL_ADC_HwConfigStruct *AdcHwConfig;

    AL_ASSERT((Adc != AL_NULL && DevId < AL_ADC_NUM_INSTANCE), AL_ADC_ERR_ILLEGAL_PARAM);

    AdcHwConfig          = AlAdc_Dev_LookupConfig(DevId);
    Adc->DevId           = DevId;
    Adc->AdcBaseAddr     = AdcHwConfig->AdcBaseAddress;
    Adc->IntrNum         = AdcHwConfig->IntrNum;
    Adc->Configs         = (InitConfig == AL_NULL) ? AdcDefInitConfigs : (*InitConfig);

    /*********** Init PS-ADC ***********/
    AlAdc_ll_ResetPsAdc(Adc->AdcBaseAddr);
    AlAdc_ll_FlushCmdFifo(Adc->AdcBaseAddr);
    AlAdc_ll_FlushDataFifo(Adc->AdcBaseAddr);

    AlAdc_ll_ClrAllPsAdcIntr(Adc->AdcBaseAddr);
    AlAdc_ll_EnablePsAdc(Adc->AdcBaseAddr, AL_TRUE);

    /*********** Init PL-ADC ***********/
    AL_ADC_PlReg_Cfg0 Cfg0;
    Cfg0.AdcSwReset = AL_ADC_SW_RELEASE;
    Cfg0.Enctr = 0;
    Cfg0.RefSel = Adc->Configs.RefVoltag;
    Cfg0.ResSel = Adc->Configs.Resolution;
    Cfg0.DiffEnable = Adc->Configs.InputSingal;
    Cfg0.PhyExternalMux = 0;
    Cfg0.AnalogMuxEn = AL_TRUE;
    Cfg0.RegAdcSocSel = 0;
    Cfg0.PhyExternalMuxGap = 0;
    AlAdc_ll_SetAdcCfg0Reg(Adc->AdcBaseAddr, Cfg0.RegData);
    AL_LOG(AL_LOG_LEVEL_INFO, "AdcCfg0 is %x\r\n", AlAdc_ll_ReadPlAdcReg(Adc->AdcBaseAddr, ADC_CONFIG0_OFFSET));

    /* Clear and Mask intr for for ADC channel */
    AL_ADC_PlReg_Cfg1 Cfg1;
    Cfg1.IntrDoneMask = AL_TRUE;
    Cfg1.IntrGthMask = AL_TRUE;
    Cfg1.IntrLthMask = AL_TRUE;
    Cfg1.IntrErrorMask = AL_TRUE;
    Cfg1.IntrDone = AL_TRUE;
    Cfg1.IntrGth = AL_TRUE;
    Cfg1.IntrLth = AL_TRUE;
    Cfg1.IntrError = AL_TRUE;
    AlAdc_ll_SetAdcCfg1Reg(Adc->AdcBaseAddr, Cfg1.RegData);
    AL_LOG(AL_LOG_LEVEL_INFO, "AdcCfg1 is %x\r\n", AlAdc_ll_ReadPlAdcReg(Adc->AdcBaseAddr, ADC_CONFIG1_OFFSET));

    /* Set ADC Clock */
    AL_ADC_PlReg_Cfg2 Cfg2;
    Cfg2.RegAdcEnable = 0;
    Cfg2.RegAdcDislvl = 0;
    Cfg2.AdcClkSel = Adc->Configs.ClkSource;
    Cfg2.AdcClkGate = 0;
    Cfg2.AdcClkDiv = 0;
    AlAdc_ll_SetAdcCfg2Reg(Adc->AdcBaseAddr, Cfg2.RegData);
    AL_LOG(AL_LOG_LEVEL_INFO, "AdcCfg2 is %x\r\n", AlAdc_ll_ReadPlAdcReg(Adc->AdcBaseAddr, ADC_CONFIG2_OFFSET));

    /* Set ADC Conv Mode */
    AL_ADC_PlReg_Cfg3 Cfg3;
    Cfg3.ModeSel = Adc->Configs.ConvMode;
    Cfg3.ChanSel = Adc->Configs.ConvChanNum;
    Cfg3.ExternalChanSel = 0;
    Cfg3.RegAdcSoc = 0;
    AlAdc_ll_SetAdcCfg3Reg(Adc->AdcBaseAddr, Cfg3.RegData);
    AL_LOG(AL_LOG_LEVEL_INFO, "AdcCfg3 is %x\r\n", AlAdc_ll_ReadPlAdcReg(Adc->AdcBaseAddr, ADC_CONFIG3_OFFSET));

    return AL_OK;
}

AL_S32 AlAdc_Dev_EnablePsAdcIntr(AL_ADC_DevStruct *Adc, AL_ADC_PsIntrTypeEnum IntrType, AL_BOOL State)
{
    AL_ASSERT((Adc != AL_NULL), AL_ADC_ERR_ILLEGAL_PARAM);

    if (State == AL_TRUE) {
        AlAdc_ll_MaskPsAdcIntr(Adc->AdcBaseAddr, IntrType, AL_FALSE);
    } else {
        AlAdc_ll_MaskPsAdcIntr(Adc->AdcBaseAddr, IntrType, AL_TRUE);
    }

    return AL_OK;
}

AL_VOID AlAdc_Dev_EnablePlAdc(AL_ADC_DevStruct *Adc, AL_BOOL State)
{
    AlAdc_ll_EnablePlAdc(Adc->AdcBaseAddr, State);
}

AL_VOID AlAdc_Dev_StartConv(AL_ADC_DevStruct *Adc)
{
    AlAdc_ll_StartConv(Adc->AdcBaseAddr);
}

AL_VOID AlAdc_Dev_StopConv(AL_ADC_DevStruct *Adc)
{
    AlAdc_ll_StopConv(Adc->AdcBaseAddr);
}


AL_S32 AlAdc_Dev_EnablePlAdcIntr(AL_ADC_DevStruct *Adc, AL_ADC_PlIntrTypeEnum IntrType, AL_BOOL State)
{
    AL_ASSERT((Adc != AL_NULL), AL_ADC_ERR_ILLEGAL_PARAM);
    if (State == AL_TRUE) {
        switch (IntrType)
        {
        case AL_ADC_INTR_DONE_PL:
            AlAdc_ll_MaskPlAdcIntrDone(Adc->AdcBaseAddr, AL_FALSE);
            break;
        case AL_ADC_INTR_GTH_PL:
            AlAdc_ll_MaskPlAdcIntrGth(Adc->AdcBaseAddr, AL_FALSE);
            break;
        case AL_ADC_INTR_LTH_PL:
            AlAdc_ll_MaskPlAdcIntrLth(Adc->AdcBaseAddr, AL_FALSE);
            break;
        case AL_ADC_INTR_ERROR_PL:
            AlAdc_ll_MaskPlAdcIntrError(Adc->AdcBaseAddr, AL_FALSE);
            break;
        default:
            break;
        }
    } else {
        switch (IntrType)
        {
        case AL_ADC_INTR_DONE_PL:
            AlAdc_ll_MaskPlAdcIntrDone(Adc->AdcBaseAddr, AL_TRUE);
            break;
        case AL_ADC_INTR_GTH_PL:
            AlAdc_ll_MaskPlAdcIntrGth(Adc->AdcBaseAddr, AL_TRUE);
            break;
        case AL_ADC_INTR_LTH_PL:
            AlAdc_ll_MaskPlAdcIntrLth(Adc->AdcBaseAddr, AL_TRUE);
            break;
        case AL_ADC_INTR_ERROR_PL:
            AlAdc_ll_MaskPlAdcIntrError(Adc->AdcBaseAddr, AL_TRUE);
            break;
        default:
            break;
        }
    }
    return AL_OK;
}

AL_S32 AlAdc_Dev_SetMuxForChan(AL_ADC_DevStruct *Adc, AL_ADC_ChanCfg *ChanCfg)
{
    AL_ASSERT(((Adc != AL_NULL) && (ChanCfg != AL_NULL)), AL_ADC_ERR_ILLEGAL_PARAM);

    switch (ChanCfg->ChanNum)
    {
    case AL_ADC_CHAN0:
        AlAdc_ll_SetMuxForChan0(Adc->AdcBaseAddr, ChanCfg->MuxForChan);
        break;
    case AL_ADC_CHAN1:
        AlAdc_ll_SetMuxForChan1(Adc->AdcBaseAddr, ChanCfg->MuxForChan);
        break;
    case AL_ADC_CHAN2:
        AlAdc_ll_SetMuxForChan2(Adc->AdcBaseAddr, ChanCfg->MuxForChan);
        break;
    case AL_ADC_CHAN3:
        AlAdc_ll_SetMuxForChan3(Adc->AdcBaseAddr, ChanCfg->MuxForChan);
        break;
    case AL_ADC_CHAN4:
        AlAdc_ll_SetMuxForChan4(Adc->AdcBaseAddr, ChanCfg->MuxForChan);
        break;
    case AL_ADC_CHAN5:
        AlAdc_ll_SetMuxForChan5(Adc->AdcBaseAddr, ChanCfg->MuxForChan);
        break;
    case AL_ADC_CHAN6:
        AlAdc_ll_SetMuxForChan6(Adc->AdcBaseAddr, ChanCfg->MuxForChan);
        break;
    case AL_ADC_CHAN7:
        AlAdc_ll_SetMuxForChan7(Adc->AdcBaseAddr, ChanCfg->MuxForChan);
        break;
    default:
        break;
    }
    return AL_OK;
}

AL_S32 AlAdc_Dev_SetThreForChan(AL_ADC_DevStruct *Adc, AL_ADC_ChanCfg *ChanCfg)
{
    AL_ASSERT(((Adc != AL_NULL) && (ChanCfg != AL_NULL)), AL_ADC_ERR_ILLEGAL_PARAM);

    AlAdc_ll_SetAdcChanXLth(Adc->AdcBaseAddr, ChanCfg->ChanNum, ChanCfg->LthVal);
    AlAdc_ll_SetAdcChanXGth(Adc->AdcBaseAddr, ChanCfg->ChanNum, ChanCfg->GthVal);

    return AL_OK;
}

AL_S32 AlAdc_Dev_ClrPlAdcIntr(AL_ADC_DevStruct *Adc, AL_ADC_PlIntrTypeEnum IntrType)
{
    AL_ASSERT((Adc != AL_NULL), AL_ADC_ERR_ILLEGAL_PARAM);

    switch (IntrType)
    {
    case AL_ADC_INTR_DONE_PL:
        AlAdc_ll_ClrPlAdcIntrDone(Adc->AdcBaseAddr);
        break;
    case AL_ADC_INTR_GTH_PL:
        AlAdc_ll_ClrPlAdcIntrGth(Adc->AdcBaseAddr);
        break;
    case AL_ADC_INTR_LTH_PL:
        AlAdc_ll_ClrPlAdcIntrDone(Adc->AdcBaseAddr);
        break;
    case AL_ADC_INTR_ERROR_PL:
        AlAdc_ll_ClrPlAdcIntrGth(Adc->AdcBaseAddr);
        break;
    default:
        break;
    }

    return AL_OK;
}

AL_U16 AlAdc_Dev_GetAdcData(AL_ADC_DevStruct *Adc, AL_ADC_ChanEnum ChanNum)
{
    while (1) {
        AL_U16 TMP = AlAdc_ll_GetPlAdcIntrType(Adc->AdcBaseAddr);
        if(TMP & BIT(AL_ADC_INTR_DONE_PL)) {
            Adc->AdcData->ChanNum = ChanNum;
            Adc->AdcData->ChanData = AlAdc_ll_GetAdcData(Adc->AdcBaseAddr, ChanNum);
            break;
        }
    }
    return Adc->AdcData->ChanData;
}


static AL_VOID AlAdc_Dev_IntrDoneHandler(AL_ADC_DevStruct *Adc)
{
    AL_U32 Index;
    AL_ADC_EventStruct AdcEvent = {0};

    for (Index = 0; Index <= Adc->Configs.ConvChanNum; Index++) {
        Adc->AdcData[Index].ChanNum = Index;
        Adc->AdcData[Index].ChanData = AlAdc_ll_GetAdcData(Adc->AdcBaseAddr, Index);
        AdcEvent.EventData |= BIT(Index);
    }

    AlAdc_ll_ClrPlAdcIntrDone(Adc->AdcBaseAddr);

    AdcEvent.Events = AL_ADC_EVENT_DATA_DONE;
    if (Adc->EventCallBack) {
        (*Adc->EventCallBack)(AdcEvent, Adc->EventCallBackRef);
    }
}

static AL_VOID AlAdc_Dev_IntrGthHandler(AL_ADC_DevStruct *Adc)
{
    AL_U32 Index;
    AL_ADC_EventStruct AdcEvent = {0};

    AL_U16 AdcFlag = AlAdc_ll_GetAdcFlag(Adc->AdcBaseAddr);
    for (Index = 0; Index <= Adc->Configs.ConvChanNum; Index++) {
        if (AdcFlag & (1 << (Index + AL_ADC_FLAG_COMP_VC0))) {
            Adc->AdcData[Index].ChanNum = Index;
            Adc->AdcData[Index].ChanData = AlAdc_ll_GetAdcData(Adc->AdcBaseAddr, Index);
            AdcEvent.EventData |= BIT(Index);
        }
    }

    AlAdc_ll_ClrPlAdcIntrGth(Adc->AdcBaseAddr);

    AdcEvent.Events = AL_ADC_EVENT_DATA_GTH;
    if (Adc->EventCallBack) {
        (*Adc->EventCallBack)(AdcEvent, Adc->EventCallBackRef);
    }
}

static AL_VOID AlAdc_Dev_IntrLthHandler(AL_ADC_DevStruct *Adc)
{
    AL_U32 Index;
    AL_ADC_EventStruct AdcEvent = {0};

    AL_U16 AdcFlag = AlAdc_ll_GetAdcFlag(Adc->AdcBaseAddr);
    for (Index = 0; Index <= Adc->Configs.ConvChanNum; Index++) {
        if (AdcFlag & (1 << (Index + AL_ADC_FLAG_COMP_VC0))) {
            Adc->AdcData[Index].ChanNum = Index;
            Adc->AdcData[Index].ChanData = AlAdc_ll_GetAdcData(Adc->AdcBaseAddr, Index);
            AdcEvent.EventData |= BIT(Index);
        }
    }

    AlAdc_ll_ClrPlAdcIntrLth(Adc->AdcBaseAddr);

    AdcEvent.Events = AL_ADC_EVENT_DATA_LTH;
    if (Adc->EventCallBack) {
        (*Adc->EventCallBack)(AdcEvent, Adc->EventCallBackRef);
    }
}

static AL_VOID AlAdc_Dev_IntrErrorHandler(AL_ADC_DevStruct *Adc)
{
    AL_U32 Index;
    AL_ADC_EventStruct AdcEvent = {0};

    AlAdc_ll_ClrPlAdcIntrError(Adc->AdcBaseAddr);

    AdcEvent.Events = AL_ADC_EVENT_DATA_ERROR;
    if (Adc->EventCallBack) {
        (*Adc->EventCallBack)(AdcEvent, Adc->EventCallBackRef);
    }
}

AL_VOID AlAdc_Dev_IntrHandler(AL_VOID *Instance)
{
    AL_ADC_DevStruct *Adc = (AL_ADC_DevStruct *)Instance;
    AL_U32 PsAdcIntrStatus;
    AL_U16 PlAdcIntrStatus;

    /* Get PsAdc interrupts status */
    PsAdcIntrStatus = AlAdc_ll_GetPsAdcIntrType(Adc->AdcBaseAddr);

    if (PsAdcIntrStatus & BIT(AL_ADC_PLADC_INTR)) {

        /* The interrupt about PlAdc */
        PlAdcIntrStatus = AlAdc_ll_GetPlAdcIntrType(Adc->AdcBaseAddr);

        /* Determine the interrupt type of PlAdc */
        if (PlAdcIntrStatus & BIT(AL_ADC_INTR_DONE_PL)) {
            AlAdc_Dev_IntrDoneHandler(Adc);
        }
        if (PlAdcIntrStatus & BIT(AL_ADC_INTR_GTH_PL)) {
            AlAdc_Dev_IntrGthHandler(Adc);
        }
        if (PlAdcIntrStatus & BIT(AL_ADC_INTR_LTH_PL)) {
            AlAdc_Dev_IntrLthHandler(Adc);
        }
        if (PlAdcIntrStatus & BIT(AL_ADC_INTR_ERROR_PL)) {
            AlAdc_Dev_IntrErrorHandler(Adc);
        }

        AlAdc_ll_ClrPsAdcIntr(Adc->AdcBaseAddr, AL_ADC_PLADC_INTR);
    }
}

AL_S32 AlAdc_Dev_IoCtl(AL_ADC_DevStruct *Adc, AL_ADC_IoCtlCmdEnum Cmd, AL_ADC_IoctlParamUnion *IoctlParam)
{
    AL_S32 Ret = AL_OK;

    AL_ASSERT((Adc != AL_NULL), AL_ADC_ERR_ILLEGAL_PARAM);

    switch (Cmd)
    {
    case AL_ADC_IOCTL_SET_REFVOLTAG: {
        AL_U8 RefVoltag = IoctlParam->RefVoltag;
        AlAdc_ll_SetRefVoltag(Adc->AdcBaseAddr, RefVoltag);
        break;
    }
    case AL_ADC_IOCTL_SET_RESOLUTION: {
        AL_U8 Resolution = IoctlParam->Resolution;
        AlAdc_ll_SetResolution(Adc->AdcBaseAddr, Resolution);
        break;
    }
    case AL_ADC_IOCTL_SET_INPUTSINGAL: {
        AL_U8 InuputSignal = IoctlParam->InputSingal;
        AlAdc_ll_SetInputSingal(Adc->AdcBaseAddr, InuputSignal);
        break;
    }
    default:
        break;
    }

    return Ret;
}

AL_S32 AlAdc_Dev_RegisterEventCallBack(AL_ADC_DevStruct *Adc, AL_ADC_EventCallBack Callback, AL_VOID *CallbackRef)
{
    AL_ASSERT(((Adc != AL_NULL) && (Callback != AL_NULL)), AL_ADC_ERR_ILLEGAL_PARAM);

    Adc->EventCallBack        = Callback;
    Adc->EventCallBackRef     = CallbackRef;

    return AL_OK;
}

AL_S32 AlAdc_Dev_UnRegisterEventCallBack(AL_ADC_DevStruct *Adc)
{
    AL_ASSERT((Adc != AL_NULL), AL_ADC_ERR_ILLEGAL_PARAM);

    Adc->EventCallBack = (AL_ADC_EventCallBack)AL_NULL;

    return AL_OK;
}
