/*
 * Copyright (c) 2023, Anlogic Inc. and Contributors. All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

/***************************** Include Files *********************************/
#include "al_tc_dev.h"


/************************** Variable Definitions *****************************/
/* Hardware config generated by TD */
extern AL_TC_HwConfigStruct AlTc_HwConfig[AL_TC_NUM_INSTANCE];

/**
 * This function searches through the available hardware configurations
 * to find the one that matches the given device ID. If a match is found,
 * a pointer to the configuration structure is returned. Otherwise, NULL is returned.
 *
 * @param DevId The device ID for which the hardware configuration is being looked up.
 * @return A pointer to the hardware configuration structure if found, otherwise NULL.
 */
AL_TC_HwConfigStruct *AlTc_Dev_LookupConfig(AL_U32 DevId)
{
    AL_U32 Index;
    AL_TC_HwConfigStruct *ConfigPtr = AL_NULL;

    for (Index = 0; Index < AL_TC_NUM_INSTANCE; Index++) {
        if (AlTc_HwConfig[Index].DevId == DevId) {
            ConfigPtr = &AlTc_HwConfig[Index];
            break;
        }
    }
    return ConfigPtr;
}

/************************** Constant Definitions *****************************/

static AL_TC_TimerInitStruct TcDefInitConfigs = {
    .CountDec            = AL_TC_CountUp,
    .ClkSrc              = AL_TC_PCLK,
    .EnablePrescale      = AL_TRUE,
    .PrescaleVal         = 2,
};

/************************** Function Prototypes ******************************/

/************************** Function Definitions ******************************/
/**
 * This function sets up a TC device based on the provided device ID and initialization
 * configurations. It configures the device's base address, interrupt number, input clock frequency,
 * and other timer settings. It also performs a series of low-level initializations to reset the counter,
 * set the clock source, enable/disable overflow mode, and more.
 *
 * @param Tc Pointer to the TC device structure to be initialized.
 * @param DevId The device ID of the TC to be initialized.
 * @param InitConfig Pointer to the initialization configuration structure. If NULL, default configurations are used.
 * @return AL_OK if the initialization is successful, error code otherwise.
 */
AL_S32 AlTc_Dev_Init(AL_TC_DevStruct *Tc, AL_U32 DevId, AL_TC_TimerInitStruct *InitConfig)
{
    AL_TC_HwConfigStruct *TcHwConfig;

    AL_ASSERT((Tc != AL_NULL && DevId < AL_TC_NUM_INSTANCE), AL_TC_ERR_ILLEGAL_PARAM);

    TcHwConfig              = AlTc_Dev_LookupConfig(DevId);
    Tc->DevId               = DevId;
    Tc->BaseAddr            = TcHwConfig->BaseAddress;
    Tc->IntrNum             = TcHwConfig->IntrNum;
    Tc->InputClockHz        = TcHwConfig->InputClockHz;
    Tc->TimerInitConfigs    = (InitConfig == AL_NULL) ? TcDefInitConfigs : *InitConfig;

    AlTc_ll_ResetCounter(Tc->BaseAddr);
    AlTc_ll_EnbaleOverflowMode(Tc->BaseAddr);
    AlTc_ll_SetClkSrc(Tc->BaseAddr, Tc->TimerInitConfigs.ClkSrc);
    AlTc_ll_EnbaleCounter(Tc->BaseAddr, AL_FALSE);
    AlTc_ll_DisableAllIntr(Tc->BaseAddr);
    AlTc_ll_EnableWaveOutput(Tc->BaseAddr, AL_FALSE);
    AlTc_ll_EnableEventTimerMode(Tc->BaseAddr, AL_FALSE);
    AlTc_ll_EnbalePresacle(Tc->BaseAddr, Tc->TimerInitConfigs.EnablePrescale);
    AlTc_ll_SetPresacleVal(Tc->BaseAddr, Tc->TimerInitConfigs.PrescaleVal);
    AlTc_ll_SetCountDec(Tc->BaseAddr, Tc->TimerInitConfigs.CountDec);
    AlTc_ll_GetIntrtype(Tc->BaseAddr);

    return AL_OK;
}

/**
 * This function is called when an interval timer event occurs. It constructs an event structure
 * and calls the registered callback function, passing the event structure and callback reference.
 *
 * @param Tc Pointer to the TC device structure.
 */
static AL_VOID AlTc_Dev_IntervalHandler(AL_TC_DevStruct *Tc)
{
    AL_TC_EventStruct TcEvent = {
        .Events = AL_TC_EVENT_Interval
    };
    if (Tc->EventCallBack) {
        (*Tc->EventCallBack)(TcEvent, Tc->EventCallBackRef);
    }
}

/**
 * This function is called when a match1 timer event occurs. It constructs an event structure
 * and calls the registered callback function, passing the event structure and callback reference.
 *
 * @param Tc Pointer to the TC device structure.
 */
static AL_VOID AlTc_Dev_Match1Handler(AL_TC_DevStruct *Tc)
{
    AL_TC_EventStruct TcEvent = {
        .Events = AL_TC_EVENT_Match1
    };
    if (Tc->EventCallBack) {
        (*Tc->EventCallBack)(TcEvent, Tc->EventCallBackRef);
    }
}

/**
 * This function is called when a match2 timer event occurs. It constructs an event structure
 * and calls the registered callback function, passing the event structure and callback reference.
 *
 * @param Tc Pointer to the TC device structure.
 */
static AL_VOID AlTc_Dev_Match2Handler(AL_TC_DevStruct *Tc)
{
    AL_TC_EventStruct TcEvent = {
        .Events = AL_TC_EVENT_Match2
    };
    if (Tc->EventCallBack) {
        (*Tc->EventCallBack)(TcEvent, Tc->EventCallBackRef);
    }
}

/**
 * This function is called when a match3 timer event occurs. It constructs an event structure
 * and calls the registered callback function, passing the event structure and callback reference.
 *
 * @param Tc Pointer to the TC device structure.
 */
static AL_VOID AlTc_Dev_Match3Handler(AL_TC_DevStruct *Tc)
{
    AL_TC_EventStruct TcEvent = {
        .Events = AL_TC_EVENT_Match3
    };
    if (Tc->EventCallBack) {
        (*Tc->EventCallBack)(TcEvent, Tc->EventCallBackRef);
    }
}

/**
 * This function is called when an overflow timer event occurs. It constructs an event structure
 * and calls the registered callback function, passing the event structure and callback reference.
 *
 * @param Tc Pointer to the TC device structure.
 */
static AL_VOID AlTc_Dev_OverflowHandler(AL_TC_DevStruct *Tc)
{
    AL_TC_EventStruct TcEvent = {
        .Events = AL_TC_EVENT_Overflow
    };
    if (Tc->EventCallBack) {
        (*Tc->EventCallBack)(TcEvent, Tc->EventCallBackRef);
    }
}

/**
 * This function is called when an event timer event occurs. It reads the event timer value,
 * constructs an event structure including the read value, and calls the registered callback function,
 * passing the event structure and callback reference.
 *
 * @param Tc Pointer to the TC device structure.
 */
static AL_VOID AlTc_Dev_EventTimerHandler(AL_TC_DevStruct *Tc)
{
    AL_TC_EventStruct TcEvent = {
        .Events = AL_TC_EVENT_EventTimer,
        .EventData = 0
    };

    TcEvent.EventData = AlTc_ll_GetEventTimerVal(Tc->BaseAddr);

    if (Tc->EventCallBack) {
        (*Tc->EventCallBack)(TcEvent, Tc->EventCallBackRef);
    }
}


#define AL_TC_INTR_INTERVAL(Status)           (Status & (BIT(AL_TC_IntrInterval)))
#define AL_TC_INTR_MATCH1(Status)             (Status & (BIT(AL_TC_IntrMatch1)))
#define AL_TC_INTR_MATCH2(Status)             (Status & (BIT(AL_TC_IntrMatch2)))
#define AL_TC_INTR_MATCH3(Status)             (Status & (BIT(AL_TC_IntrMatch3)))
#define AL_TC_INTR_OVERFLOW(Status)           (Status & (BIT(AL_TC_IntrOverflow)))
#define AL_TC_INTR_EVENTTIMER(Status)         (Status & (BIT(AL_TC_IntrEventTimer)))

/**
 * This function is the main interrupt handler for the TC device. It checks the interrupt status
 * and calls the appropriate event handler function based on which interrupt(s) are active.
 *
 * @param Instance Pointer to the TC device structure (cast to void*).
 */
AL_VOID AlTc_Dev_IntrHandler(AL_VOID *Instance)
{
    AL_TC_DevStruct *Tc = (AL_TC_DevStruct *)Instance;
    AL_U32 IntrStatus = AlTc_ll_GetIntrtype(Tc->BaseAddr);

    if (AL_TC_INTR_INTERVAL(IntrStatus)) {
        AlTc_Dev_IntervalHandler(Tc);
    }
    if (AL_TC_INTR_MATCH1(IntrStatus)) {
        AlTc_Dev_Match1Handler(Tc);
    }
    if (AL_TC_INTR_MATCH2(IntrStatus)) {
        AlTc_Dev_Match2Handler(Tc);
    }
    if (AL_TC_INTR_MATCH3(IntrStatus)) {
        AlTc_Dev_Match3Handler(Tc);
    }
    if (AL_TC_INTR_OVERFLOW(IntrStatus)) {
        AlTc_Dev_OverflowHandler(Tc);
    }
    if (AL_TC_INTR_EVENTTIMER(IntrStatus)) {
        AlTc_Dev_EventTimerHandler(Tc);
    }
}

/**
 * This function provides a generic interface for performing various control operations on a TC device,
 * such as setting the interval max value, getting the counter value, enabling wave output, etc.
 * The operation to be performed is specified by the Cmd parameter, and any additional information
 * required for the operation is passed through the IoctlParam union.
 *
 * @param Tc Pointer to the TC device structure.
 * @param Cmd The IOCTL command to be performed.
 * @param IoctlParam Pointer to the IOCTL parameter union, which holds the necessary data for the command.
 * @return AL_OK if the operation is successful, error code otherwise.
 */
AL_S32 AlTc_Dev_IoCtl(AL_TC_DevStruct *Tc, AL_TC_IoCtlCmdEnum Cmd, AL_TC_IoctlParamUnion *IoctlParam)
{
    AL_S32 Ret = AL_OK;

    AL_ASSERT((Tc != AL_NULL), AL_TC_ERR_ILLEGAL_PARAM);

    switch (Cmd)
    {
    case AL_TC_IOCTL_SetIntervalMaxVal:
        AlTc_ll_SetIntervalMaxVal(Tc->BaseAddr, IoctlParam->IntervalMaxVal);
        break;
    case AL_TC_IOCTL_GetCounterVal:
        IoctlParam->GetCounterVal = AlTc_ll_GetCounterVal(Tc->BaseAddr);
        break;
    case AL_TC_IOCTL_GetEventTimerVal:
        IoctlParam->GetEventTimerVal = AlTc_ll_GetEventTimerVal(Tc->BaseAddr);
        break;
    case AL_TC_IOCTL_EnableWaveOutput:
        AlTc_ll_EnableWaveOutput(Tc->BaseAddr, IoctlParam->WaveOutputState);
        break;
    default:
        AL_LOG(AL_LOG_LEVEL_ERROR, "AL_TC_ERR_IOCTL_CMD");
        break;
    }

    return Ret;
}

/**
 * This function allows the user to register a callback function that will be called when an event occurs
 * on the TC device. The callback function and a reference pointer are stored in the TC device structure.
 *
 * @param Tc Pointer to the TC device structure.
 * @param Callback The callback function to be registered.
 * @param CallbackRef A user-defined reference pointer to be passed to the callback function.
 * @return AL_OK if the registration is successful.
 */
AL_S32 AlTc_Dev_RegisterEventCallBack(AL_TC_DevStruct *Tc, AL_TC_EventCallBack Callback, void *CallbackRef)
{
    Tc->EventCallBack        = Callback;
    Tc->EventCallBackRef     = CallbackRef;

    return AL_OK;
}

/**
 * This function removes the previously registered callback function from the TC device structure,
 * effectively disabling event notifications to the user.
 *
 * @param Tc Pointer to the TC device structure.
 * @return AL_OK if the unregistration is successful.
 */
AL_S32 AlTc_Dev_UnRegisterEventCallBack(AL_TC_DevStruct *Tc)
{
    Tc->EventCallBack = (AL_TC_EventCallBack)AL_NULL;

    return AL_OK;
}







