/*
 * Copyright (c) 2023, Anlogic Inc. and Contributors. All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

/***************************** Include Files *********************************/
#include "al_ttc_dev.h"


/************************** Variable Definitions *****************************/
/* Hardware config generated by TD */
extern AL_TTC_HwConfigStruct AlTtc_HwConfig[AL_TTC_NUM_INSTANCE];

/**
 * This function searches through the available hardware configurations
 * to find the one that matches the given device ID. If a match is found,
 * a pointer to the configuration structure is returned. Otherwise, NULL is returned.
 *
 * @param DevId The device ID for which the hardware configuration is being looked up.
 * @return A pointer to the hardware configuration structure if found, otherwise NULL.
 */
AL_TTC_HwConfigStruct *AlTtc_Dev_LookupConfig(AL_U32 DevId)
{
    AL_U32 Index;
    AL_TTC_HwConfigStruct *ConfigPtr = AL_NULL;

    for (Index = 0; Index < AL_TTC_NUM_INSTANCE; Index++) {
        if (AlTtc_HwConfig[Index].DevId == DevId) {
            ConfigPtr = &AlTtc_HwConfig[Index];
            break;
        }
    }
    return ConfigPtr;
}

/************************** Constant Definitions *****************************/

static AL_TTC_TimerInitStruct TtcDefInitConfigs = {
    .CountDec            = AL_TTC_CountUp,
    .ClkSrc              = AL_TTC_PCLK,
    .EnablePrescale      = AL_TRUE,
    .PrescaleVal         = 2,
};

/************************** Function Prototypes ******************************/

/************************** Function Definitions ******************************/
/**
 * This function sets up a TTC device based on the provided device ID and initialization
 * configurations. It configures the device's base address, interrupt number, input clock frequency,
 * and other timer settings. It also performs a series of low-level initializations to reset the counter,
 * set the clock source, enable/disable overflow mode, and more.
 *
 * @param Ttc Pointer to the TTC device structure to be initialized.
 * @param DevId The device ID of the TTC to be initialized.
 * @param InitConfig Pointer to the initialization configuration structure. If NULL, default configurations are used.
 * @return AL_OK if the initialization is successful, error code otherwise.
 */
AL_S32 AlTtc_Dev_Init(AL_TTC_DevStruct *Ttc, AL_U32 DevId, AL_TTC_TimerInitStruct *InitConfig)
{
    AL_TTC_HwConfigStruct *TtcHwConfig;

    AL_ASSERT((Ttc != AL_NULL && DevId < AL_TTC_NUM_INSTANCE), AL_TTC_ERR_ILLEGAL_PARAM);

    TtcHwConfig              = AlTtc_Dev_LookupConfig(DevId);
    Ttc->DevId               = DevId;
    Ttc->BaseAddr            = TtcHwConfig->BaseAddress;
    Ttc->IntrNum             = TtcHwConfig->IntrNum;
    Ttc->InputClockHz        = TtcHwConfig->InputClockHz;
    Ttc->TimerInitConfigs    = (InitConfig == AL_NULL) ? TtcDefInitConfigs : *InitConfig;

    AlTtc_ll_ResetCounter(Ttc->BaseAddr);
    AlTtc_ll_EnbaleOverflowMode(Ttc->BaseAddr);
    AlTtc_ll_SetClkSrc(Ttc->BaseAddr, Ttc->TimerInitConfigs.ClkSrc);
    AlTtc_ll_EnbaleCounter(Ttc->BaseAddr, AL_FALSE);
    AlTtc_ll_DisableAllIntr(Ttc->BaseAddr);
    AlTtc_ll_EnableWaveOutput(Ttc->BaseAddr, AL_FALSE);
    AlTtc_ll_EnableEventTimerMode(Ttc->BaseAddr, AL_FALSE);
    AlTtc_ll_EnbalePresacle(Ttc->BaseAddr, Ttc->TimerInitConfigs.EnablePrescale);
    AlTtc_ll_SetPresacleVal(Ttc->BaseAddr, Ttc->TimerInitConfigs.PrescaleVal);
    AlTtc_ll_SetCountDec(Ttc->BaseAddr, Ttc->TimerInitConfigs.CountDec);
    AltTtc_ll_GetIntrtype(Ttc->BaseAddr);

    return AL_OK;
}

/**
 * This function is called when an interval timer event occurs. It constructs an event structure
 * and calls the registered callback function, passing the event structure and callback reference.
 *
 * @param Ttc Pointer to the TTC device structure.
 */
static AL_VOID AlTtc_Dev_IntervalHandler(AL_TTC_DevStruct *Ttc)
{
    AL_TTC_EventStruct TtcEvent = {
        .Events = AL_TTC_EVENT_Interval
    };
    if (Ttc->EventCallBack) {
        (*Ttc->EventCallBack)(TtcEvent, Ttc->EventCallBackRef);
    }
}

/**
 * This function is called when a match1 timer event occurs. It constructs an event structure
 * and calls the registered callback function, passing the event structure and callback reference.
 *
 * @param Ttc Pointer to the TTC device structure.
 */
static AL_VOID AlTtc_Dev_Match1Handler(AL_TTC_DevStruct *Ttc)
{
    AL_TTC_EventStruct TtcEvent = {
        .Events = AL_TTC_EVENT_Match1
    };
    if (Ttc->EventCallBack) {
        (*Ttc->EventCallBack)(TtcEvent, Ttc->EventCallBackRef);
    }
}

/**
 * This function is called when a match2 timer event occurs. It constructs an event structure
 * and calls the registered callback function, passing the event structure and callback reference.
 *
 * @param Ttc Pointer to the TTC device structure.
 */
static AL_VOID AlTtc_Dev_Match2Handler(AL_TTC_DevStruct *Ttc)
{
    AL_TTC_EventStruct TtcEvent = {
        .Events = AL_TTC_EVENT_Match2
    };
    if (Ttc->EventCallBack) {
        (*Ttc->EventCallBack)(TtcEvent, Ttc->EventCallBackRef);
    }
}

/**
 * This function is called when a match3 timer event occurs. It constructs an event structure
 * and calls the registered callback function, passing the event structure and callback reference.
 *
 * @param Ttc Pointer to the TTC device structure.
 */
static AL_VOID AlTtc_Dev_Match3Handler(AL_TTC_DevStruct *Ttc)
{
    AL_TTC_EventStruct TtcEvent = {
        .Events = AL_TTC_EVENT_Match3
    };
    if (Ttc->EventCallBack) {
        (*Ttc->EventCallBack)(TtcEvent, Ttc->EventCallBackRef);
    }
}

/**
 * This function is called when an overflow timer event occurs. It constructs an event structure
 * and calls the registered callback function, passing the event structure and callback reference.
 *
 * @param Ttc Pointer to the TTC device structure.
 */
static AL_VOID AlTtc_Dev_OverflowHandler(AL_TTC_DevStruct *Ttc)
{
    AL_TTC_EventStruct TtcEvent = {
        .Events = AL_TTC_EVENT_Overflow
    };
    if (Ttc->EventCallBack) {
        (*Ttc->EventCallBack)(TtcEvent, Ttc->EventCallBackRef);
    }
}

/**
 * This function is called when an event timer event occurs. It reads the event timer value,
 * constructs an event structure including the read value, and calls the registered callback function,
 * passing the event structure and callback reference.
 *
 * @param Ttc Pointer to the TTC device structure.
 */
static AL_VOID AlTtc_Dev_EventTimerHandler(AL_TTC_DevStruct *Ttc)
{
    AL_TTC_EventStruct TtcEvent = {
        .Events = AL_TTC_EVENT_EventTimer,
        .EventData = 0
    };

    TtcEvent.EventData = AltTtc_ll_GetEventTimerVal(Ttc->BaseAddr);

    if (Ttc->EventCallBack) {
        (*Ttc->EventCallBack)(TtcEvent, Ttc->EventCallBackRef);
    }
}


#define AL_TTC_INTR_INTERVAL(Status)           (Status & (BIT(AL_TTC_IntrInterval)))
#define AL_TTC_INTR_MATCH1(Status)             (Status & (BIT(AL_TTC_IntrMatch1)))
#define AL_TTC_INTR_MATCH2(Status)             (Status & (BIT(AL_TTC_IntrMatch2)))
#define AL_TTC_INTR_MATCH3(Status)             (Status & (BIT(AL_TTC_IntrMatch3)))
#define AL_TTC_INTR_OVERFLOW(Status)           (Status & (BIT(AL_TTC_IntrOverflow)))
#define AL_TTC_INTR_EVENTTIMER(Status)         (Status & (BIT(AL_TTC_IntrEventTimer)))

/**
 * This function is the main interrupt handler for the TTC device. It checks the interrupt status
 * and calls the appropriate event handler function based on which interrupt(s) are active.
 *
 * @param Instance Pointer to the TTC device structure (cast to void*).
 */
AL_VOID AlTtc_Dev_IntrHandler(AL_VOID *Instance)
{
    AL_TTC_DevStruct *Ttc = (AL_TTC_DevStruct *)Instance;
    AL_U32 IntrStatus = AltTtc_ll_GetIntrtype(Ttc->BaseAddr);

    if (AL_TTC_INTR_INTERVAL(IntrStatus)) {
        AlTtc_Dev_IntervalHandler(Ttc);
    }
    if (AL_TTC_INTR_MATCH1(IntrStatus)) {
        AlTtc_Dev_Match1Handler(Ttc);
    }
    if (AL_TTC_INTR_MATCH2(IntrStatus)) {
        AlTtc_Dev_Match2Handler(Ttc);
    }
    if (AL_TTC_INTR_MATCH3(IntrStatus)) {
        AlTtc_Dev_Match3Handler(Ttc);
    }
    if (AL_TTC_INTR_OVERFLOW(IntrStatus)) {
        AlTtc_Dev_OverflowHandler(Ttc);
    }
    if (AL_TTC_INTR_EVENTTIMER(IntrStatus)) {
        AlTtc_Dev_EventTimerHandler(Ttc);
    }
}

/**
 * This function provides a generic interface for performing various control operations on a TTC device,
 * such as setting the interval max value, getting the counter value, enabling wave output, etc.
 * The operation to be performed is specified by the Cmd parameter, and any additional information
 * required for the operation is passed through the IoctlParam union.
 *
 * @param Ttc Pointer to the TTC device structure.
 * @param Cmd The IOCTL command to be performed.
 * @param IoctlParam Pointer to the IOCTL parameter union, which holds the necessary data for the command.
 * @return AL_OK if the operation is successful, error code otherwise.
 */
AL_S32 AlTtc_Dev_IoCtl(AL_TTC_DevStruct *Ttc, AL_TTC_IoCtlCmdEnum Cmd, AL_TTC_IoctlParamUnion *IoctlParam)
{
    AL_S32 Ret = AL_OK;

    AL_ASSERT((Ttc != AL_NULL), AL_TTC_ERR_ILLEGAL_PARAM);

    switch (Cmd)
    {
    case AL_TTC_IOCTL_SetIntervalMaxVal:
        AlTtc_ll_SetIntervalMaxVal(Ttc->BaseAddr, IoctlParam->IntervalMaxVal);
        break;
    case AL_TTC_IOCTL_GetCounterVal:
        IoctlParam->GetCounterVal = AltTtc_ll_GetCounterVal(Ttc->BaseAddr);
        break;
    case AL_TTC_IOCTL_GetEventTimerVal:
        IoctlParam->GetEventTimerVal = AltTtc_ll_GetEventTimerVal(Ttc->BaseAddr);
        break;
    case AL_TTC_IOCTL_EnableWaveOutput:
        AlTtc_ll_EnableWaveOutput(Ttc->BaseAddr, IoctlParam->WaveOutputState);
        break;
    default:
        AL_LOG(AL_LOG_LEVEL_ERROR, "AL_TTC_ERR_IOCTL_CMD");
        break;
    }

    return Ret;
}

/**
 * This function allows the user to register a callback function that will be called when an event occurs
 * on the TTC device. The callback function and a reference pointer are stored in the TTC device structure.
 *
 * @param Ttc Pointer to the TTC device structure.
 * @param Callback The callback function to be registered.
 * @param CallbackRef A user-defined reference pointer to be passed to the callback function.
 * @return AL_OK if the registration is successful.
 */
AL_S32 AlTtc_Dev_RegisterEventCallBack(AL_TTC_DevStruct *Ttc, AL_TTC_EventCallBack Callback, void *CallbackRef)
{
    Ttc->EventCallBack        = Callback;
    Ttc->EventCallBackRef     = CallbackRef;

    return AL_OK;
}

/**
 * This function removes the previously registered callback function from the TTC device structure,
 * effectively disabling event notifications to the user.
 *
 * @param Ttc Pointer to the TTC device structure.
 * @return AL_OK if the unregistration is successful.
 */
AL_S32 AlTtc_Dev_UnRegisterEventCallBack(AL_TTC_DevStruct *Ttc)
{
    Ttc->EventCallBack = (AL_TTC_EventCallBack)AL_NULL;

    return AL_OK;
}







