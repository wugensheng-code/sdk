/*
 * Copyright (c) 2023, Anlogic Inc. and Contributors. All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

/***************************** Include Files *********************************/
#include "al_ttc_dev.h"


/************************** Variable Definitions *****************************/
/* Hardware config generated by TD */
extern AL_TTC_HwConfigStruct AlTtc_HwConfig[AL_TTC_NUM_INSTANCE];

AL_TTC_HwConfigStruct *AlTtc_Dev_LookupConfig(AL_U32 DevId)
{
    AL_U32 Index;
    AL_TTC_HwConfigStruct *ConfigPtr = AL_NULL;

    for (Index = 0; Index < AL_TTC_NUM_INSTANCE; Index++) {
        if (AlTtc_HwConfig[Index].DevId == DevId) {
            ConfigPtr = &AlTtc_HwConfig[Index];
            break;
        }
    }
    return ConfigPtr;
}

/************************** Constant Definitions *****************************/

static AL_TTC_TimerInitStruct TtcDefInitConfigs = {
    .ClkSrc              = AL_TTC_PCLK,
    .PrescaleVal         = 2,
    .CountDec            = AL_TTC_CountUp
};

/************************** Function Prototypes ******************************/

/************************** Function Definitions ******************************/


AL_S32 AlTtc_Dev_Init(AL_TTC_DevStruct *Ttc, AL_U32 DevId, AL_TTC_TimerInitStruct *InitConfig)
{
    AL_TTC_HwConfigStruct *TtcHwConfig;

    AL_ASSERT((Ttc != AL_NULL && DevId < AL_TTC_NUM_INSTANCE), AL_TTC_ERR_ILLEGAL_PARAM);

    TtcHwConfig              = AlTtc_Dev_LookupConfig(DevId);
    Ttc->DevId               = DevId;
    Ttc->BaseAddr            = TtcHwConfig->BaseAddress;
    Ttc->IntrNum             = TtcHwConfig->IntrNum;
    Ttc->InputClockHz        = TtcHwConfig->InputClockHz;
    Ttc->TimerInitConfigs    = (InitConfig == AL_NULL) ? TtcDefInitConfigs : *InitConfig;

    AlTtc_ll_DisbaleCounter(Ttc->BaseAddr);
    AlTtc_ll_EnbalePresacle(Ttc->BaseAddr);
    AlTtc_ll_SetClkSrc(Ttc->BaseAddr, Ttc->TimerInitConfigs.ClkSrc);
    AlTtc_ll_SetPresacleVal(Ttc->BaseAddr, Ttc->TimerInitConfigs.PrescaleVal);
    AlTtc_ll_EnbaleOverflowMode(Ttc->BaseAddr);
    AlTtc_ll_DisableWaveOutput(Ttc->BaseAddr);
    AlTtc_ll_DisableAllIntr(Ttc->BaseAddr);
    AlTtc_ll_DisableEventTimerMode(Ttc->BaseAddr);
    AlTtc_ll_ResetCounter(Ttc->BaseAddr);

    return AL_OK;
}

AL_VOID AlTtc_Dev_EnableOverflowMode(AL_TTC_DevStruct *Ttc)
{
    AlTtc_ll_EnbaleOverflowMode(Ttc->BaseAddr);
}

AL_VOID AlTtc_Dev_EnableIntervalMode(AL_TTC_DevStruct *Ttc)
{
    AlTtc_ll_EnbaleIntervalMode(Ttc->BaseAddr);
}

AL_S32 AlTtc_Dev_SetIntervalMaxVal(AL_TTC_DevStruct *Ttc, AL_U16 Value)
{
    AL_ASSERT((Ttc != AL_NULL), AL_TTC_ERR_ILLEGAL_PARAM);

    AlTtc_ll_SetIntervalMaxVal(Ttc->BaseAddr, Value);

    return AL_OK;
}

AL_U16 AlTtc_Dev_GetCounterVal(AL_TTC_DevStruct *Ttc)
{
    return AltTtc_ll_GetCounterVal(Ttc->BaseAddr);
}

AL_S32 AlTtc_Dev_EnableMatchMode(AL_TTC_DevStruct *Ttc, AL_BOOL State)
{
    AL_ASSERT((Ttc != AL_NULL), AL_TTC_ERR_ILLEGAL_PARAM);

    if (State == AL_TRUE) {
        AlTtc_ll_EnableMatchMode(Ttc->BaseAddr);
    } else {
        AlTtc_ll_DisableMatchMode(Ttc->BaseAddr);
    }

    return AL_OK;
}

AL_S32 AlTtc_Dev_SetMatchVal(AL_TTC_DevStruct *Ttc, AL_TTC_MatchNumEnum MatchNum, AL_U16 Value)
{
    AL_ASSERT((Ttc != AL_NULL), AL_TTC_ERR_ILLEGAL_PARAM);
    AL_ASSERT(MatchNum != AL_TTC_Match1 || MatchNum != AL_TTC_Match2 ||
              MatchNum != AL_TTC_Match3, AL_TTC_ERR_ILLEGAL_PARAM);

    AlTtc_ll_SetMatchVal(Ttc->BaseAddr, Ttc->DevId, MatchNum, Value);

    return AL_OK;
}

AL_S32 AlTtc_Dev_EnableEventTimerMode(AL_TTC_DevStruct *Ttc, AL_BOOL State)
{
    AL_ASSERT((Ttc != AL_NULL), AL_TTC_ERR_ILLEGAL_PARAM);

    if (State == AL_TRUE) {
        AlTtc_ll_EnableEventTimerMode(Ttc->BaseAddr);
    } else {
        AlTtc_ll_DisableEventTimerMode(Ttc->BaseAddr);
    }

    return AL_OK;
}
AL_S32 AlTtc_Dev_SelExtClkEdge(AL_TTC_DevStruct *Ttc, AL_TTC_ClkEdgeEnum ClkEdge)
{
    AL_S32 Ret = AL_OK;
    AL_ASSERT((Ttc != AL_NULL), AL_TTC_ERR_ILLEGAL_PARAM);

    if (Ttc->TimerInitConfigs.ClkSrc == AL_TTC_EXTCLK) {
        AlTtc_ll_SelExtClkEdge(Ttc->BaseAddr, ClkEdge);
    } else {
        AL_LOG(AL_LOG_LEVEL_ERROR, "Set external clk edge need enable external clk");
        return AL_TTC_ERR_NOT_SUPPORT;
    }

    return AL_OK;
}


/*Set the event timer to count the pulse width of high or low levels */
AL_S32 AlTtc_Dev_SetEventTimerLevel(AL_TTC_DevStruct *Ttc, AL_TTC_LevelEnum Level)
{
    AL_ASSERT((Ttc != AL_NULL), AL_TTC_ERR_ILLEGAL_PARAM);

    AlTtc_ll_SetEventTimerLevel(Ttc->BaseAddr, Level);

    return AL_OK;
}

/*wheh event timer is overflow,whether continue counting*/
AL_S32 AlTtc_Dev_EventTimerOv(AL_TTC_DevStruct *Ttc, AL_BOOL State)
{
    AL_ASSERT((Ttc != AL_NULL), AL_TTC_ERR_ILLEGAL_PARAM);

    AlTtc_ll_EventTimerOv(Ttc->BaseAddr, State);

    return AL_OK;
}

AL_U16 AltTtc_Dev_GetEventTimerVal(AL_TTC_DevStruct *Ttc)
{
    return AltTtc_ll_GetEventTimerVal(Ttc->BaseAddr);
}

AL_S32 AlTtc_Dev_SetWaveformPolarity(AL_TTC_DevStruct *Ttc, AL_TTC_ClkEdgeEnum ClkEdge)
{
    AL_ASSERT((Ttc != AL_NULL), AL_TTC_ERR_ILLEGAL_PARAM);
    AL_ASSERT((ClkEdge != AL_TTC_Posedge || ClkEdge != AL_TTC_Negedge), AL_TTC_ERR_ILLEGAL_PARAM);

    AlTtc_ll_SetWaveformPolarity(Ttc->BaseAddr, ClkEdge);

    return AL_OK;
}

AL_S32 AlTtc_Dev_EnableWaveOutput(AL_TTC_DevStruct *Ttc, AL_BOOL State)
{
    AL_ASSERT((Ttc != AL_NULL), AL_TTC_ERR_ILLEGAL_PARAM);

    if (State == AL_TRUE) {
        AlTtc_ll_EnableWaveOutput(Ttc->BaseAddr);
    } else {
        AlTtc_ll_DisableWaveOutput(Ttc->BaseAddr);
    }

    return AL_OK;
}

AL_S32 AlTtc_Dev_EnableCounter(AL_TTC_DevStruct *Ttc, AL_BOOL State)
{
    AL_ASSERT((Ttc != AL_NULL), AL_TTC_ERR_ILLEGAL_PARAM);

    if (State == AL_TRUE) {
        AlTtc_ll_EnbaleCounter(Ttc->BaseAddr);
    } else {
        AlTtc_ll_DisbaleCounter(Ttc->BaseAddr);
    }

    return AL_OK;
}

AL_U32 AlTtc_Dev_EnableIntr(AL_TTC_DevStruct *Ttc, AL_TTC_IntrTypeEnum IntrType)
{
    AL_ASSERT((Ttc != AL_NULL), AL_TTC_ERR_ILLEGAL_PARAM);

    AlTtc_ll_EnableIntr(Ttc->BaseAddr, IntrType);

    return AL_OK;
}

AL_U32 AltTtc_Dev_GetIntrType(AL_TTC_DevStruct *Ttc)
{
    AL_ASSERT((Ttc != AL_NULL), AL_TTC_ERR_ILLEGAL_PARAM);

    return AltTtc_ll_GetIntrtype(Ttc->BaseAddr);
}

static AL_VOID AlTtc_Dev_IntervalHandler(AL_TTC_DevStruct *Ttc)
{
    AL_TTC_EventStruct TtcEvent = {
        .Events = AL_TTC_EVENT_Interval
    };
    if (Ttc->EventCallBack) {
        (*Ttc->EventCallBack)(TtcEvent, Ttc->EventCallBackRef);
    }
}

static AL_VOID AlTtc_Dev_Match1Handler(AL_TTC_DevStruct *Ttc)
{
    AL_TTC_EventStruct TtcEvent = {
        .Events = AL_TTC_EVENT_Match1
    };
    if (Ttc->EventCallBack) {
        (*Ttc->EventCallBack)(TtcEvent, Ttc->EventCallBackRef);
    }
}

static AL_VOID AlTtc_Dev_Match2Handler(AL_TTC_DevStruct *Ttc)
{
    AL_TTC_EventStruct TtcEvent = {
        .Events = AL_TTC_EVENT_Match2
    };
    if (Ttc->EventCallBack) {
        (*Ttc->EventCallBack)(TtcEvent, Ttc->EventCallBackRef);
    }
}

static AL_VOID AlTtc_Dev_Match3Handler(AL_TTC_DevStruct *Ttc)
{
    AL_TTC_EventStruct TtcEvent = {
        .Events = AL_TTC_EVENT_Match3
    };
    if (Ttc->EventCallBack) {
        (*Ttc->EventCallBack)(TtcEvent, Ttc->EventCallBackRef);
    }
}

static AL_VOID AlTtc_Dev_OverflowHandler(AL_TTC_DevStruct *Ttc)
{
    AL_TTC_EventStruct TtcEvent = {
        .Events = AL_TTC_EVENT_Overflow
    };
    if (Ttc->EventCallBack) {
        (*Ttc->EventCallBack)(TtcEvent, Ttc->EventCallBackRef);
    }
}

static AL_VOID AlTtc_Dev_EventTimerHandler(AL_TTC_DevStruct *Ttc)
{
    AL_TTC_EventStruct TtcEvent = {
        .Events = AL_TTC_EVENT_EventTimer,
        .EventData = 0
    };

    TtcEvent.EventData = AltTtc_ll_GetEventTimerVal(Ttc->BaseAddr);

    if (Ttc->EventCallBack) {
        (*Ttc->EventCallBack)(TtcEvent, Ttc->EventCallBackRef);
    }
}


#define AL_TTC_INTR_INTERVAL(Status)           (Status & (BIT(AL_TTC_IntrInterval)))
#define AL_TTC_INTR_MATCH1(Status)             (Status & (BIT(AL_TTC_IntrMatch1)))
#define AL_TTC_INTR_MATCH2(Status)             (Status & (BIT(AL_TTC_IntrMatch2)))
#define AL_TTC_INTR_MATCH3(Status)             (Status & (BIT(AL_TTC_IntrMatch3)))
#define AL_TTC_INTR_OVERFLOW(Status)           (Status & (BIT(AL_TTC_IntrOverflow)))
#define AL_TTC_INTR_EVENTTIMER(Status)         (Status & (BIT(AL_TTC_IntrEventTimer)))


AL_VOID AlTtc_Dev_IntrHandler(AL_VOID *Instance)
{
    AL_TTC_DevStruct *Ttc = (AL_TTC_DevStruct *)Instance;
    AL_U32 IntrStatus = AltTtc_ll_GetIntrtype(Ttc->BaseAddr);

    if (AL_TTC_INTR_INTERVAL(IntrStatus)) {
        AlTtc_Dev_IntervalHandler(Ttc);
    }
    if (AL_TTC_INTR_MATCH1(IntrStatus)) {
        AlTtc_Dev_Match1Handler(Ttc);
    }
    if (AL_TTC_INTR_MATCH2(IntrStatus)) {
        AlTtc_Dev_Match2Handler(Ttc);
    }
    if (AL_TTC_INTR_MATCH3(IntrStatus)) {
        AlTtc_Dev_Match3Handler(Ttc);
    }
    if (AL_TTC_INTR_OVERFLOW(IntrStatus)) {
        AlTtc_Dev_OverflowHandler(Ttc);
    }
    if (AL_TTC_INTR_EVENTTIMER(IntrStatus)) {
        AlTtc_Dev_EventTimerHandler(Ttc);
    }
}

AL_S32 AlTtc_Dev_IoCtl(AL_TTC_DevStruct *Ttc, AL_TTC_IoCtlCmdEnum Cmd, AL_TTC_IoctlParamUnion *IoctlParam)
{
    AL_S32 Ret = AL_OK;

    AL_ASSERT((Ttc != AL_NULL), AL_TTC_ERR_ILLEGAL_PARAM);

    switch (Cmd)
    {
    case AL_TTC_IOCTL_SetIntervalMaxVal:
        AlTtc_ll_SetIntervalMaxVal(Ttc->BaseAddr, IoctlParam->IntervalMaxVal);
        break;
    case AL_TTC_IOCTL_GetCounterVal:
        IoctlParam->GetCounterVal = AltTtc_ll_GetCounterVal(Ttc->BaseAddr);
    case AL_TTC_IOCTL_GetEventTimerVal:
        IoctlParam->GetEventTimerVal = AltTtc_ll_GetEventTimerVal(Ttc->BaseAddr);
    case AL_TTC_IOCTL_EnableWaveOutput:
        if (IoctlParam->WaveOutputState == AL_TRUE) {
            AlTtc_ll_EnableWaveOutput(Ttc->BaseAddr);
        } else {
            AlTtc_ll_DisableWaveOutput(Ttc->BaseAddr);
        }
    default:
        AL_LOG(AL_LOG_LEVEL_ERROR, "AL_TTC_ERR_IOCTL_CMD");
        break;
    }

    return Ret;
}

AL_S32 AlTtc_Dev_RegisterEventCallBack(AL_TTC_DevStruct *Ttc, AL_TTC_EventCallBack Callback, void *CallbackRef)
{
    Ttc->EventCallBack        = Callback;
    Ttc->EventCallBackRef     = CallbackRef;

    return AL_OK;
}

AL_S32 AlTtc_Dev_UnRegisterEventCallBack(AL_TTC_DevStruct *Ttc)
{
    Ttc->EventCallBack = (AL_TTC_EventCallBack)AL_NULL;

    return AL_OK;
}







