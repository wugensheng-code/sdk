/*
 * Copyright (c) 2023, Anlogic Inc. and Contributors. All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

/***************************** Include Files *********************************/
#include "al_ttc_dev.h"


/************************** Variable Definitions *****************************/
/* Hardware config generated by TD */
extern AL_TTC_HwConfigStruct AlTtc_HwConfig[AL_TTC_NUM_INSTANCE];

AL_TTC_HwConfigStruct *AlTtc_Dev_LookupConfig(AL_U32 DevId)
{
    AL_U32 Index;
    AL_TTC_HwConfigStruct *ConfigPtr = AL_NULL;

    for (Index = 0; Index < AL_TTC_NUM_INSTANCE; Index++) {
        if (AlTtc_HwConfig[Index].DevId == DevId) {
            ConfigPtr = &AlTtc_HwConfig[Index];
            break;
        }
    }
    return ConfigPtr;
}

/************************** Constant Definitions *****************************/

static AL_TTC_TimerInitStruct TtcDefInitConfigs = {
    .CountDec            = AL_TTC_CountUp,
    .ClkSrc              = AL_TTC_PCLK,
    .EnablePrescale      = AL_TRUE,
    .PrescaleVal         = 2,
};

/************************** Function Prototypes ******************************/

/************************** Function Definitions ******************************/

/**
 * This function init TTC module.
 * @param   Ttc is pointer to AL_TTC_DevStruct
 * @param   DevId is hardware module id
 * @param   InitConfig is module config structure with AL_TTC_TimerInitStruct
 * @return
 *          - AL_OK is init done
 * @note
*/
AL_S32 AlTtc_Dev_Init(AL_TTC_DevStruct *Ttc, AL_U32 DevId, AL_TTC_TimerInitStruct *InitConfig)
{
    AL_TTC_HwConfigStruct *TtcHwConfig;

    AL_ASSERT((Ttc != AL_NULL && DevId < AL_TTC_NUM_INSTANCE), AL_TTC_ERR_ILLEGAL_PARAM);

    TtcHwConfig              = AlTtc_Dev_LookupConfig(DevId);
    Ttc->DevId               = DevId;
    Ttc->BaseAddr            = TtcHwConfig->BaseAddress;
    Ttc->IntrNum             = TtcHwConfig->IntrNum;
    Ttc->InputClockHz        = TtcHwConfig->InputClockHz;
    Ttc->TimerInitConfigs    = (InitConfig == AL_NULL) ? TtcDefInitConfigs : *InitConfig;

    AlTtc_ll_ResetCounter(Ttc->BaseAddr);
    AlTtc_ll_EnbaleOverflowMode(Ttc->BaseAddr);
    AlTtc_ll_SetClkSrc(Ttc->BaseAddr, Ttc->TimerInitConfigs.ClkSrc);
    AlTtc_ll_EnbaleCounter(Ttc->BaseAddr, AL_FALSE);
    AlTtc_ll_DisableAllIntr(Ttc->BaseAddr);
    AlTtc_ll_EnableWaveOutput(Ttc->BaseAddr, AL_FALSE);
    AlTtc_ll_EnableEventTimerMode(Ttc->BaseAddr, AL_FALSE);
    AlTtc_ll_EnbalePresacle(Ttc->BaseAddr, Ttc->TimerInitConfigs.EnablePrescale);
    AlTtc_ll_SetPresacleVal(Ttc->BaseAddr, Ttc->TimerInitConfigs.PrescaleVal);
    AlTtc_ll_SetCountDec(Ttc->BaseAddr, Ttc->TimerInitConfigs.CountDec);
    AltTtc_ll_GetIntrtype(Ttc->BaseAddr);

    return AL_OK;
}

/**
 * This function is interval interrupt handler.
 * @param   Ttc is pointer to AL_TTC_DevStruct
 * @return
 * @note
*/
static AL_VOID AlTtc_Dev_IntervalHandler(AL_TTC_DevStruct *Ttc)
{
    AL_TTC_EventStruct TtcEvent = {
        .Events = AL_TTC_EVENT_Interval
    };
    if (Ttc->EventCallBack) {
        (*Ttc->EventCallBack)(TtcEvent, Ttc->EventCallBackRef);
    }
}

/**
 * This function is match1 interrupt handler.
 * @param   Ttc is pointer to AL_TTC_DevStruct
 * @return
 * @note
*/
static AL_VOID AlTtc_Dev_Match1Handler(AL_TTC_DevStruct *Ttc)
{
    AL_TTC_EventStruct TtcEvent = {
        .Events = AL_TTC_EVENT_Match1
    };
    if (Ttc->EventCallBack) {
        (*Ttc->EventCallBack)(TtcEvent, Ttc->EventCallBackRef);
    }
}

/**
 * This function is match2 interrupt handler.
 * @param   Ttc is pointer to AL_TTC_DevStruct
 * @return
 * @note
*/
static AL_VOID AlTtc_Dev_Match2Handler(AL_TTC_DevStruct *Ttc)
{
    AL_TTC_EventStruct TtcEvent = {
        .Events = AL_TTC_EVENT_Match2
    };
    if (Ttc->EventCallBack) {
        (*Ttc->EventCallBack)(TtcEvent, Ttc->EventCallBackRef);
    }
}

/**
 * This function is match3 interrupt handler.
 * @param   Ttc is pointer to AL_TTC_DevStruct
 * @return
 * @note
*/
static AL_VOID AlTtc_Dev_Match3Handler(AL_TTC_DevStruct *Ttc)
{
    AL_TTC_EventStruct TtcEvent = {
        .Events = AL_TTC_EVENT_Match3
    };
    if (Ttc->EventCallBack) {
        (*Ttc->EventCallBack)(TtcEvent, Ttc->EventCallBackRef);
    }
}

/**
 * This function is overflow interrupt handler.
 * @param   Ttc is pointer to AL_TTC_DevStruct
 * @return
 * @note
*/
static AL_VOID AlTtc_Dev_OverflowHandler(AL_TTC_DevStruct *Ttc)
{
    AL_TTC_EventStruct TtcEvent = {
        .Events = AL_TTC_EVENT_Overflow
    };
    if (Ttc->EventCallBack) {
        (*Ttc->EventCallBack)(TtcEvent, Ttc->EventCallBackRef);
    }
}

/**
 * This function is eventtimer interrupt handler.
 * @param   Ttc is pointer to AL_TTC_DevStruct
 * @return
 * @note
*/
static AL_VOID AlTtc_Dev_EventTimerHandler(AL_TTC_DevStruct *Ttc)
{
    AL_TTC_EventStruct TtcEvent = {
        .Events = AL_TTC_EVENT_EventTimer,
        .EventData = 0
    };

    TtcEvent.EventData = AltTtc_ll_GetEventTimerVal(Ttc->BaseAddr);

    if (Ttc->EventCallBack) {
        (*Ttc->EventCallBack)(TtcEvent, Ttc->EventCallBackRef);
    }
}


#define AL_TTC_INTR_INTERVAL(Status)           (Status & (BIT(AL_TTC_IntrInterval)))
#define AL_TTC_INTR_MATCH1(Status)             (Status & (BIT(AL_TTC_IntrMatch1)))
#define AL_TTC_INTR_MATCH2(Status)             (Status & (BIT(AL_TTC_IntrMatch2)))
#define AL_TTC_INTR_MATCH3(Status)             (Status & (BIT(AL_TTC_IntrMatch3)))
#define AL_TTC_INTR_OVERFLOW(Status)           (Status & (BIT(AL_TTC_IntrOverflow)))
#define AL_TTC_INTR_EVENTTIMER(Status)         (Status & (BIT(AL_TTC_IntrEventTimer)))

/**
 * This function is ttc's all interrupt entries handler.
 * @param   Instance is pointer to interrupts call back reference
 * @return
 * @note
*/
AL_VOID AlTtc_Dev_IntrHandler(AL_VOID *Instance)
{
    AL_TTC_DevStruct *Ttc = (AL_TTC_DevStruct *)Instance;
    AL_U32 IntrStatus = AltTtc_ll_GetIntrtype(Ttc->BaseAddr);

    if (AL_TTC_INTR_INTERVAL(IntrStatus)) {
        AlTtc_Dev_IntervalHandler(Ttc);
    }
    if (AL_TTC_INTR_MATCH1(IntrStatus)) {
        AlTtc_Dev_Match1Handler(Ttc);
    }
    if (AL_TTC_INTR_MATCH2(IntrStatus)) {
        AlTtc_Dev_Match2Handler(Ttc);
    }
    if (AL_TTC_INTR_MATCH3(IntrStatus)) {
        AlTtc_Dev_Match3Handler(Ttc);
    }
    if (AL_TTC_INTR_OVERFLOW(IntrStatus)) {
        AlTtc_Dev_OverflowHandler(Ttc);
    }
    if (AL_TTC_INTR_EVENTTIMER(IntrStatus)) {
        AlTtc_Dev_EventTimerHandler(Ttc);
    }
}

/**
 * This function excute operations to set or get ttc status.
 * @param   Ttc Pointer to a AL_TTC_DevStruct structure that contains ttc device instance
 * @param   Cmd is io ctl operation to AL_TTC_IoCtlCmdEnum
 * @param   IoctlParam is pointer reference to Cmd
 * @return
 *          - AL_OK for function success
 *          - Other for function failure
 * @note
*/
AL_S32 AlTtc_Dev_IoCtl(AL_TTC_DevStruct *Ttc, AL_TTC_IoCtlCmdEnum Cmd, AL_TTC_IoctlParamUnion *IoctlParam)
{
    AL_S32 Ret = AL_OK;

    AL_ASSERT((Ttc != AL_NULL), AL_TTC_ERR_ILLEGAL_PARAM);

    switch (Cmd)
    {
    case AL_TTC_IOCTL_SetIntervalMaxVal:
        AlTtc_ll_SetIntervalMaxVal(Ttc->BaseAddr, IoctlParam->IntervalMaxVal);
        break;
    case AL_TTC_IOCTL_GetCounterVal:
        IoctlParam->GetCounterVal = AltTtc_ll_GetCounterVal(Ttc->BaseAddr);
        break;
    case AL_TTC_IOCTL_GetEventTimerVal:
        IoctlParam->GetEventTimerVal = AltTtc_ll_GetEventTimerVal(Ttc->BaseAddr);
        break;
    case AL_TTC_IOCTL_EnableWaveOutput:
        AlTtc_ll_EnableWaveOutput(Ttc->BaseAddr, IoctlParam->WaveOutputState);
        break;
    default:
        AL_LOG(AL_LOG_LEVEL_ERROR, "AL_TTC_ERR_IOCTL_CMD");
        break;
    }

    return Ret;
}

/**
 * This function register a User Ttc Callback To be used when send or receive done.
 * @param   Ttc Pointer to a AL_TTC_DevStruct structure that contains ttc device instance
 * @param   CallBack pointer to the Callback function
 * @param   CallbackRef pointer to the Callback function params
 * @return
 *          - AL_OK for function success
 *          - Other for function failure
 * @note
*/
AL_S32 AlTtc_Dev_RegisterEventCallBack(AL_TTC_DevStruct *Ttc, AL_TTC_EventCallBack Callback, void *CallbackRef)
{
    Ttc->EventCallBack        = Callback;
    Ttc->EventCallBackRef     = CallbackRef;

    return AL_OK;
}

/**
 * This function unregister a User Ttc Callback To be used when send or receive done.
 * @param   Ttc Pointer to a AL_TTC_DevStruct structure that contains ttc device instance
 * @return
 *          - AL_OK for function success
 *          - Other for function failure
 * @note
*/
AL_S32 AlTtc_Dev_UnRegisterEventCallBack(AL_TTC_DevStruct *Ttc)
{
    Ttc->EventCallBack = (AL_TTC_EventCallBack)AL_NULL;

    return AL_OK;
}







