/***************************** Include Files *********************************/
#include "al_dmacahb_dev.h"
#include "al_errno.h"
#include <string.h>

/************************** Constant Definitions *****************************/
/* Channel register offset and mask */
static AL_DMACAHB_ChParamStruct AlDmacAhb_ChParam[AL_DMACAHB_CHANNEL_NUM] = {
    {.ChBaseOffset = (0x000), .ChMask = (0x1 << 0)},
    {.ChBaseOffset = (0x058), .ChMask = (0x1 << 1)},
    {.ChBaseOffset = (0x0B0), .ChMask = (0x1 << 2)},
    {.ChBaseOffset = (0x108), .ChMask = (0x1 << 3)},
    {.ChBaseOffset = (0x160), .ChMask = (0x1 << 4)},
    {.ChBaseOffset = (0x1B8), .ChMask = (0x1 << 5)},
    {.ChBaseOffset = (0x210), .ChMask = (0x1 << 6)},
    {.ChBaseOffset = (0x268), .ChMask = (0x1 << 7)},
};

/* Default init config */
static AL_DMACAHB_ChInitStruct AlDmacAhb_ChDefInitConfig = {
    .Id                     = AL_DMACAHB_CHANNEL_0,
    .TransType              = AL_DMACAHB_TRANS_TYPE_1,
    .Intr.IsIntrEn          = AL_TRUE,
    .Intr.IntrUnMask        = AL_DMACAHB_CH_INTR_TFR | AL_DMACAHB_CH_INTR_BLOCK | AL_DMACAHB_CH_INTR_SRCT | \
                              AL_DMACAHB_CH_INTR_DSTT | AL_DMACAHB_CH_INTR_ERR,
    .SrcTransWidth          = AL_DMACAHB_TRANS_WIDTH_32,
    .DstTransWidth          = AL_DMACAHB_TRANS_WIDTH_32,
    .SrcAddrIncMode         = AL_DMACAHB_ADDR_INC_INC,
    .DstAddrIncMode         = AL_DMACAHB_ADDR_INC_INC,
    .SrcBurstLength         = AL_DMACAHB_MSIZE_1,
    .DstBurstLength         = AL_DMACAHB_MSIZE_1,
    .Direction              = AL_DMACAHB_TT_FC_MEM2MEM,
    .SrcMasterSel           = AL_DMACAHB_MASTER_SEL_1,
    .DstMasterSel           = AL_DMACAHB_MASTER_SEL_1,
    .ListMasterSel          = AL_DMACAHB_MASTER_SEL_1,
    .ChPrior                = AL_DMACAHB_CH_PRIOR_7,
    .FifoMode               = AL_DMACAHB_FIFO_MODE_0,
    .ProtCtl                = AL_DMACAHB_PROT_0,
    .SgrDsr.IsSrcGatherEn   = AL_FALSE,
    .SgrDsr.IsDstScatterEn  = AL_FALSE,
};

/**************************** Type Definitions *******************************/
/* TODO: LLI state */
/***************** Macros (Inline Functions) Definitions *********************/
/*Intr state check*/
#define AL_DMACAHB_TFR_INTR(Status)     (Status & AL_DMACAHB_CH_INTR_TFR)
#define AL_DMACAHB_BLOCK_INTR(Status)   (Status & AL_DMACAHB_CH_INTR_BLOCK)
#define AL_DMACAHB_SRCT_INTR(Status)    (Status & AL_DMACAHB_CH_INTR_SRCT)
#define AL_DMACAHB_DSTT_INTR(Status)    (Status & AL_DMACAHB_CH_INTR_DSTT)
#define AL_DMACAHB_ERR_INTR(Status)     (Status & AL_DMACAHB_CH_INTR_ERR)

#define AL_DMACAHB_LOOP_REG_DELAY   do {AlDelay_Us(1);} while (0)

/************************** Variable Definitions *****************************/
/* Hardware config generated by TD */
extern AL_DMACAHB_HwConfigStruct AlDmacAhb_HwConfig[];

/* Static dmac instance */
static AL_DMACAHB_DmacStruct AlDmacAhb_DmacInstance[AL_DMACAHB_NUM_INSTANCE];

/************************** Function Prototypes ******************************/
AL_BOOL AlDmacAhb_Dev_GetState(AL_DMACAHB_ChStruct *Channel, AL_DMACAHB_ChStateEnum State);

AL_VOID AlDmacAhb_Dev_SetState(AL_DMACAHB_ChStruct *Channel, AL_DMACAHB_ChStateEnum State);

AL_VOID AlDmacAhb_Dev_ClrState(AL_DMACAHB_ChStruct *Channel, AL_DMACAHB_ChStateEnum State);

/************************** Function Definitions ******************************/
/**
 * This function look up hardware config structure
 * @param   DeviceId is hardware module id
 * @return  hardware config structure with AL_DMACAHB_HwConfigStruct
 * @note
*/
AL_DMACAHB_HwConfigStruct *AlDmacAhb_Dev_LookupConfig(AL_U32 DeviceId)
{
    AL_U32 Index;
    AL_DMACAHB_HwConfigStruct *CfgPtr = AL_NULL;

    for (Index = 0; Index < AL_DMACAHB_NUM_INSTANCE; Index++) {
        if (AlDmacAhb_HwConfig[Index].DeviceId == DeviceId) {
            CfgPtr = &AlDmacAhb_HwConfig[Index];
            break;
        }
    }

    return CfgPtr;
}

/**
 * This function clear all intr of specified channel
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @return
 * @note
*/
AL_VOID AlDmacAhb_Dev_ClrChAllIntr(AL_DMACAHB_ChStruct *Channel)
{
    AL_U32 ChMask = Channel->Param.ChMask;
    AL_REG BaseAddr = Channel->Dmac->BaseAddr;
    AlDmacAhb_ll_WriteClearTfr(BaseAddr, ChMask);
    AlDmacAhb_ll_WriteClearBlock(BaseAddr, ChMask);
    AlDmacAhb_ll_WriteClearBlock(BaseAddr, ChMask);
    AlDmacAhb_ll_WriteClearDstTran(BaseAddr, ChMask);
    AlDmacAhb_ll_WriteClearErr(BaseAddr, ChMask);
}

/**
 * This function unmask intr of specified channel
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @return
 * @note
*/
AL_VOID AlDmacAhb_Dev_UnmaskChIntr(AL_DMACAHB_ChStruct *Channel)
{
    AL_U32 ChMask = Channel->Param.ChMask;
    AL_REG BaseAddr = Channel->Dmac->BaseAddr;

    if (Channel->Config.Intr.IntrUnMask & AL_DMACAHB_CH_INTR_TFR) {
        AlDmacAhb_ll_SetMaskTfr(BaseAddr, ChMask);
    }
    if (Channel->Config.Intr.IntrUnMask & AL_DMACAHB_CH_INTR_BLOCK) {
        AlDmacAhb_ll_SetMaskBlock(BaseAddr, ChMask);
    }
    if (Channel->Config.Intr.IntrUnMask & AL_DMACAHB_CH_INTR_SRCT) {
        AlDmacAhb_ll_SetMaskSrcTran(BaseAddr, ChMask);
    }
    if (Channel->Config.Intr.IntrUnMask & AL_DMACAHB_CH_INTR_DSTT) {
        AlDmacAhb_ll_SetMaskDstTran(BaseAddr, ChMask);
    }
    if (Channel->Config.Intr.IntrUnMask & AL_DMACAHB_CH_INTR_ERR) {
        AlDmacAhb_ll_SetMaskErr(BaseAddr, ChMask);
    }
}

/**
 * This function set trans type of specified channel
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @return
 *          - AL_OK
 * @note
*/
AL_S32 AlDmacAhb_Dev_SetTransType(AL_DMACAHB_ChStruct *Channel)
{
    AL_BOOL LlpSrcEn, LlpDstEn;
    AL_BOOL SrcAutoEn, DstAutoEn;
    AL_U32 ChOffset = Channel->Param.ChBaseOffset;
    AL_REG BaseAddr = Channel->Dmac->BaseAddr;

    switch (Channel->Config.TransType)
    {
    case AL_DMACAHB_TRANS_TYPE_1:
        AlDmacAhb_ll_SetLinkStartAddr(BaseAddr, ChOffset, 0);
        LlpSrcEn    = AL_FALSE;
        LlpDstEn    = AL_FALSE;
        SrcAutoEn   = AL_FALSE;
        DstAutoEn   = AL_FALSE;
        break;
    case AL_DMACAHB_TRANS_TYPE_2:
        AlDmacAhb_ll_SetLinkStartAddr(BaseAddr, ChOffset, 0);
        LlpSrcEn    = AL_FALSE;
        LlpDstEn    = AL_FALSE;
        SrcAutoEn   = AL_FALSE;
        DstAutoEn   = AL_TRUE;
        break;
    case AL_DMACAHB_TRANS_TYPE_3:
        AlDmacAhb_ll_SetLinkStartAddr(BaseAddr, ChOffset, 0);
        LlpSrcEn    = AL_FALSE;
        LlpDstEn    = AL_FALSE;
        SrcAutoEn   = AL_TRUE;
        DstAutoEn   = AL_FALSE;
        break;
    case AL_DMACAHB_TRANS_TYPE_4:
        AlDmacAhb_ll_SetLinkStartAddr(BaseAddr, ChOffset, 0);
        LlpSrcEn    = AL_FALSE;
        LlpDstEn    = AL_FALSE;
        SrcAutoEn   = AL_TRUE;
        DstAutoEn   = AL_TRUE;
        break;
    case AL_DMACAHB_TRANS_TYPE_5:
        LlpSrcEn    = AL_FALSE;
        LlpDstEn    = AL_FALSE;
        SrcAutoEn   = AL_FALSE;
        DstAutoEn   = AL_FALSE;
        break;
    case AL_DMACAHB_TRANS_TYPE_6:
        LlpSrcEn    = AL_FALSE;
        LlpDstEn    = AL_TRUE;
        SrcAutoEn   = AL_FALSE;
        DstAutoEn   = AL_FALSE;
        break;
    case AL_DMACAHB_TRANS_TYPE_7:
        LlpSrcEn    = AL_FALSE;
        LlpDstEn    = AL_TRUE;
        SrcAutoEn   = AL_TRUE;
        DstAutoEn   = AL_FALSE;
        break;
    case AL_DMACAHB_TRANS_TYPE_8:
        LlpSrcEn    = AL_TRUE;
        LlpDstEn    = AL_FALSE;
        SrcAutoEn   = AL_FALSE;
        DstAutoEn   = AL_FALSE;
        break;
    case AL_DMACAHB_TRANS_TYPE_9:
        LlpSrcEn    = AL_TRUE;
        LlpDstEn    = AL_FALSE;
        SrcAutoEn   = AL_FALSE;
        DstAutoEn   = AL_TRUE;
        break;
    case AL_DMACAHB_TRANS_TYPE_10:
        LlpSrcEn    = AL_TRUE;
        LlpDstEn    = AL_TRUE;
        SrcAutoEn   = AL_FALSE;
        DstAutoEn   = AL_FALSE;
        break;
    default:
        return AL_DMACAHB_ERR_ILLEGAL_PARAM;
        break;
    }

    AlDmacAhb_ll_SetLlpSrcEn(BaseAddr, ChOffset, LlpSrcEn);
    AlDmacAhb_ll_SetLlpDstEn(BaseAddr, ChOffset, LlpDstEn);
    AlDmacAhb_ll_SetSrcAutoReload(BaseAddr, ChOffset, SrcAutoEn);
    AlDmacAhb_ll_SetDstAutoReload(BaseAddr, ChOffset, DstAutoEn);


    return AL_OK;
}

/**
 * This function set CTL low register of specified channel
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @note
*/
AL_VOID AlDmacAhb_Dev_SetCtlLoReg(AL_DMACAHB_ChStruct *Channel)
{
    AL_U32 ChOffset = Channel->Param.ChBaseOffset;
    AL_REG BaseAddr = Channel->Dmac->BaseAddr;
    volatile AL_DMACAHB_CtlLoUnion CtlLo;

    CtlLo.Reg = AlDmacAhb_ll_ReadCtlLo(BaseAddr, ChOffset);
    CtlLo.Bit.IntEn         = Channel->Config.Intr.IsIntrEn;
    CtlLo.Bit.DstTransWidth = Channel->Config.DstTransWidth;
    CtlLo.Bit.SrcTransWidth = Channel->Config.SrcTransWidth;
    CtlLo.Bit.DstInc        = Channel->Config.DstAddrIncMode;
    CtlLo.Bit.SrcInc        = Channel->Config.SrcAddrIncMode;
    CtlLo.Bit.DstMsize      = Channel->Config.DstBurstLength;
    CtlLo.Bit.SrcMsize      = Channel->Config.SrcBurstLength;
    CtlLo.Bit.SrcGattterEn  = Channel->Config.SgrDsr.IsSrcGatherEn;
    CtlLo.Bit.DstScatterEn  = Channel->Config.SgrDsr.IsDstScatterEn;
    CtlLo.Bit.TtFc          = Channel->Config.Direction;
    CtlLo.Bit.DstMasterSel  = Channel->Config.DstMasterSel;
    CtlLo.Bit.SrcMasterSel  = Channel->Config.SrcMasterSel;
    AlDmacAhb_ll_WriteCtlLo(BaseAddr, ChOffset, CtlLo.Reg);
}

/**
 * This function set CFG low register of specified channel
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @note
*/
AL_VOID AlDmacAhb_Dev_SetCfgLoReg(AL_DMACAHB_ChStruct *Channel)
{
    AL_U32 ChOffset = Channel->Param.ChBaseOffset;
    AL_REG BaseAddr = Channel->Dmac->BaseAddr;
    volatile AL_DMACAHB_CfgLoUnion CfgLo;

    CfgLo.Reg = AlDmacAhb_ll_ReadCfgLo(BaseAddr, ChOffset);
    CfgLo.Bit.ChPrior   = Channel->Config.ChPrior;
    CfgLo.Bit.DstHsSel  = Channel->Config.HandShaking.DstHsSel;
    CfgLo.Bit.SrcHsSel  = Channel->Config.HandShaking.SrcHsSel;
    CfgLo.Bit.DstHsPol  = Channel->Config.HandShaking.DstHsPol;
    CfgLo.Bit.SrcHsPol  = Channel->Config.HandShaking.SrcHsPol;
    AlDmacAhb_ll_WriteCfgLo(BaseAddr, ChOffset, CfgLo.Reg);
}

/**
 * This function set CFG high register of specified channel
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @note
*/
AL_VOID AlDmacAhb_Dev_SetCfgHiReg(AL_DMACAHB_ChStruct *Channel)
{
    AL_U32 ChOffset = Channel->Param.ChBaseOffset;
    AL_REG BaseAddr = Channel->Dmac->BaseAddr;
    volatile AL_DMACAHB_CfgHiUnion CfgHi;

    CfgHi.Reg = AlDmacAhb_ll_ReadCfgHi(BaseAddr, ChOffset);
    CfgHi.Bit.FifoMode  = Channel->Config.FifoMode;
    CfgHi.Bit.ProtCtl   = Channel->Config.ProtCtl;
    if (Channel->Config.HandShaking.SrcHsSel == AL_DMACAHB_HAND_SHAKING_HARDWARE) {
        CfgHi.Bit.SrcPer = Channel->Config.HandShaking.SrcPer;
    }
    if (Channel->Config.HandShaking.DstHsSel == AL_DMACAHB_HAND_SHAKING_HARDWARE) {
        CfgHi.Bit.DstPer = Channel->Config.HandShaking.DstPer;
    }
    AlDmacAhb_ll_WriteCfgHi(BaseAddr, ChOffset, CfgHi.Reg);
}

/**
 * This function set src gather and dst scatter of specified channel
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @note
*/
AL_VOID AlDmacAhb_Dev_SetSgrDsr(AL_DMACAHB_ChStruct *Channel)
{
    AL_U32 ChOffset = Channel->Param.ChBaseOffset;
    AL_REG BaseAddr = Channel->Dmac->BaseAddr;

    if (Channel->Config.SgrDsr.IsSrcGatherEn == AL_TRUE) {
        AlDmacAhb_ll_SetSgi(BaseAddr, ChOffset, Channel->Config.SgrDsr.SrcGatherInterval);
        AlDmacAhb_ll_SetSgc(BaseAddr, ChOffset, Channel->Config.SgrDsr.SrcGatherCount);
    }
    if (Channel->Config.SgrDsr.IsDstScatterEn == AL_TRUE) {
        AlDmacAhb_ll_SetDsi(BaseAddr, ChOffset, Channel->Config.SgrDsr.DstScatterInterval);
        AlDmacAhb_ll_SetDsc(BaseAddr, ChOffset, Channel->Config.SgrDsr.DstScatterCount);
    }
}

/**
 * This function fill Lli struct with ctl register to specified channel
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @param   c
 * @note
*/
AL_VOID AlDmacAhb_Dev_FillLliWithCtl(AL_DMACAHB_ChStruct *Channel, AL_DMACAHB_LliStruct *Lli)
{
    AL_U32 ChOffset = Channel->Param.ChBaseOffset;
    AL_REG BaseAddr = Channel->Dmac->BaseAddr;

    Lli->CtlLow.Reg = AlDmacAhb_ll_ReadCtlLo(BaseAddr, ChOffset);
    Lli->CtlHigh.Reg = AlDmacAhb_ll_ReadCtlHi(BaseAddr, ChOffset);
}

/**
 * This function set channel trans params
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @param   TransParams is pointer to AL_DMACAHB_ChTransUnion
 * @return
 *          - AL_DMACAHB_ERR_NULL_PTR Channel is NULL
 *          - AL_DMACAHB_ERR_ADDR_NOT_ALIGN src or dst address not align with their trans width
 *          - AL_DMACAHB_ERR_STATE_NOT_READY channel not ready
 *          - AL_OK start success
 * @note
*/
AL_S32 AlDmacAhb_Dev_SetTransParams(AL_DMACAHB_ChStruct *Channel)
{
    if (Channel == AL_NULL) {
        return AL_DMACAHB_ERR_NULL_PTR;
    }

    AL_S32 Ret = AL_OK;
    AL_U32 ChOffset = Channel->Param.ChBaseOffset;
    AL_U32 ChMask   = Channel->Param.ChMask;
    AL_REG BaseAddr = Channel->Dmac->BaseAddr;
    AL_DMACAHB_ChTransStruct *Trans = &Channel->Trans;
    AL_DMACAHB_ChStateEnum State;

    Ret = AlDmacAhb_Dev_TransTypeToState(Channel->Config.TransType, &State);
    if (Ret != AL_OK) {
        return Ret;
    }

    if (State == AL_DMACAHB_STATE_LLP_MODE_BUSY || State == AL_DMACAHB_STATE_LLP_RELOAD_MODE_BUSY) {
        if (Trans->Lli == AL_NULL) {
            return AL_DMACAHB_ERR_NULL_PTR;
        } else if (((AL_U32)(AL_UINTPTR)Trans->Lli) & 0x3){
            return AL_DMACAHB_ERR_ADDR_NOT_ALIGN;
        }
    } else {
        if ((Trans->SrcAddr & ((1 << (Channel->Config.SrcTransWidth + 1)) - 1)) ||
            (Trans->DstAddr & ((1 << (Channel->Config.DstTransWidth + 1)) - 1))) {
            return AL_DMACAHB_ERR_ADDR_NOT_ALIGN;
        }
    }

    if (!AlDmacAhb_Dev_GetState(Channel, AL_DMACAHB_STATE_READY)) {
        return AL_DMACAHB_ERR_STATE_NOT_READY;
    }

    if (AlDmacAhb_Dev_GetState(Channel, (AL_DMACAHB_STATE_SINGLE_MODE_BUSY | AL_DMACAHB_STATE_RELOAD_MODE_BUSY |
                                         AL_DMACAHB_STATE_LLP_MODE_BUSY | AL_DMACAHB_STATE_LLP_RELOAD_MODE_BUSY))) {
        return AL_DMACAHB_ERR_TRANS_BUSY;
    }

    AlDmacAhb_Dev_SetState(Channel, State);

    if ((State == AL_DMACAHB_STATE_LLP_MODE_BUSY) || (State == AL_DMACAHB_STATE_LLP_RELOAD_MODE_BUSY)) {
        AlDmacAhb_ll_SetLinkStartAddr(BaseAddr, ChOffset, (AL_REG)Trans->Lli);
        AlDmacAhb_ll_SetLms(BaseAddr, ChOffset, Channel->Config.ListMasterSel);
        /* Write these register for contiguous src/dst */
        AlDmacAhb_ll_WriteSrcAddr(BaseAddr, ChOffset, Trans->SrcAddr);
        AlDmacAhb_ll_WriteDstAddr(BaseAddr, ChOffset, Trans->DstAddr);
    } else {
        AlDmacAhb_ll_WriteSrcAddr(BaseAddr, ChOffset, Trans->SrcAddr);
        AlDmacAhb_ll_WriteDstAddr(BaseAddr, ChOffset, Trans->DstAddr);
        AlDmacAhb_ll_SetBlkTransSize(BaseAddr, ChOffset, Trans->TransSize);
    }

    return Ret;
}

/**
 * This function set channel trans params and enable it
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @return
 *          - AL_DMACAHB_ERR_NULL_PTR Channel is NULL
 *          - AL_DMACAHB_ERR_ADDR_NOT_ALIGN src or dst address not align with their trans width
 *          - AL_DMACAHB_ERR_STATE_NOT_READY channel not ready
 *          - AL_OK start success
 * @note
*/
AL_S32 AlDmacAhb_Dev_Start(AL_DMACAHB_ChStruct *Channel)
{
    AL_S32 Ret;

    Ret = AlDmacAhb_Dev_SetTransParams(Channel);
    if (Ret != AL_OK) {
        return Ret;
    }

    AlDmacAhb_ll_SetChannelEn(Channel->Dmac->BaseAddr, Channel->Param.ChMask, AL_TRUE);

    return AL_OK;
}

/**
 * This function init DMACAHB module
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @param   HwConfigs is hardware config structure with AL_DMACAHB_HwConfigStruct
 * @param   InitConfig is module config structure with AL_DMACAHB_InitStruct
 * @return
 *          - AL_OK is init done
 * @note
*/
AL_S32 AlDmacAhb_Dev_Init(AL_DMACAHB_ChStruct *Channel, AL_DMACAHB_HwConfigStruct *HwConfig,
                          AL_DMACAHB_ChInitStruct *InitConfig)
{
    Channel->Config = (InitConfig == AL_NULL) ? AlDmacAhb_ChDefInitConfig : (*InitConfig);
    Channel->Dmac   = &AlDmacAhb_DmacInstance[HwConfig->DeviceId];

    if (Channel->Dmac->State.DmacEn == AL_FALSE) {
        Channel->Dmac->BaseAddr     = HwConfig->BaseAddress;
        Channel->Dmac->DevId        = HwConfig->DeviceId;
        Channel->Dmac->IntrId       = HwConfig->IntrId;
        Channel->Dmac->ChannelNum   = HwConfig->ChannelNum;
        Channel->Dmac->LockAddress  = HwConfig->LockAddress;
        Channel->Dmac->ChStateAddr  = HwConfig->ChStateAddr;
        AlDmacAhb_ll_SetDmaCfgEn(Channel->Dmac->BaseAddr, AL_TRUE);
        Channel->Dmac->State.DmacEn = AL_TRUE;
    }

    Channel->Param = AlDmacAhb_ChParam[Channel->Config.Id];

    Channel->Dmac->State.ChEn |= AlDmacAhb_ChParam[Channel->Config.Id].ChMask;
    Channel->Dmac->Channel[Channel->Config.Id] = Channel;

    AlDmacAhb_Dev_ClrChAllIntr(Channel);
    AlDmacAhb_Dev_UnmaskChIntr(Channel);
    AlDmacAhb_Dev_SetTransType(Channel);
    AlDmacAhb_Dev_SetCtlLoReg(Channel);
    AlDmacAhb_Dev_SetCfgLoReg(Channel);
    AlDmacAhb_Dev_SetCfgHiReg(Channel);
    AlDmacAhb_Dev_SetSgrDsr(Channel);

    AlDmacAhb_Dev_SetState(Channel, AL_DMACAHB_STATE_READY);

    return AL_OK;
}

/**
 * This function deinit DMACAHB module
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @return
 *          - AL_OK is init done
 * @note
*/
AL_S32 AlDmacAhb_Dev_DeInit(AL_DMACAHB_ChStruct *Channel)
{
    /* TODO: modify for sync baremetal and kernel */
    /* Firstly, clear channel status in dmac struct */
    Channel->Dmac->State.ChEn &= ~(Channel->Param.ChMask);
    if (!Channel->Dmac->State.ChEn) {
        /* Only one channel enabled, reset dmac */
        AlDmacAhb_ll_SetDmaCfgEn(Channel->Dmac->BaseAddr, AL_FALSE);
        memset(Channel->Dmac, 0, sizeof(AL_DMACAHB_DmacStruct));
        /* TODO: unregister intr handler */
    }

    /* Reset channel struct and unlink channel with handle */
    memset(Channel, 0, sizeof(AL_DMACAHB_ChStruct));

    return AL_OK;
}

/**
 * This function register interrupt call back function
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @param   CallBack is call back struct with AL_CAN_CallBackStruct
 * @return
 *          - AL_OK is register correct
 * @note
*/
AL_S32 AlDmacAhb_Dev_RegisterChEventCallBack(AL_DMACAHB_ChStruct *Channel, AL_DMACAHB_ChCallBackStruct *CallBack)
{
    if (Channel == AL_NULL || CallBack == AL_NULL) {
        return AL_DMACAHB_ERR_NULL_PTR;
    }

    if (Channel->EventCallBack.Func != AL_NULL) {

#ifdef DMACAHB_DEBUG
        AL_LOG(AL_ERR_LEVEL_WARNING, "dmacahb=%p duplicate register callback: replace old:%p with New: %p\r\n",
               Channel, Channel->EventCallBack, CallBack);
#endif
    }

    Channel->EventCallBack.Func = CallBack->Func;
    Channel->EventCallBack.Ref  = CallBack->Ref;

    return AL_OK;
}

/**
 * This function unregister interrupt call back function
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @return
 *          - AL_OK is unregister correct
 * @note
*/
AL_S32 AlDmacAhb_Dev_UnRegisterChEventCallBack(AL_DMACAHB_ChStruct *Channel)
{
    if (Channel == AL_NULL) {
        return AL_DMACAHB_ERR_NULL_PTR;
    }

    Channel->EventCallBack.Func = (AL_DMACAHB_ChEventCallBack)AL_NULL;

    return AL_OK;
}

/**
 * This function get module status
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @param   State is enum to AL_DMACAHB_ChStateEnum
 * @return  is this state active or not
 * @note
*/
AL_BOOL AlDmacAhb_Dev_GetState(AL_DMACAHB_ChStruct *Channel, AL_DMACAHB_ChStateEnum State)
{
    return ((Channel->State & State) ? AL_TRUE : AL_FALSE);
}

/**
 * This function set module status
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @param   State is enum to AL_DMACAHB_ChStateEnum
 * @return
 * @note
*/
AL_VOID AlDmacAhb_Dev_SetState(AL_DMACAHB_ChStruct *Channel, AL_DMACAHB_ChStateEnum State)
{
    Channel->State |= State;
}

/**
 * This function clr module status
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @param   State is enum to AL_DMACAHB_ChStateEnum
 * @return
 * @note
*/
AL_VOID AlDmacAhb_Dev_ClrState(AL_DMACAHB_ChStruct *Channel, AL_DMACAHB_ChStateEnum State)
{
    Channel->State &= ~State;
}

/**
 * This function handle trans complete intr
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @return
 * @note
*/
static AL_VOID AlDmacAhb_Dev_TransCompHandler(AL_DMACAHB_ChStruct *Channel)
{
    AL_DMACAHB_ChStateEnum State;
    AL_LOG(AL_ERR_LEVEL_DEBUG, "Dmacahb Channel %d trans complete!\r\n", Channel->Config.Id);

    /* multi-block trans done with trans complete intr */
    AlDmacAhb_Dev_TransTypeToState(Channel->Config.TransType, &State);
    AlDmacAhb_Dev_ClrState(Channel, State);

    AL_DMACAHB_EventStruct Event = {
        .EventId    = AL_DMACAHB_EVENT_TRANS_COMP,
        .EventData  = 0
    };
    Channel->EventCallBack.Func(&Event, Channel->EventCallBack.Ref);
}

/**
 * This function handle block trans complete intr
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @return
 * @note
*/
static AL_VOID AlDmacAhb_Dev_BlockTransCompHandler(AL_DMACAHB_ChStruct *Channel)
{
    AL_DMACAHB_ChStateEnum State;
    AL_LOG(AL_ERR_LEVEL_DEBUG, "Dmacahb Channel %d block trans complete!\r\n", Channel->Config.Id);

    /* Abandon BLOCK_TRANS_BUSY state, to be remove */
    // AlDmacAhb_Dev_ClrState(Channel, AL_DMACAHB_STATE_BLOCK_TRANS_BUSY);

    AlDmacAhb_Dev_TransTypeToState(Channel->Config.TransType, &State);
    /* In reload mode, before the last trans, set reload_src and reload_dst to AL_FALSE */
    if (State == AL_DMACAHB_STATE_RELOAD_MODE_BUSY || State == AL_DMACAHB_STATE_LLP_RELOAD_MODE_BUSY) {
        Channel->Trans.ReloadCount++;
        if (Channel->Trans.ReloadCountNum != 0xFFFFFFFF) {
            if (Channel->Trans.ReloadCount == Channel->Trans.ReloadCountNum) {
                AlDmacAhb_Dev_ClrState(Channel, State);
            } else if ((Channel->Trans.ReloadCount == (Channel->Trans.ReloadCountNum - 1)) &&
                    (State == AL_DMACAHB_STATE_RELOAD_MODE_BUSY)) {
                AL_BOOL IsLastTransSet = AL_TRUE;
                AlDmacAhb_Dev_IoCtl(Channel, AL_DMACAHB_IOCTL_SET_RELOAD_LAST_TRANS, &IsLastTransSet);
            }
        }

    }

    AL_DMACAHB_EventStruct Event = {
        .EventId    = AL_DMACAHB_EVENT_BLOCK_TRANS_COMP,
        .EventData  = 0
    };
    Channel->EventCallBack.Func(&Event, Channel->EventCallBack.Ref);
}

/**
 * This function handle src trans complete intr
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @return
 * @note
*/
static AL_VOID AlDmacAhb_Dev_SrcTransCompHandler(AL_DMACAHB_ChStruct *Channel)
{
    AL_LOG(AL_ERR_LEVEL_DEBUG, "Dmacahb Channel %d src trans complete!\r\n", Channel->Config.Id);
    AL_DMACAHB_EventStruct Event = {
        .EventId    = AL_DMACAHB_EVENT_SRC_TRANS_COMP,
        .EventData  = 0
    };
    Channel->EventCallBack.Func(&Event, Channel->EventCallBack.Ref);
}

/**
 * This function handle dst trans complete intr
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @return
 * @note
*/
static AL_VOID AlDmacAhb_Dev_DstTransCompHandler(AL_DMACAHB_ChStruct *Channel)
{
    AL_LOG(AL_ERR_LEVEL_DEBUG, "Dmacahb Channel %d dst trans complete!\r\n", Channel->Config.Id);
    AL_DMACAHB_EventStruct Event = {
        .EventId    = AL_DMACAHB_EVENT_DST_TRANS_COMP,
        .EventData  = 0
    };
    Channel->EventCallBack.Func(&Event, Channel->EventCallBack.Ref);
}

/**
 * This function handle channel error intr
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @return
 * @note
*/
static AL_VOID AlDmacAhb_Dev_ErrHandler(AL_DMACAHB_ChStruct *Channel)
{
    AL_LOG(AL_ERR_LEVEL_DEBUG, "DmacAhb ErrHandler\r\n");
    AL_DMACAHB_EventStruct Event = {
        .EventId    = AL_DMACAHB_EVENT_ERR,
        .EventData  = 0
    };
    Channel->EventCallBack.Func(&Event, Channel->EventCallBack.Ref);
}

/**
 * This function is intr call back
 * @param   Instance is pointer to intr call back reference
 * @return
 * @note
*/
AL_VOID AlDmacAhb_Dev_IntrHandler(AL_VOID *Instance)
{
    AL_DMACAHB_DmacStruct *Dmac = (AL_DMACAHB_DmacStruct *)Instance;
    AL_U32 IntrStatus = AlDmacAhb_ll_ReadStatusIntr(Dmac->BaseAddr);
    /* TODO: think sync with kernel */
    if (AL_DMACAHB_TFR_INTR(IntrStatus)) {
        AL_U32 TfrStatus = AlDmacAhb_ll_ReadStatusTfr(Dmac->BaseAddr);
        for (AL_U32 i = 0; i < Dmac->ChannelNum; i++) {
            if (TfrStatus & (0x1 << i)) {
                AlDmacAhb_Dev_TransCompHandler(Dmac->Channel[i]);
                AlDmacAhb_ll_WriteClearTfr(Dmac->BaseAddr, (0x1 << i));
            }
        }
    }

    if (AL_DMACAHB_BLOCK_INTR(IntrStatus)) {
        AL_U32 BlockStatus = AlDmacAhb_ll_ReadStatusBlock(Dmac->BaseAddr);
        for (AL_U32 i = 0; i < Dmac->ChannelNum; i++) {
            if (BlockStatus & (0x1 << i)) {
                AlDmacAhb_Dev_BlockTransCompHandler(Dmac->Channel[i]);
                AlDmacAhb_ll_WriteClearBlock(Dmac->BaseAddr, (0x1 << i));
            }
        }
    }

    if (AL_DMACAHB_SRCT_INTR(IntrStatus)) {
        AL_U32 SrctStatus = AlDmacAhb_ll_ReadStatusSrcTran(Dmac->BaseAddr);
        for (AL_U32 i = 0; i < Dmac->ChannelNum; i++) {
            if (SrctStatus & (0x1 << i)) {
                AlDmacAhb_Dev_SrcTransCompHandler(Dmac->Channel[i]);
                AlDmacAhb_ll_WriteClearSrcTran(Dmac->BaseAddr, (0x1 << i));
            }
        }
    }

    if (AL_DMACAHB_DSTT_INTR(IntrStatus)) {
        AL_U32 DsttStatus = AlDmacAhb_ll_ReadStatusDstTran(Dmac->BaseAddr);
        for (AL_U32 i = 0; i < Dmac->ChannelNum; i++) {
            if (DsttStatus & (0x1 << i)) {
                AlDmacAhb_Dev_DstTransCompHandler(Dmac->Channel[i]);
                AlDmacAhb_ll_WriteClearDstTran(Dmac->BaseAddr, (0x1 << i));
            }
        }
    }

    if (AL_DMACAHB_ERR_INTR(IntrStatus)) {  /* TODO: bus error */
        AL_U32 ErrStatus = AlDmacAhb_ll_ReadStatusErr(Dmac->BaseAddr);
        for (AL_U32 i = 0; i < Dmac->ChannelNum; i++) {
            if (ErrStatus & (0x1 << i)) {
                AlDmacAhb_Dev_ErrHandler(Dmac->Channel[i]);
                AlDmacAhb_ll_WriteClearErr(Dmac->BaseAddr, (0x1 << i));
            }
        }
    }
}

/**
 * This function excute operations exclude dma start
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @param   Cmd is io ctl operation to AL_DMACAHB_IoCtlCmdEnum
 * @param   Data is pointer reference to Cmd
 * @return
 *          - AL_OK is send done
 * @note
*/
AL_S32 AlDmacAhb_Dev_IoCtl(AL_DMACAHB_ChStruct *Channel, AL_DMACAHB_IoCtlCmdEnum Cmd, AL_VOID *Data)
{
    if (Channel == AL_NULL) {
        return AL_DMACAHB_ERR_NULL_PTR;
    }

    switch (Cmd)
    {
    case AL_DMACAHB_IOCTL_FILL_LLI_WITH_CTL: {
        AL_DMACAHB_LliStruct *Lli = (AL_DMACAHB_LliStruct *)Data;
        AlDmacAhb_Dev_FillLliWithCtl(Channel, Lli);
    }
    case AL_DMACAHB_IOCTL_GET_STATE: {
        AL_DMACAHB_ChStateEnum *GetState = (AL_DMACAHB_ChStateEnum *)Data;
        *GetState = Channel->State;
        break;
    }
    case AL_DMACAHB_IOCTL_SET_STATE: {
        AL_DMACAHB_ChStateEnum SetState = *(AL_DMACAHB_ChStateEnum *)Data;
        AlDmacAhb_Dev_SetState(Channel, SetState);
        break;
    }
    case AL_DMACAHB_IOCTL_CLR_STATE: {
        AL_DMACAHB_ChStateEnum ClrState = *(AL_DMACAHB_ChStateEnum *)Data;
        AlDmacAhb_Dev_ClrState(Channel, ClrState);
        break;
    }
    case AL_DMACAHB_IOCTL_READ_CTL_LO_REG: {
        AL_DMACAHB_CtlLoUnion *ReadCtlLo = (AL_DMACAHB_CtlLoUnion *)Data;
        ReadCtlLo->Reg = AlDmacAhb_ll_ReadCtlLo(Channel->Dmac->BaseAddr, Channel->Param.ChBaseOffset);
        break;
    }
    case AL_DMACAHB_IOCTL_READ_CTL_HI_REG: {
        AL_DMACAHB_CtlHiUnion *ReadCtlHi = (AL_DMACAHB_CtlHiUnion *)Data;
        ReadCtlHi->Reg = AlDmacAhb_ll_ReadCtlHi(Channel->Dmac->BaseAddr, Channel->Param.ChBaseOffset);
        break;
    }
    case AL_DMACAHB_IOCTL_READ_CFG_LO_REG: {
        AL_DMACAHB_CfgLoUnion *ReadCfgLo = (AL_DMACAHB_CfgLoUnion *)Data;
        ReadCfgLo->Reg = AlDmacAhb_ll_ReadCfgLo(Channel->Dmac->BaseAddr, Channel->Param.ChBaseOffset);
        break;
    }
    case AL_DMACAHB_IOCTL_READ_CFG_HI_REG: {
        AL_DMACAHB_CfgHiUnion *ReadCfgHi = (AL_DMACAHB_CfgHiUnion *)Data;
        ReadCfgHi->Reg = AlDmacAhb_ll_ReadCfgHi(Channel->Dmac->BaseAddr, Channel->Param.ChBaseOffset);
        break;
    }
    case AL_DMACAHB_IOCTL_WRITE_CTL_LO_REG: {
        AL_DMACAHB_CtlLoUnion *WriteCtlLo = (AL_DMACAHB_CtlLoUnion *)Data;
        AlDmacAhb_ll_WriteCtlLo(Channel->Dmac->BaseAddr, Channel->Param.ChBaseOffset, WriteCtlLo->Reg);
        break;
    }
    case AL_DMACAHB_IOCTL_WRITE_CTL_HI_REG: {
        AL_DMACAHB_CtlHiUnion *WriteCtlHi = (AL_DMACAHB_CtlHiUnion *)Data;
        AlDmacAhb_ll_WriteCtlHi(Channel->Dmac->BaseAddr, Channel->Param.ChBaseOffset, WriteCtlHi->Reg);
        break;
    }
    case AL_DMACAHB_IOCTL_WRITE_CFG_LO_REG: {
        AL_DMACAHB_CfgLoUnion *WriteCfgLo = (AL_DMACAHB_CfgLoUnion *)Data;
        AlDmacAhb_ll_WriteCfgLo(Channel->Dmac->BaseAddr, Channel->Param.ChBaseOffset, WriteCfgLo->Reg);
        break;
    }
    case AL_DMACAHB_IOCTL_WRITE_CFG_HI_REG: {
        AL_DMACAHB_CfgHiUnion *WriteCfgHi = (AL_DMACAHB_CfgHiUnion *)Data;
        AlDmacAhb_ll_WriteCfgHi(Channel->Dmac->BaseAddr, Channel->Param.ChBaseOffset, WriteCfgHi->Reg);
        break;
    }
    case AL_DMACAHB_IOCTL_GET_PARAM_CHANNEL_0:
    case AL_DMACAHB_IOCTL_GET_PARAM_CHANNEL_1:
    case AL_DMACAHB_IOCTL_GET_PARAM_CHANNEL_2:
    case AL_DMACAHB_IOCTL_GET_PARAM_CHANNEL_3:
    case AL_DMACAHB_IOCTL_GET_PARAM_CHANNEL_4:
    case AL_DMACAHB_IOCTL_GET_PARAM_CHANNEL_5:
    case AL_DMACAHB_IOCTL_GET_PARAM_CHANNEL_6:
    case AL_DMACAHB_IOCTL_GET_PARAM_CHANNEL_7:{
        AL_DMACAHB_DmaCompChParamsUnion *ChParam = (AL_DMACAHB_DmaCompChParamsUnion *)Data;
        ChParam->Reg = AlDmacAhb_ll_ReadDmaCompChannelx(Channel->Dmac->BaseAddr,
                                                        (Cmd - AL_DMACAHB_IOCTL_GET_PARAM_CHANNEL_0));
        break;
    }
    case AL_DMACAHB_IOCTL_SET_CHANNEL_EN:{
        AL_BOOL IsChEn = *(AL_BOOL *)Data;
        AlDmacAhb_ll_SetChannelEn(Channel->Dmac->BaseAddr, Channel->Param.ChMask, IsChEn);
        break;
    }
    case AL_DMACAHB_IOCTL_SET_RELOAD_LAST_TRANS:{
        AL_BOOL IsSet = *(AL_BOOL *)Data;
        AlDmacAhb_ll_SetSrcAutoReload(Channel->Dmac->BaseAddr, Channel->Param.ChBaseOffset, ~IsSet);
        AlDmacAhb_ll_SetDstAutoReload(Channel->Dmac->BaseAddr, Channel->Param.ChBaseOffset, ~IsSet);
        break;
    }
    default:
        return AL_DMACAHB_ERR_IOCTL_CMD;
        break;
    }

    return AL_OK;
}

/**
 * This function switch trans type to state
 * @param   Type is enum to AL_DMACAHB_TransTypeEnum
 * @param   State is pointer to AL_DMACAHB_ChStateEnum
 * @return
 *          - AL_OK switch type to state correct
 *          - AL_DMACAHB_ERR_NULL_PTR
 *          - AL_DMACAHB_ERR_ILLEGAL_PARAM
 * @note
*/
AL_S32 AlDmacAhb_Dev_TransTypeToState(AL_DMACAHB_TransTypeEnum Type, AL_DMACAHB_ChStateEnum *State)
{
    if (State == AL_NULL) {
        return AL_DMACAHB_ERR_NULL_PTR;
    }

    switch (Type)
    {
    case AL_DMACAHB_TRANS_TYPE_1:
    case AL_DMACAHB_TRANS_TYPE_5:
        *State = AL_DMACAHB_STATE_SINGLE_MODE_BUSY;
        break;
    case AL_DMACAHB_TRANS_TYPE_2:
    case AL_DMACAHB_TRANS_TYPE_3:
    case AL_DMACAHB_TRANS_TYPE_4:
        *State = AL_DMACAHB_STATE_RELOAD_MODE_BUSY;
        break;
    case AL_DMACAHB_TRANS_TYPE_6:
    case AL_DMACAHB_TRANS_TYPE_8:
    case AL_DMACAHB_TRANS_TYPE_10:
        *State = AL_DMACAHB_STATE_LLP_MODE_BUSY;
        break;
    case AL_DMACAHB_TRANS_TYPE_7:
    case AL_DMACAHB_TRANS_TYPE_9:
        *State = AL_DMACAHB_STATE_LLP_RELOAD_MODE_BUSY;
        break;
    default:
        return AL_DMACAHB_ERR_ILLEGAL_PARAM;
        break;
    }

    return AL_OK;
}

AL_S32 AlDmacAhb_Dev_RequestCh(AL_DMACAHB_HwConfigStruct *HwConfig, AL_DMACAHB_ChIdEnum RequestId,
                               AL_DMACAHB_ChIdEnum *AvailableId)
{
    AL_U32 Timeout = 1000;
    if (RequestId > HwConfig->ChannelNum) {
        AL_LOG(AL_ERR_LEVEL_INFO, "Request channel Id is not support!\r\n");
    }

    while ((!AlDmacAhb_ll_FetchLock(HwConfig->LockAddress)) && Timeout--) {
        AL_DMACAHB_LOOP_REG_DELAY;
    }

    if (!Timeout) {
        AL_LOG(AL_ERR_LEVEL_ERROR, "Lock fetch timeout!\r\n");
        return AL_DMACAHB_ERR_FETCH_LOCK;
    }

    AL_U32 ChState = AlDmacAhb_ll_GetChannelState(HwConfig->ChStateAddr);
    if (ChState & AlDmacAhb_ChParam[RequestId].ChMask) {
        AL_LOG(AL_ERR_LEVEL_INFO, "Request channel Id is used!\r\n");
    } else {
        /* TODO: owner channel */
    }

    AL_LOG(AL_ERR_LEVEL_INFO, "Auto assign a channel!\r\n");

    AL_U32 i;
    for (i = 0; i < HwConfig->ChannelNum; i++) {
        if (!(ChState & AlDmacAhb_ChParam[RequestId].ChMask)) {
            AlDmacAhb_ll_SetChannelState(HwConfig->ChStateAddr, (ChState | AlDmacAhb_ChParam[RequestId].ChMask));
            AL_LOG(AL_ERR_LEVEL_INFO, "Assign an available channel %d!\r\n", i);
            *AvailableId = i;
            break;
        }
    }

    AlDmacAhb_ll_ReleaseLock(HwConfig->LockAddress);

    if (i == HwConfig->ChannelNum) {
        AL_LOG(AL_ERR_LEVEL_ERROR, "No available channel here!\r\n");
        return AL_DMACAHB_ERR_NONE_AVAILABLE_CH;
    }

    return AL_OK;
}

AL_S32 AlDmacAhb_Dev_ReleaseCh(AL_DMACAHB_ChStruct *Channel)
{
    AL_U32 Timeout = 1000;

    if (Channel == AL_NULL) {
        return AL_DMACAHB_ERR_NULL_PTR;
    }

    while ((!AlDmacAhb_ll_FetchLock(Channel->Dmac->LockAddress)) && Timeout--) {
        AL_DMACAHB_LOOP_REG_DELAY;
    }

    if (!Timeout) {
        AL_LOG(AL_ERR_LEVEL_ERROR, "Lock fetch timeout!\r\n");
        return AL_DMACAHB_ERR_FETCH_LOCK;
    }

    AL_U32 ChState = AlDmacAhb_ll_GetChannelState(Channel->Dmac->ChStateAddr);

    AlDmacAhb_ll_SetChannelState(Channel->Dmac->ChStateAddr, (ChState & (~Channel->Param.ChMask)));

    AlDmacAhb_ll_ReleaseLock(Channel->Dmac->LockAddress);

    return AL_OK;
}