/*
 * Copyright (c) 2023, Anlogic Inc. and Contributors. All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

/***************************** Include Files *********************************/
#ifdef __aarch64__
#include "al_aarch64_core.h"
#endif
#include "al_dmacahb_dev.h"
#include "al_errno.h"
#include <string.h>

/************************** Constant Definitions *****************************/
/* Channel register offset and mask */
static AL_DMACAHB_ChParamStruct AlDmacAhb_ChParam[AL_DMACAHB_CHANNEL_NUM] = {
    {.ChBaseOffset = (0x000), .ChMask = (0x1 << 0)},
    {.ChBaseOffset = (0x058), .ChMask = (0x1 << 1)},
    {.ChBaseOffset = (0x0B0), .ChMask = (0x1 << 2)},
    {.ChBaseOffset = (0x108), .ChMask = (0x1 << 3)},
    {.ChBaseOffset = (0x160), .ChMask = (0x1 << 4)},
    {.ChBaseOffset = (0x1B8), .ChMask = (0x1 << 5)},
    {.ChBaseOffset = (0x210), .ChMask = (0x1 << 6)},
    {.ChBaseOffset = (0x268), .ChMask = (0x1 << 7)},
};

/* Default init config */
static AL_DMACAHB_ChInitStruct AlDmacAhb_ChDefInitConfig = {
    .Id                     = AL_DMACAHB_CHANNEL_0,
    .TransType              = AL_DMACAHB_TRANS_TYPE_1,
    .Intr.IsIntrEn          = AL_TRUE,
    .Intr.IntrUnMask        = AL_DMACAHB_CH_INTR_TFR | AL_DMACAHB_CH_INTR_ERR,
    .SrcTransWidth          = AL_DMACAHB_TRANS_WIDTH_32,
    .DstTransWidth          = AL_DMACAHB_TRANS_WIDTH_32,
    .SrcAddrIncMode         = AL_DMACAHB_ADDR_INC_INC,
    .DstAddrIncMode         = AL_DMACAHB_ADDR_INC_INC,
    .SrcBurstLength         = AL_DMACAHB_MSIZE_1,
    .DstBurstLength         = AL_DMACAHB_MSIZE_1,
    .Direction              = AL_DMACAHB_TT_FC_MEM2MEM,
    .SrcMasterSel           = AL_DMACAHB_MASTER_SEL_1,
    .DstMasterSel           = AL_DMACAHB_MASTER_SEL_1,
    .ListMasterSel          = AL_DMACAHB_MASTER_SEL_1,
    .ChPrior                = AL_DMACAHB_CH_PRIOR_7,
    .FifoMode               = AL_DMACAHB_FIFO_MODE_0,
    .ProtCtl                = AL_DMACAHB_PROT_0,
    .SgrDsr.IsSrcGatherEn   = AL_FALSE,
    .SgrDsr.IsDstScatterEn  = AL_FALSE,
};

/**************************** Type Definitions *******************************/
/* TODO: LLI state */
/***************** Macros (Inline Functions) Definitions *********************/
/*Intr state check*/
#define AL_DMACAHB_TFR_INTR(Status)     (Status & AL_DMACAHB_CH_INTR_TFR)
#define AL_DMACAHB_BLOCK_INTR(Status)   (Status & AL_DMACAHB_CH_INTR_BLOCK)
#define AL_DMACAHB_SRCT_INTR(Status)    (Status & AL_DMACAHB_CH_INTR_SRCT)
#define AL_DMACAHB_DSTT_INTR(Status)    (Status & AL_DMACAHB_CH_INTR_DSTT)
#define AL_DMACAHB_ERR_INTR(Status)     (Status & AL_DMACAHB_CH_INTR_ERR)

#define AL_DMACAHB_LOOP_REG_DELAY       do {AlSys_MDelay(1);} while (0)
#define AL_DMACAHB_LOOP_REG_CNT_MAX     (1000)

/************************** Variable Definitions *****************************/
/* Hardware config generated by TD */
extern AL_DMACAHB_HwConfigStruct AlDmacAhb_HwConfig[];

/* Static dmac instance */
static AL_DMACAHB_DmacStruct AlDmacAhb_DmacInstance[AL_DMACAHB_NUM_INSTANCE];

/************************** Function Prototypes ******************************/
AL_BOOL AlDmacAhb_Dev_GetState(AL_DMACAHB_ChStruct *Channel, AL_DMACAHB_ChStateEnum State);

AL_VOID AlDmacAhb_Dev_SetState(AL_DMACAHB_ChStruct *Channel, AL_DMACAHB_ChStateEnum State);

AL_VOID AlDmacAhb_Dev_ClrState(AL_DMACAHB_ChStruct *Channel, AL_DMACAHB_ChStateEnum State);

/************************** Function Definitions ******************************/
/**
 * This function looks up the hardware configuration for a given device ID.
 *
 * @param DeviceId The unique identifier for the device.
 * @return A pointer to the hardware configuration structure if found, otherwise NULL.
 */
AL_DMACAHB_HwConfigStruct *AlDmacAhb_Dev_LookupConfig(AL_U32 DeviceId)
{
    AL_U32 Index;
    AL_DMACAHB_HwConfigStruct *CfgPtr = AL_NULL;

    for (Index = 0; Index < AL_DMACAHB_NUM_INSTANCE; Index++) {
        if (AlDmacAhb_HwConfig[Index].DeviceId == DeviceId) {
            CfgPtr = &AlDmacAhb_HwConfig[Index];
            break;
        }
    }

    return CfgPtr;
}

/**
 * This function clears all interrupts for a given DMA channel.
 *
 * @param Channel A pointer to the DMA channel structure.
 * @return AL_OK on success, error code on failure.
 */
AL_S32 AlDmacAhb_Dev_ClrChAllIntr(AL_DMACAHB_ChStruct *Channel)
{
    AL_ASSERT(Channel != AL_NULL, AL_DMACAHB_ERR_NULL_PTR);

    AL_U32 ChMask = Channel->Param.ChMask;
    AL_REG BaseAddr = Channel->Dmac->BaseAddr;

    AlDmacAhb_ll_WriteClearTfr(BaseAddr, ChMask);
    AlDmacAhb_ll_WriteClearBlock(BaseAddr, ChMask);
    AlDmacAhb_ll_WriteClearBlock(BaseAddr, ChMask);
    AlDmacAhb_ll_WriteClearDstTran(BaseAddr, ChMask);
    AlDmacAhb_ll_WriteClearErr(BaseAddr, ChMask);

    return AL_OK;
}

/**
 * This function unmasks interrupts for a given DMA channel based on its configuration.
 *
 * @param Channel A pointer to the DMA channel structure.
 * @return AL_OK on success, error code on failure.
 */
AL_S32 AlDmacAhb_Dev_UnmaskChIntr(AL_DMACAHB_ChStruct *Channel)
{
    AL_ASSERT(Channel != AL_NULL, AL_DMACAHB_ERR_NULL_PTR);

    AL_U32 ChMask = Channel->Param.ChMask;
    AL_REG BaseAddr = Channel->Dmac->BaseAddr;

    if (Channel->Config.Intr.IntrUnMask & AL_DMACAHB_CH_INTR_TFR) {
        AlDmacAhb_ll_SetMaskTfr(BaseAddr, ChMask, AL_DMACAHB_INTR_UNMASK);
    }
    if (Channel->Config.Intr.IntrUnMask & AL_DMACAHB_CH_INTR_BLOCK) {
        AlDmacAhb_ll_SetMaskBlock(BaseAddr, ChMask, AL_DMACAHB_INTR_UNMASK);
    }
    if (Channel->Config.Intr.IntrUnMask & AL_DMACAHB_CH_INTR_SRCT) {
        AlDmacAhb_ll_SetMaskSrcTran(BaseAddr, ChMask, AL_DMACAHB_INTR_UNMASK);
    }
    if (Channel->Config.Intr.IntrUnMask & AL_DMACAHB_CH_INTR_DSTT) {
        AlDmacAhb_ll_SetMaskDstTran(BaseAddr, ChMask, AL_DMACAHB_INTR_UNMASK);
    }
    if (Channel->Config.Intr.IntrUnMask & AL_DMACAHB_CH_INTR_ERR) {
        AlDmacAhb_ll_SetMaskErr(BaseAddr, ChMask, AL_DMACAHB_INTR_UNMASK);
    }

    return AL_OK;
}

/**
 * This function masks interrupts for a given DMA channel based on its configuration.
 *
 * @param Channel A pointer to the DMA channel structure.
 * @return AL_OK on success, error code on failure.
 */
AL_S32 AlDmacAhb_Dev_MaskChIntr(AL_DMACAHB_ChStruct *Channel)
{
    AL_ASSERT(Channel != AL_NULL, AL_DMACAHB_ERR_NULL_PTR);

    AL_U32 ChMask = Channel->Param.ChMask;
    AL_REG BaseAddr = Channel->Dmac->BaseAddr;

    if (Channel->Config.Intr.IntrUnMask & AL_DMACAHB_CH_INTR_TFR) {
        AlDmacAhb_ll_SetMaskTfr(BaseAddr, ChMask, AL_DMACAHB_INTR_MASK);
    }
    if (Channel->Config.Intr.IntrUnMask & AL_DMACAHB_CH_INTR_BLOCK) {
        AlDmacAhb_ll_SetMaskBlock(BaseAddr, ChMask, AL_DMACAHB_INTR_MASK);
    }
    if (Channel->Config.Intr.IntrUnMask & AL_DMACAHB_CH_INTR_SRCT) {
        AlDmacAhb_ll_SetMaskSrcTran(BaseAddr, ChMask, AL_DMACAHB_INTR_MASK);
    }
    if (Channel->Config.Intr.IntrUnMask & AL_DMACAHB_CH_INTR_DSTT) {
        AlDmacAhb_ll_SetMaskDstTran(BaseAddr, ChMask, AL_DMACAHB_INTR_MASK);
    }
    if (Channel->Config.Intr.IntrUnMask & AL_DMACAHB_CH_INTR_ERR) {
        AlDmacAhb_ll_SetMaskErr(BaseAddr, ChMask, AL_DMACAHB_INTR_MASK);
    }

    return AL_OK;
}

/**
 * This function sets the transaction type for a given DMA channel.
 *
 * @param Channel A pointer to the DMA channel structure.
 * @return AL_OK on success, AL_DMACAHB_ERR_ILLEGAL_PARAM if an invalid transaction type is specified, error code on failure.
 */
AL_S32 AlDmacAhb_Dev_SetTransType(AL_DMACAHB_ChStruct *Channel)
{
    AL_ASSERT(Channel != AL_NULL, AL_DMACAHB_ERR_NULL_PTR);

    AL_BOOL LlpSrcEn, LlpDstEn;
    AL_BOOL SrcAutoEn, DstAutoEn;
    AL_U32 ChOffset = Channel->Param.ChBaseOffset;
    AL_REG BaseAddr = Channel->Dmac->BaseAddr;

    switch (Channel->Config.TransType)
    {
    case AL_DMACAHB_TRANS_TYPE_1:
        AlDmacAhb_ll_SetLinkStartAddr(BaseAddr, ChOffset, 0);
        LlpSrcEn    = AL_FALSE;
        LlpDstEn    = AL_FALSE;
        SrcAutoEn   = AL_FALSE;
        DstAutoEn   = AL_FALSE;
        break;
    case AL_DMACAHB_TRANS_TYPE_2:
        AlDmacAhb_ll_SetLinkStartAddr(BaseAddr, ChOffset, 0);
        LlpSrcEn    = AL_FALSE;
        LlpDstEn    = AL_FALSE;
        SrcAutoEn   = AL_FALSE;
        DstAutoEn   = AL_TRUE;
        break;
    case AL_DMACAHB_TRANS_TYPE_3:
        AlDmacAhb_ll_SetLinkStartAddr(BaseAddr, ChOffset, 0);
        LlpSrcEn    = AL_FALSE;
        LlpDstEn    = AL_FALSE;
        SrcAutoEn   = AL_TRUE;
        DstAutoEn   = AL_FALSE;
        break;
    case AL_DMACAHB_TRANS_TYPE_4:
        AlDmacAhb_ll_SetLinkStartAddr(BaseAddr, ChOffset, 0);
        LlpSrcEn    = AL_FALSE;
        LlpDstEn    = AL_FALSE;
        SrcAutoEn   = AL_TRUE;
        DstAutoEn   = AL_TRUE;
        break;
    case AL_DMACAHB_TRANS_TYPE_5:
        LlpSrcEn    = AL_FALSE;
        LlpDstEn    = AL_FALSE;
        SrcAutoEn   = AL_FALSE;
        DstAutoEn   = AL_FALSE;
        break;
    case AL_DMACAHB_TRANS_TYPE_6:
        LlpSrcEn    = AL_FALSE;
        LlpDstEn    = AL_TRUE;
        SrcAutoEn   = AL_FALSE;
        DstAutoEn   = AL_FALSE;
        break;
    case AL_DMACAHB_TRANS_TYPE_7:
        LlpSrcEn    = AL_FALSE;
        LlpDstEn    = AL_TRUE;
        SrcAutoEn   = AL_TRUE;
        DstAutoEn   = AL_FALSE;
        break;
    case AL_DMACAHB_TRANS_TYPE_8:
        LlpSrcEn    = AL_TRUE;
        LlpDstEn    = AL_FALSE;
        SrcAutoEn   = AL_FALSE;
        DstAutoEn   = AL_FALSE;
        break;
    case AL_DMACAHB_TRANS_TYPE_9:
        LlpSrcEn    = AL_TRUE;
        LlpDstEn    = AL_FALSE;
        SrcAutoEn   = AL_FALSE;
        DstAutoEn   = AL_TRUE;
        break;
    case AL_DMACAHB_TRANS_TYPE_10:
        LlpSrcEn    = AL_TRUE;
        LlpDstEn    = AL_TRUE;
        SrcAutoEn   = AL_FALSE;
        DstAutoEn   = AL_FALSE;
        break;
    default:
        return AL_DMACAHB_ERR_ILLEGAL_PARAM;
        break;
    }

    AlDmacAhb_ll_SetLlpSrcEn(BaseAddr, ChOffset, LlpSrcEn);
    AlDmacAhb_ll_SetLlpDstEn(BaseAddr, ChOffset, LlpDstEn);
    AlDmacAhb_ll_SetSrcAutoReload(BaseAddr, ChOffset, SrcAutoEn);
    AlDmacAhb_ll_SetDstAutoReload(BaseAddr, ChOffset, DstAutoEn);


    return AL_OK;
}

/**
 * This function sets the control register low part for a given DMA channel.
 *
 * @param Channel A pointer to the DMA channel structure.
 * @return AL_OK on success, error code on failure.
 */
AL_S32 AlDmacAhb_Dev_SetCtlLoReg(AL_DMACAHB_ChStruct *Channel)
{
    AL_ASSERT(Channel != AL_NULL, AL_DMACAHB_ERR_NULL_PTR);

    AL_U32 ChOffset = Channel->Param.ChBaseOffset;
    AL_REG BaseAddr = Channel->Dmac->BaseAddr;
    volatile AL_DMACAHB_CtlLoUnion CtlLo;

    CtlLo.Reg = AlDmacAhb_ll_ReadCtlLo(BaseAddr, ChOffset);
    CtlLo.Bit.IntEn         = Channel->Config.Intr.IsIntrEn;
    CtlLo.Bit.DstTransWidth = Channel->Config.DstTransWidth;
    CtlLo.Bit.SrcTransWidth = Channel->Config.SrcTransWidth;
    CtlLo.Bit.DstInc        = Channel->Config.DstAddrIncMode;
    CtlLo.Bit.SrcInc        = Channel->Config.SrcAddrIncMode;
    CtlLo.Bit.DstMsize      = Channel->Config.DstBurstLength;
    CtlLo.Bit.SrcMsize      = Channel->Config.SrcBurstLength;
    CtlLo.Bit.SrcGattterEn  = Channel->Config.SgrDsr.IsSrcGatherEn;
    CtlLo.Bit.DstScatterEn  = Channel->Config.SgrDsr.IsDstScatterEn;
    CtlLo.Bit.TtFc          = Channel->Config.Direction;
    CtlLo.Bit.DstMasterSel  = Channel->Config.DstMasterSel;
    CtlLo.Bit.SrcMasterSel  = Channel->Config.SrcMasterSel;
    AlDmacAhb_ll_WriteCtlLo(BaseAddr, ChOffset, CtlLo.Reg);

    return AL_OK;
}

/**
 * This function sets the configuration register low part for a given DMA channel.
 *
 * @param Channel A pointer to the DMA channel structure.
 * @return AL_OK on success, error code on failure.
 */
AL_S32 AlDmacAhb_Dev_SetCfgLoReg(AL_DMACAHB_ChStruct *Channel)
{
    AL_ASSERT(Channel != AL_NULL, AL_DMACAHB_ERR_NULL_PTR);

    AL_U32 ChOffset = Channel->Param.ChBaseOffset;
    AL_REG BaseAddr = Channel->Dmac->BaseAddr;
    volatile AL_DMACAHB_CfgLoUnion CfgLo;

    CfgLo.Reg = AlDmacAhb_ll_ReadCfgLo(BaseAddr, ChOffset);
    CfgLo.Bit.ChPrior   = Channel->Config.ChPrior;
    CfgLo.Bit.DstHsSel  = Channel->Config.HandShaking.DstHsSel;
    CfgLo.Bit.SrcHsSel  = Channel->Config.HandShaking.SrcHsSel;
    CfgLo.Bit.DstHsPol  = Channel->Config.HandShaking.DstHsPol;
    CfgLo.Bit.SrcHsPol  = Channel->Config.HandShaking.SrcHsPol;
    AlDmacAhb_ll_WriteCfgLo(BaseAddr, ChOffset, CfgLo.Reg);

    return AL_OK;
}

/**
 *
 * This function configures the high register of a DMA channel based on the channel's configuration settings.
 * It sets the FIFO mode, protection control, and source/destination peripherals for handshaking, if hardware handshaking is used.
 *
 * @param Channel Pointer to the DMA channel structure.
 * @return AL_OK on success, error code otherwise.
 * @param None
 */
AL_S32 AlDmacAhb_Dev_SetCfgHiReg(AL_DMACAHB_ChStruct *Channel)
{
    AL_ASSERT(Channel != AL_NULL, AL_DMACAHB_ERR_NULL_PTR);

    AL_U32 ChOffset = Channel->Param.ChBaseOffset;
    AL_REG BaseAddr = Channel->Dmac->BaseAddr;
    volatile AL_DMACAHB_CfgHiUnion CfgHi;

    CfgHi.Reg = AlDmacAhb_ll_ReadCfgHi(BaseAddr, ChOffset);
    CfgHi.Bit.FifoMode  = Channel->Config.FifoMode;
    CfgHi.Bit.ProtCtl   = Channel->Config.ProtCtl;
    if (Channel->Config.HandShaking.SrcHsSel == AL_DMACAHB_HAND_SHAKING_HARDWARE) {
        CfgHi.Bit.SrcPer = Channel->Config.HandShaking.SrcPer;
    }
    if (Channel->Config.HandShaking.DstHsSel == AL_DMACAHB_HAND_SHAKING_HARDWARE) {
        CfgHi.Bit.DstPer = Channel->Config.HandShaking.DstPer;
    }
    AlDmacAhb_ll_WriteCfgHi(BaseAddr, ChOffset, CfgHi.Reg);

    return AL_OK;
}

/**
 *
 * This function configures the scatter-gather settings for a DMA channel, enabling and setting the source gather and
 * destination scatter intervals and counts if they are enabled in the channel's configuration.
 *
 * @param Channel Pointer to the DMA channel structure.
 * @return AL_OK on success, error code otherwise.
 * @param None
 */
AL_S32 AlDmacAhb_Dev_SetSgrDsr(AL_DMACAHB_ChStruct *Channel)
{
    AL_ASSERT(Channel != AL_NULL, AL_DMACAHB_ERR_NULL_PTR);

    AL_U32 ChOffset = Channel->Param.ChBaseOffset;
    AL_REG BaseAddr = Channel->Dmac->BaseAddr;

    if (Channel->Config.SgrDsr.IsSrcGatherEn == AL_TRUE) {
        AlDmacAhb_ll_SetSgi(BaseAddr, ChOffset, Channel->Config.SgrDsr.SrcGatherInterval);
        AlDmacAhb_ll_SetSgc(BaseAddr, ChOffset, Channel->Config.SgrDsr.SrcGatherCount);
    }
    if (Channel->Config.SgrDsr.IsDstScatterEn == AL_TRUE) {
        AlDmacAhb_ll_SetDsi(BaseAddr, ChOffset, Channel->Config.SgrDsr.DstScatterInterval);
        AlDmacAhb_ll_SetDsc(BaseAddr, ChOffset, Channel->Config.SgrDsr.DstScatterCount);
    }

    return AL_OK;
}

/**
 *
 * This function reads the control information from the DMA channel's registers and fills the provided linked list item structure with this information.
 *
 * @param Channel Pointer to the DMA channel structure.
 * @param Lli Pointer to the linked list item structure to be filled.
 * @return AL_OK on success, error code otherwise.
 */
AL_S32 AlDmacAhb_Dev_FillLliWithCtl(AL_DMACAHB_ChStruct *Channel, AL_DMACAHB_LliStruct *Lli)
{
    AL_ASSERT((Channel != AL_NULL) && (Lli != AL_NULL), AL_DMACAHB_ERR_NULL_PTR);

    AL_U32 ChOffset = Channel->Param.ChBaseOffset;
    AL_REG BaseAddr = Channel->Dmac->BaseAddr;

    Lli->CtlLow.Reg = AlDmacAhb_ll_ReadCtlLo(BaseAddr, ChOffset);
    Lli->CtlHigh.Reg = AlDmacAhb_ll_ReadCtlHi(BaseAddr, ChOffset);

    return AL_OK;
}

#ifdef ENABLE_MMU
/**
 * This function flush src addr data and invlidate dst addr data for sync
 * @param   Channel is pointer to AL_DMACAHB_ChStruct
 * @return
 *          - AL_DMACAHB_ERR_NULL_PTR Channel is NULL
 *          - AL_DMACAHB_ERR_ADDR_NOT_ALIGN src or dst address not align with their trans width
 *          - AL_DMACAHB_ERR_STATE_NOT_READY channel not ready
 *          - AL_OK start success
 * @note
*/
static AL_S32 AlDmacahb_Dev_FlushAndInvalidateData(AL_DMACAHB_ChStruct *Channel)
{
    AL_ASSERT(Channel != AL_NULL, AL_DMACAHB_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;
    AL_U32 TransSize = 0;
    AL_U32 SrcAddr = 0;
    AL_U32 DstAddr = 0;
    AL_DMACAHB_ChTransStruct *Trans = &Channel->Trans;
    AL_DMACAHB_LliStruct *CurLli = (AL_DMACAHB_LliStruct *)Channel->Trans.Lli;

    switch (Channel->Config.TransType)
    {
    case AL_DMACAHB_TRANS_TYPE_1:
    case AL_DMACAHB_TRANS_TYPE_5:
        SrcAddr = Trans->SrcAddr;
        DstAddr = Trans->DstAddr;
        TransSize = Trans->TransSize * (1 << Channel->Config.SrcTransWidth);
        AlCache_FlushAndInvalidateDiffDcacheRange(SrcAddr, SrcAddr + TransSize, DstAddr, DstAddr + TransSize);
        break;
    case AL_DMACAHB_TRANS_TYPE_2:
        SrcAddr = Trans->SrcAddr;
        DstAddr = Trans->DstAddr;
        TransSize = Trans->TransSize * (1 << Channel->Config.SrcTransWidth);
        /* Also need user invalidate dst addr after every block trans done */
        AlCache_FlushAndInvalidateDiffDcacheRange(SrcAddr, SrcAddr + TransSize * Trans->ReloadCountNum,
                                              DstAddr, DstAddr + TransSize);
        break;
    case AL_DMACAHB_TRANS_TYPE_3:
        SrcAddr = Trans->SrcAddr;
        DstAddr = Trans->DstAddr;
        TransSize = Trans->TransSize * (1 << Channel->Config.SrcTransWidth);
        /* Also need user flush src addr after every block trans done */
        AlCache_FlushAndInvalidateDiffDcacheRange(SrcAddr, SrcAddr + TransSize,
                                              DstAddr, DstAddr + TransSize * Trans->ReloadCountNum);
        break;
    case AL_DMACAHB_TRANS_TYPE_4:
        SrcAddr = Trans->SrcAddr;
        DstAddr = Trans->DstAddr;
        TransSize = Trans->TransSize * (1 << Channel->Config.SrcTransWidth);
        /* Also need user flush src addr and invalidate dst addr after every block trans done */
        AlCache_FlushAndInvalidateDiffDcacheRange(SrcAddr, SrcAddr + TransSize, DstAddr, DstAddr + TransSize);
        break;
    case AL_DMACAHB_TRANS_TYPE_6:
        SrcAddr = Trans->SrcAddr;
        TransSize = CurLli->CtlHigh.Bit.BlockTransSize * (1 << CurLli->CtlLow.Bit.SrcTransWidth);
        while (CurLli != AL_NULL) {
            AlCache_FlushDcacheRange((AL_UINTPTR)CurLli, (AL_UINTPTR)(CurLli + sizeof(AL_DMACAHB_LliStruct)));
            DstAddr = CurLli->DstAddr;
            AlCache_FlushAndInvalidateDiffDcacheRange(SrcAddr, SrcAddr + TransSize, DstAddr, DstAddr + TransSize);
            SrcAddr += TransSize;
            CurLli = (AL_DMACAHB_LliStruct *)(AL_UINTPTR)CurLli->LlpNext;
        }
        break;
    case AL_DMACAHB_TRANS_TYPE_8:
        DstAddr = Trans->DstAddr;
        TransSize = CurLli->CtlHigh.Bit.BlockTransSize * (1 << CurLli->CtlLow.Bit.SrcTransWidth);
        while (CurLli != AL_NULL) {
            AlCache_FlushDcacheRange((AL_UINTPTR)CurLli, (AL_UINTPTR)(CurLli + sizeof(AL_DMACAHB_LliStruct)));
            SrcAddr = CurLli->SrcAddr;
            AlCache_FlushAndInvalidateDiffDcacheRange(SrcAddr, SrcAddr + TransSize, DstAddr, DstAddr + TransSize);
            DstAddr += TransSize;
            CurLli = (AL_DMACAHB_LliStruct *)(AL_UINTPTR)CurLli->LlpNext;
        }
        break;
    case AL_DMACAHB_TRANS_TYPE_10:
        while (CurLli != AL_NULL) {
            AlCache_FlushDcacheRange((AL_UINTPTR)CurLli, (AL_UINTPTR)(CurLli + sizeof(AL_DMACAHB_LliStruct)));
            SrcAddr = CurLli->SrcAddr;
            DstAddr = CurLli->DstAddr;
            TransSize = CurLli->CtlHigh.Bit.BlockTransSize * (1 << CurLli->CtlLow.Bit.SrcTransWidth);
            AlCache_FlushAndInvalidateDiffDcacheRange(SrcAddr, SrcAddr + TransSize, DstAddr, DstAddr + TransSize);
            CurLli = (AL_DMACAHB_LliStruct *)(AL_UINTPTR)CurLli->LlpNext;
        }
        break;
    case AL_DMACAHB_TRANS_TYPE_7:
        SrcAddr = Trans->SrcAddr;
        TransSize = CurLli->CtlHigh.Bit.BlockTransSize * (1 << CurLli->CtlLow.Bit.SrcTransWidth);
        /* Also need user flush after every block trans done */
        AlCache_FlushDcacheRange(SrcAddr, SrcAddr + TransSize);
        while (CurLli != AL_NULL) {
            AlCache_FlushDcacheRange((AL_UINTPTR)CurLli, (AL_UINTPTR)(CurLli + sizeof(AL_DMACAHB_LliStruct)));
            DstAddr = CurLli->DstAddr;
            AlCache_InvalidateDcacheRange(DstAddr, DstAddr + TransSize);
            CurLli = (AL_DMACAHB_LliStruct *)(AL_UINTPTR)CurLli->LlpNext;
        }
        break;
    case AL_DMACAHB_TRANS_TYPE_9:
        DstAddr = Trans->DstAddr;
        TransSize = CurLli->CtlHigh.Bit.BlockTransSize * (1 << CurLli->CtlLow.Bit.SrcTransWidth);
        /* Also need user invalidate after every block trans done */
        AlCache_InvalidateDcacheRange(DstAddr, DstAddr + TransSize);
        while (CurLli != AL_NULL) {
            AlCache_FlushDcacheRange((AL_UINTPTR)CurLli, (AL_UINTPTR)(CurLli + sizeof(AL_DMACAHB_LliStruct)));
            SrcAddr = CurLli->SrcAddr;
            AlCache_FlushDcacheRange(SrcAddr, SrcAddr + TransSize);
            CurLli = (AL_DMACAHB_LliStruct *)(AL_UINTPTR)CurLli->LlpNext;
        }
        break;
    default:
        return AL_DMACAHB_ERR_ILLEGAL_PARAM;
        break;
    }

    return Ret;
}

static AL_S32 AlDmacahb_Dev_CheckAddrAlign(AL_DMACAHB_ChStruct *Channel)
{
    AL_DMACAHB_ChTransStruct *Trans = &Channel->Trans;
    AL_DMACAHB_LliStruct *Lli = Trans->Lli;

    if (Lli != AL_NULL) {
        if (((AL_U32)(AL_UINTPTR)Trans->Lli) & 0x3F) {
            return AL_DMACAHB_ERR_ADDR_NOT_ALIGN;
        }

        if (Channel->Config.HandShaking.SrcHsSel == AL_DMACAHB_HAND_SHAKING_SOFTWARE ||
            Channel->Config.HandShaking.SrcHsSel == AL_DMACAHB_HAND_SHAKING_HARDWARE) {
            return AL_OK;
        }

        if (Channel->Config.Direction == AL_DMACAHB_TT_FC_MEM2MEM) {
            while (Lli) {
                if ((Lli->SrcAddr | Lli->DstAddr) & 0x3F) {
                    return AL_DMACAHB_ERR_ADDR_NOT_ALIGN;
                }
                Lli = (AL_DMACAHB_LliStruct *)(AL_UINTPTR)Lli->LlpNext;
            }
        } else if (Channel->Config.Direction == AL_DMACAHB_TT_FC_MEM2PER) {
            while (Lli) {
                if (Lli->SrcAddr & 0x3F) {
                    return AL_DMACAHB_ERR_ADDR_NOT_ALIGN;
                }
                Lli = (AL_DMACAHB_LliStruct *)(AL_UINTPTR)Lli->LlpNext;
            }
        } else if (Channel->Config.Direction == AL_DMACAHB_TT_FC_PER2MEM) {
            while (Lli) {
                if (Lli->DstAddr & 0x3F) {
                    return AL_DMACAHB_ERR_ADDR_NOT_ALIGN;
                }
                Lli = (AL_DMACAHB_LliStruct *)(AL_UINTPTR)Lli->LlpNext;
            }
        } else {
            AL_LOG(AL_LOG_LEVEL_DEBUG, "Unsupport mode\r\n");
            return AL_DMACAHB_ERR_UNSUPPORT_MODE;
        }
    } else {
        if (Channel->Config.Direction == AL_DMACAHB_TT_FC_MEM2MEM) {
            if ((Trans->SrcAddr | Trans->DstAddr) & 0x3F) {
                return AL_DMACAHB_ERR_ADDR_NOT_ALIGN;
            }
        } else if (Channel->Config.Direction == AL_DMACAHB_TT_FC_MEM2PER) {
            if (Trans->SrcAddr & 0x3F) {
                return AL_DMACAHB_ERR_ADDR_NOT_ALIGN;
            }
        } else if (Channel->Config.Direction == AL_DMACAHB_TT_FC_PER2MEM) {
            if (Trans->DstAddr & 0x3F) {
                return AL_DMACAHB_ERR_ADDR_NOT_ALIGN;
            }
        } else {
            AL_LOG(AL_LOG_LEVEL_DEBUG, "Unsupport mode\r\n");
            return AL_DMACAHB_ERR_UNSUPPORT_MODE;
        }
    }

    return AL_OK;
}
#endif

/**
 *
 * This function performs cache operations to ensure data coherency for DMA operations. It flushes the source address data from the cache and
 * invalidates the destination address data in the cache. The operation varies depending on the transaction type configured for the channel.
 *
 * @param Channel Pointer to the DMA channel structure.
 * @return AL_OK on success,
 *         AL_DMACAHB_ERR_NULL_PTR if the channel is NULL,
 *         AL_DMACAHB_ERR_ADDR_NOT_ALIGN if the source or destination address is not aligned,
 *         AL_DMACAHB_ERR_STATE_NOT_READY if the channel is not ready, or other error codes as appropriate.
 */
AL_S32 AlDmacAhb_Dev_SetTransParams(AL_DMACAHB_ChStruct *Channel)
{
    AL_ASSERT(Channel != AL_NULL, AL_DMACAHB_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;
    AL_U32 ChOffset = Channel->Param.ChBaseOffset;
    AL_REG BaseAddr = Channel->Dmac->BaseAddr;
    AL_DMACAHB_ChTransStruct *Trans = &Channel->Trans;
    AL_DMACAHB_ChStateEnum State;

    Ret = AlDmacAhb_Dev_TransTypeToState(Channel->Config.TransType, &State);
    if (Ret != AL_OK) {
        return Ret;
    }

    if (State == AL_DMACAHB_STATE_LLP_MODE_BUSY || State == AL_DMACAHB_STATE_LLP_RELOAD_MODE_BUSY) {
        if (Trans->Lli == AL_NULL) {
            return AL_DMACAHB_ERR_NULL_PTR;
        } else if (((AL_U32)(AL_UINTPTR)Trans->Lli) & 0x3){
            return AL_DMACAHB_ERR_ADDR_NOT_ALIGN;
        }
    } else {
        if ((Trans->SrcAddr & ((1 << (Channel->Config.SrcTransWidth)) - 1)) ||
            (Trans->DstAddr & ((1 << (Channel->Config.DstTransWidth)) - 1))) {
            return AL_DMACAHB_ERR_ADDR_NOT_ALIGN;
        }
    }

#ifdef ENABLE_MMU
    Ret = AlDmacahb_Dev_CheckAddrAlign(Channel);
    AL_ASSERT(Ret == AL_OK, Ret);
#endif

    if (!AlDmacAhb_Dev_GetState(Channel, AL_DMACAHB_STATE_READY)) {
        return AL_DMACAHB_ERR_STATE_NOT_READY;
    }

    if (AlDmacAhb_Dev_GetState(Channel, (AL_DMACAHB_STATE_SINGLE_MODE_BUSY | AL_DMACAHB_STATE_RELOAD_MODE_BUSY |
                                         AL_DMACAHB_STATE_LLP_MODE_BUSY | AL_DMACAHB_STATE_LLP_RELOAD_MODE_BUSY))) {
        return AL_DMACAHB_ERR_TRANS_BUSY;
    }

    AlDmacAhb_Dev_SetState(Channel, State);

#ifdef ENABLE_MMU
    Ret = AlDmacahb_Dev_FlushAndInvalidateData(Channel);
    AL_ASSERT(Ret == AL_OK, Ret);
#endif

    if ((State == AL_DMACAHB_STATE_LLP_MODE_BUSY) || (State == AL_DMACAHB_STATE_LLP_RELOAD_MODE_BUSY)) {
        AlDmacAhb_ll_SetLinkStartAddr(BaseAddr, ChOffset, (AL_REG)Trans->Lli);
        AlDmacAhb_ll_SetLms(BaseAddr, ChOffset, Channel->Config.ListMasterSel);
        /* Write these register for contiguous src/dst */
        AlDmacAhb_ll_WriteSrcAddr(BaseAddr, ChOffset, Trans->SrcAddr);
        AlDmacAhb_ll_WriteDstAddr(BaseAddr, ChOffset, Trans->DstAddr);
    } else {
        if (Channel->Config.HandShaking.SrcHsSel == AL_DMACAHB_HAND_SHAKING_SOFTWARE) {
            if (Channel->Config.SrcBurstLength == AL_DMACAHB_MSIZE_1) {
                Trans->SrcBurstCnt = Trans->TransSize;
            } else {
                Trans->SrcBurstCnt = Trans->TransSize >> (Channel->Config.SrcBurstLength + 1);
                Trans->SrcSingleCnt = Trans->TransSize & ((1 << (Channel->Config.SrcBurstLength + 1)) - 1);
            }
            AL_LOG(AL_LOG_LEVEL_DEBUG, "Burst Cnt: %d, Single Cnt: %d\r\n", Trans->SrcBurstCnt, Trans->SrcSingleCnt);
        }
        AlDmacAhb_ll_WriteSrcAddr(BaseAddr, ChOffset, Trans->SrcAddr);
        AlDmacAhb_ll_WriteDstAddr(BaseAddr, ChOffset, Trans->DstAddr);
        AlDmacAhb_ll_SetBlkTransSize(BaseAddr, ChOffset, Trans->TransSize);
    }

    Ret = AlDmacAhb_Dev_SetTransType(Channel);

    return Ret;
}

/**
 * This function checks the current state of the channel and decides whether to initiate a burst transfer or a single transfer based on the channel's mode and remaining transfer count.
 *
 * @param Channel Pointer to the DMA channel structure.
 * @return AL_OK on success, error code otherwise.
 */
AL_S32 AlDmacAhb_Dev_SoftRequest(AL_DMACAHB_ChStruct *Channel)
{
    AL_S32 Ret = AL_OK;

    AL_ASSERT(Channel != AL_NULL, AL_DMACAHB_ERR_NULL_PTR);

    if (AlDmacAhb_Dev_GetState(Channel, (AL_DMACAHB_STATE_LLP_MODE_BUSY | AL_DMACAHB_STATE_LLP_RELOAD_MODE_BUSY))) {
        AL_LOG(AL_LOG_LEVEL_DEBUG, "Req a burst trans in llp mode\r\n");
        AlDmacAhb_ll_SetSrcReqAct(Channel->Dmac->BaseAddr, Channel->Param.ChMask, AL_TRUE);
        AlDmacAhb_ll_SetSrcSglReqAct(Channel->Dmac->BaseAddr, Channel->Param.ChMask, AL_TRUE);
    } else {
        if (Channel->Trans.SrcBurstCnt) {
            AL_LOG(AL_LOG_LEVEL_DEBUG, "Req a burst trans in single mode\r\n");
            Channel->Trans.SrcBurstCnt--;
            AlDmacAhb_ll_SetSrcReqAct(Channel->Dmac->BaseAddr, Channel->Param.ChMask, AL_TRUE);
            AlDmacAhb_ll_SetSrcSglReqAct(Channel->Dmac->BaseAddr, Channel->Param.ChMask, AL_TRUE);
        } else {
            if (Channel->Trans.SrcSingleCnt) {
                AL_LOG(AL_LOG_LEVEL_DEBUG, "Req a single trans in single mode\r\n");
                Channel->Trans.SrcSingleCnt--;
                AlDmacAhb_ll_SetSrcSglReqAct(Channel->Dmac->BaseAddr, Channel->Param.ChMask, AL_TRUE);
            }
        }
    }

    return Ret;
}

/**
 * This function sets the channel's transfer parameters and enables the channel for transfer.
 *
 * @param Channel Pointer to the DMA channel structure.
 * @return AL_OK on success, error code otherwise.
 */
AL_S32 AlDmacAhb_Dev_Start(AL_DMACAHB_ChStruct *Channel)
{
    AL_S32 Ret;

    AL_ASSERT(Channel != AL_NULL, AL_DMACAHB_ERR_NULL_PTR);

    Ret = AlDmacAhb_Dev_SetTransParams(Channel);
    if (Ret != AL_OK) {
        return Ret;
    }

    AlDmacAhb_ll_SetChannelEn(Channel->Dmac->BaseAddr, Channel->Param.ChMask, AL_TRUE);

    return AL_OK;
}

/**
 * This function checks each field of the configuration structures to ensure they match exactly. It is used to avoid reinitializing a channel with the same configuration.
 *
 * @param Dst Destination channel initialization structure.
 * @param Src Source channel initialization structure.
 * @return AL_TRUE if the configurations are identical, AL_FALSE otherwise.
 */
static inline AL_BOOL AlDmacahb_Dev_IsSameInitConfig(AL_DMACAHB_ChInitStruct Dst, AL_DMACAHB_ChInitStruct Src)
{
    if (Dst.TransType != Src.TransType || Dst.SrcTransWidth != Src.SrcTransWidth || Dst.DstTransWidth != Src.DstTransWidth ||
        Dst.SrcAddrIncMode != Src.SrcAddrIncMode || Dst.DstAddrIncMode != Src.DstAddrIncMode ||
        Dst.SrcBurstLength != Src.SrcBurstLength || Dst.DstBurstLength != Src.DstBurstLength ||
        Dst.Direction != Src.Direction || Dst.ListMasterSel != Src.ListMasterSel ||
        Dst.SrcMasterSel != Src.SrcMasterSel || Dst.DstMasterSel != Src.DstMasterSel ||
        Dst.ChPrior != Src.ChPrior || Dst.FifoMode != Src.FifoMode || Dst.ProtCtl != Src.ProtCtl) {
        return AL_FALSE;
    }

    if (Dst.Intr.IsIntrEn == Src.Intr.IsIntrEn) {
        if (Dst.Intr.IsIntrEn == AL_TRUE && Dst.Intr.IntrUnMask != Src.Intr.IntrUnMask) {
            return AL_FALSE;
        }
    } else {
        return AL_FALSE;
    }

    if (Dst.HandShaking.SrcHsSel == Src.HandShaking.SrcHsSel) {
        if (Dst.HandShaking.SrcHsSel == AL_DMACAHB_HAND_SHAKING_HARDWARE &&
            (Dst.HandShaking.SrcHsPol != Src.HandShaking.SrcHsPol ||
             Dst.HandShaking.SrcPer != Src.HandShaking.SrcPer)) {
            return AL_FALSE;
        }
    } else {
        return AL_FALSE;
    }

    if (Dst.HandShaking.DstHsSel == Src.HandShaking.DstHsSel) {
        if (Dst.HandShaking.DstHsSel == AL_DMACAHB_HAND_SHAKING_HARDWARE &&
            (Dst.HandShaking.DstHsPol != Src.HandShaking.DstHsPol ||
             Dst.HandShaking.DstPer != Src.HandShaking.DstPer)) {
            return AL_FALSE;
        }
    } else {
        return AL_FALSE;
    }

    if (Dst.SgrDsr.IsSrcGatherEn == Src.SgrDsr.IsSrcGatherEn) {
        if (Dst.SgrDsr.IsSrcGatherEn == AL_TRUE && (Dst.SgrDsr.SrcGatherCount != Src.SgrDsr.SrcGatherCount ||
                                                    Dst.SgrDsr.SrcGatherInterval != Src.SgrDsr.SrcGatherInterval)) {
            return AL_FALSE;
        }
    } else {
        return AL_FALSE;
    }

    if (Dst.SgrDsr.IsDstScatterEn == Src.SgrDsr.IsDstScatterEn) {
        if (Dst.SgrDsr.IsDstScatterEn == AL_TRUE && (Dst.SgrDsr.DstScatterCount != Src.SgrDsr.DstScatterCount ||
                                                    Dst.SgrDsr.DstScatterInterval != Src.SgrDsr.DstScatterInterval)) {
            return AL_FALSE;
        }
    } else {
        return AL_FALSE;
    }

    return AL_TRUE;
}

/**
 * This function sets up the DMA channel based on the provided configurations, including setting the base address, device ID, and other parameters. It also checks if the channel is already initialized with the same configuration to avoid redundancy.
 *
 * @param Channel Pointer to the DMA channel structure.
 * @param HwConfig Pointer to the hardware configuration structure.
 * @param InitConfig Pointer to the initialization configuration structure. If NULL, default configuration is used.
 * @return AL_OK on success, error code otherwise.
 */
AL_S32 AlDmacAhb_Dev_Init(AL_DMACAHB_ChStruct *Channel, AL_DMACAHB_HwConfigStruct *HwConfig,
                          AL_DMACAHB_ChInitStruct *InitConfig)
{
    AL_S32 Ret = AL_OK;

    AL_ASSERT((Channel != AL_NULL) && (HwConfig != AL_NULL), AL_DMACAHB_ERR_NULL_PTR);

    if (AlDmacAhb_Dev_GetState(Channel, AL_DMACAHB_STATE_READY)) {
        if (InitConfig == AL_NULL || AlDmacahb_Dev_IsSameInitConfig(Channel->Config, *InitConfig)) {
            return AL_OK;
        }
    }

    Channel->Config = (InitConfig == AL_NULL) ? AlDmacAhb_ChDefInitConfig : (*InitConfig);
    Channel->Dmac   = &AlDmacAhb_DmacInstance[HwConfig->DeviceId];

    if (Channel->Dmac->State.DmacEn == AL_FALSE) {
        Channel->Dmac->BaseAddr     = HwConfig->BaseAddress;
        Channel->Dmac->DevId        = HwConfig->DeviceId;
        Channel->Dmac->IntrId       = HwConfig->IntrId;
        Channel->Dmac->ChannelNum   = HwConfig->ChannelNum;
        Channel->Dmac->LockAddress  = HwConfig->LockAddress;
        Channel->Dmac->ChStateAddr  = HwConfig->ChStateAddr;
        AlDmacAhb_ll_SetDmaCfgEn(Channel->Dmac->BaseAddr, AL_TRUE);
        Channel->Dmac->State.DmacEn = AL_TRUE;
    }

    Channel->Param = AlDmacAhb_ChParam[Channel->Config.Id];

    Channel->Dmac->State.ChEn |= AlDmacAhb_ChParam[Channel->Config.Id].ChMask;
    Channel->Dmac->Channel[Channel->Config.Id] = Channel;

    AlDmacAhb_Dev_ClrChAllIntr(Channel);
    AlDmacAhb_Dev_UnmaskChIntr(Channel);
    AlDmacAhb_Dev_SetCtlLoReg(Channel);
    AlDmacAhb_Dev_SetCfgLoReg(Channel);
    AlDmacAhb_Dev_SetCfgHiReg(Channel);
    AlDmacAhb_Dev_SetSgrDsr(Channel);

    AlDmacAhb_Dev_SetState(Channel, AL_DMACAHB_STATE_READY);

    return Ret;
}

/**
 * This function disables the channel, clears its configuration, and resets the associated DMA controller if no other channels are active.
 *
 * @param Channel Pointer to the DMA channel structure.
 * @return AL_OK on success, error code otherwise.
 */
AL_S32 AlDmacAhb_Dev_DeInit(AL_DMACAHB_ChStruct *Channel)
{
    AL_ASSERT(Channel != AL_NULL, AL_DMACAHB_ERR_NULL_PTR);

    /* Mask all unmasked intr */
    AlDmacAhb_Dev_MaskChIntr(Channel);
    AlDmacAhb_Dev_ReleaseCh(Channel);
    /* Firstly, clear channel status in dmac struct */
    Channel->Dmac->State.ChEn &= ~(Channel->Param.ChMask);
    if (!Channel->Dmac->State.ChEn) {
        /* Only one channel enabled, reset dmac */
        AlDmacAhb_ll_SetDmaCfgEn(Channel->Dmac->BaseAddr, AL_FALSE);
        memset(Channel->Dmac, 0, sizeof(AL_DMACAHB_DmacStruct));
    }

    /* Reset channel struct and unlink channel with handle */
    memset(Channel, 0, sizeof(AL_DMACAHB_ChStruct));

    return AL_OK;
}

/**
 * This function sets a callback to be invoked on specific events related to the DMA channel. If a callback is already registered, it will be replaced.
 *
 * @param Channel Pointer to the DMA channel structure.
 * @param CallBack Function pointer to the callback function.
 * @param CallBackRef User-defined reference passed to the callback function.
 * @return AL_OK on success, error code otherwise.
 */
AL_S32 AlDmacAhb_Dev_RegisterChEventCallBack(AL_DMACAHB_ChStruct *Channel, AL_DMACAHB_ChEventCallBack CallBack,
                                             AL_VOID *CallBackRef)
{
    AL_ASSERT((Channel != AL_NULL) && (CallBack != AL_NULL), AL_DMACAHB_ERR_NULL_PTR);

    if (Channel->EventCallBack != AL_NULL) {

#ifdef DMACAHB_DEBUG
        AL_LOG(AL_LOG_LEVEL_WARNING, "dmacahb=%p duplicate register callback: replace old:%p with New: %p\r\n",
               Channel, Channel->EventCallBack, CallBack);
#endif
    }

    Channel->EventCallBack      = CallBack;
    Channel->EventCallBackRef   = CallBackRef;

    return AL_OK;
}

/**
 * This function removes the currently registered callback function for the specified DMA channel.
 *
 * @param Channel Pointer to the DMA channel structure.
 * @return AL_OK on success, error code otherwise.
 */
AL_S32 AlDmacAhb_Dev_UnRegisterChEventCallBack(AL_DMACAHB_ChStruct *Channel)
{
    AL_ASSERT(Channel != AL_NULL, AL_DMACAHB_ERR_NULL_PTR);

    Channel->EventCallBack = (AL_DMACAHB_ChEventCallBack)AL_NULL;

    return AL_OK;
}

/**
 * This function returns the current state of the specified DMA channel, indicating whether it matches the queried state.
 *
 * @param Channel Pointer to the DMA channel structure.
 * @param State The state to check against the channel's current state.
 * @return AL_TRUE if the current state matches the queried state, AL_FALSE otherwise.
 */
AL_BOOL AlDmacAhb_Dev_GetState(AL_DMACAHB_ChStruct *Channel, AL_DMACAHB_ChStateEnum State)
{
    return ((Channel->State & State) ? AL_TRUE : AL_FALSE);
}

/**
 * This function adds the specified state to the channel's current state.
 *
 * @param Channel Pointer to the DMA channel structure.
 * @param State The state to be added to the channel's current state.
 * @return None.
 */
AL_VOID AlDmacAhb_Dev_SetState(AL_DMACAHB_ChStruct *Channel, AL_DMACAHB_ChStateEnum State)
{
    Channel->State |= State;
}

/**
 * This function removes the specified state from the channel's current state.
 *
 * @param Channel Pointer to the DMA channel structure.
 * @param State The state to be removed from the channel's current state.
 * @return None.
 */
AL_VOID AlDmacAhb_Dev_ClrState(AL_DMACAHB_ChStruct *Channel, AL_DMACAHB_ChStateEnum State)
{
    Channel->State &= ~State;
}

/**
 * This function is called when a DMA transfer is complete. It updates the state of the channel,
 * clears the state based on the transfer type, and invokes the event callback associated with the channel.
 *
 * @param Channel Pointer to the DMA channel structure.
 * @return None.
 */
static AL_VOID AlDmacAhb_Dev_TransCompHandler(AL_DMACAHB_ChStruct *Channel)
{
    AL_DMACAHB_ChStateEnum State;
    AL_LOG(AL_LOG_LEVEL_DEBUG, "Dmacahb Channel %d trans complete!\r\n", Channel->Config.Id);

    /* multi-block trans done with trans complete intr */
    AlDmacAhb_Dev_TransTypeToState(Channel->Config.TransType, &State);
    AlDmacAhb_Dev_ClrState(Channel, State);

    AL_DMACAHB_EventStruct Event = {
        .EventId    = AL_DMACAHB_EVENT_TRANS_COMP,
        .EventData  = 0
    };
    Channel->EventCallBack(&Event, Channel->EventCallBackRef);
}

/**
 * This function is called when a block transfer is complete. It updates the state of the channel,
 * manages reload operations if necessary, and invokes the event callback associated with the channel.
 *
 * @param Channel Pointer to the DMA channel structure.
 * @return None.
 */
static AL_VOID AlDmacAhb_Dev_BlockTransCompHandler(AL_DMACAHB_ChStruct *Channel)
{
    AL_DMACAHB_ChStateEnum State = AL_DMACAHB_STATE_NOT_INIT;
    AL_DMACAHB_EventStruct Event;
    AL_LOG(AL_LOG_LEVEL_DEBUG, "Dmacahb Channel %d block trans complete!\r\n", Channel->Config.Id);

    AlDmacAhb_Dev_TransTypeToState(Channel->Config.TransType, &State);
    /* In reload mode, before the last trans, set reload_src and reload_dst to AL_FALSE */
    if (State == AL_DMACAHB_STATE_RELOAD_MODE_BUSY || State == AL_DMACAHB_STATE_LLP_RELOAD_MODE_BUSY) {
        Channel->Trans.ReloadCount++;
        if (Channel->Trans.ReloadCountNum != AL_DMACAHB_RELOAD_CNT_MAX) {
            if (Channel->Trans.ReloadCount == Channel->Trans.ReloadCountNum) {
                AlDmacAhb_Dev_ClrState(Channel, State);
                Event.EventId = AL_DMACAHB_EVENT_BLOCK_TRANS_COMP;
                Event.EventData = 0;
                Channel->EventCallBack(&Event, Channel->EventCallBackRef);
            } else if ((Channel->Trans.ReloadCount == (Channel->Trans.ReloadCountNum - 1))) {
                AL_BOOL IsLastTransSet = AL_TRUE;
                AlDmacAhb_Dev_IoCtl(Channel, AL_DMACAHB_IOCTL_SET_RELOAD_LAST_TRANS, &IsLastTransSet);
            }
        } else {
            Event.EventId = AL_DMACAHB_EVENT_RELOAD;
            Event.EventData = Channel->Trans.ReloadCount;
            Channel->EventCallBack(&Event, Channel->EventCallBackRef);
        }
    }
}

/**
 * This function is called when a source transfer is complete. It invokes the event callback associated with the channel.
 *
 * @param Channel Pointer to the DMA channel structure.
 * @return None.
 */
static AL_VOID AlDmacAhb_Dev_SrcTransCompHandler(AL_DMACAHB_ChStruct *Channel)
{
    AL_LOG(AL_LOG_LEVEL_DEBUG, "Dmacahb Channel %d block src trans complete!\r\n", Channel->Config.Id);
    AL_DMACAHB_EventStruct Event = {
        .EventId    = AL_DMACAHB_EVENT_SRC_TRANS_COMP,
        .EventData  = 0
    };
    Channel->EventCallBack(&Event, Channel->EventCallBackRef);
}

/**
 * Handles the completion of a destination transfer for a specific channel.
 * This function is called when a destination transfer is complete. It invokes the event callback associated with the channel.
 *
 * @param Channel Pointer to the DMA channel structure.
 * @return None.
 */
static AL_VOID AlDmacAhb_Dev_DstTransCompHandler(AL_DMACAHB_ChStruct *Channel)
{
    AL_LOG(AL_LOG_LEVEL_DEBUG, "Dmacahb Channel %d block dst trans complete!\r\n", Channel->Config.Id);
    AL_DMACAHB_EventStruct Event = {
        .EventId    = AL_DMACAHB_EVENT_DST_TRANS_COMP,
        .EventData  = 0
    };
    Channel->EventCallBack(&Event, Channel->EventCallBackRef);
}

/**
 * This function is called when an error occurs in the DMA operation. It invokes the event callback associated with the channel.
 *
 * @param Channel Pointer to the DMA channel structure.
 * @return None.
 */
static AL_VOID AlDmacAhb_Dev_ErrHandler(AL_DMACAHB_ChStruct *Channel)
{
    AL_LOG(AL_LOG_LEVEL_DEBUG, "DmacAhb ErrHandler\r\n");
    AL_DMACAHB_EventStruct Event = {
        .EventId    = AL_DMACAHB_EVENT_ERR,
        .EventData  = 0
    };
    Channel->EventCallBack(&Event, Channel->EventCallBackRef);
}

/**
 * This function is called when a DMA interrupt occurs. It checks the type of interrupt and calls the appropriate handler function for each active channel.
 *
 * @param Instance Pointer to the DMA instance structure.
 * @return None.
 */
AL_VOID AlDmacAhb_Dev_IntrHandler(AL_VOID *Instance)
{
    AL_DMACAHB_DmacStruct *Dmac = (AL_DMACAHB_DmacStruct *)Instance;
    AL_U32 IntrStatus = AlDmacAhb_ll_ReadStatusIntr(Dmac->BaseAddr);
    /* TODO: think sync with kernel */
    if (AL_DMACAHB_TFR_INTR(IntrStatus)) {
        AL_U32 TfrStatus = AlDmacAhb_ll_ReadStatusTfr(Dmac->BaseAddr);
        for (AL_U32 i = 0; i < Dmac->ChannelNum; i++) {
            if (TfrStatus & (0x1 << i)) {
                AlDmacAhb_Dev_TransCompHandler(Dmac->Channel[i]);
                AlDmacAhb_ll_WriteClearTfr(Dmac->BaseAddr, (0x1 << i));
            }
        }
    }

    if (AL_DMACAHB_BLOCK_INTR(IntrStatus)) {
        AL_U32 BlockStatus = AlDmacAhb_ll_ReadStatusBlock(Dmac->BaseAddr);
        for (AL_U32 i = 0; i < Dmac->ChannelNum; i++) {
            if (BlockStatus & (0x1 << i)) {
                AlDmacAhb_Dev_BlockTransCompHandler(Dmac->Channel[i]);
                AlDmacAhb_ll_WriteClearBlock(Dmac->BaseAddr, (0x1 << i));
            }
        }
    }

    if (AL_DMACAHB_SRCT_INTR(IntrStatus)) {
        AL_U32 SrctStatus = AlDmacAhb_ll_ReadStatusSrcTran(Dmac->BaseAddr);
        for (AL_U32 i = 0; i < Dmac->ChannelNum; i++) {
            if (SrctStatus & (0x1 << i)) {
                AlDmacAhb_Dev_SrcTransCompHandler(Dmac->Channel[i]);
                AlDmacAhb_ll_WriteClearSrcTran(Dmac->BaseAddr, (0x1 << i));
            }
        }
    }

    if (AL_DMACAHB_DSTT_INTR(IntrStatus)) {
        AL_U32 DsttStatus = AlDmacAhb_ll_ReadStatusDstTran(Dmac->BaseAddr);
        for (AL_U32 i = 0; i < Dmac->ChannelNum; i++) {
            if (DsttStatus & (0x1 << i)) {
                AlDmacAhb_Dev_DstTransCompHandler(Dmac->Channel[i]);
                AlDmacAhb_ll_WriteClearDstTran(Dmac->BaseAddr, (0x1 << i));
            }
        }
    }

    if (AL_DMACAHB_ERR_INTR(IntrStatus)) {  /* TODO: bus error */
        AL_U32 ErrStatus = AlDmacAhb_ll_ReadStatusErr(Dmac->BaseAddr);
        for (AL_U32 i = 0; i < Dmac->ChannelNum; i++) {
            if (ErrStatus & (0x1 << i)) {
                AlDmacAhb_Dev_ErrHandler(Dmac->Channel[i]);
                AlDmacAhb_ll_WriteClearErr(Dmac->BaseAddr, (0x1 << i));
            }
        }
    }
}

/**
 * This function is a generic interface for performing various control operations on a DMA channel,
 * such as setting or clearing the state, reading or writing control registers, etc.
 *
 * @param Channel Pointer to the DMA channel structure.
 * @param Cmd The command to execute.
 * @param Data Pointer to the data required for the command.
 * @return AL_S32 Returns 0 on success or an error code on failure.
 */
AL_S32 AlDmacAhb_Dev_IoCtl(AL_DMACAHB_ChStruct *Channel, AL_DMACAHB_IoCtlCmdEnum Cmd, AL_VOID *Data)
{
    AL_ASSERT((Channel != AL_NULL) && (Data != AL_NULL), AL_DMACAHB_ERR_NULL_PTR);

    switch (Cmd)
    {
    case AL_DMACAHB_IOCTL_FILL_LLI_WITH_CTL: {
        AL_DMACAHB_LliStruct *Lli = (AL_DMACAHB_LliStruct *)Data;
        AlDmacAhb_Dev_FillLliWithCtl(Channel, Lli);
    }
    case AL_DMACAHB_IOCTL_GET_STATE: {
        AL_DMACAHB_ChStateEnum *GetState = (AL_DMACAHB_ChStateEnum *)Data;
        *GetState = Channel->State;
        break;
    }
    case AL_DMACAHB_IOCTL_SET_STATE: {
        AL_DMACAHB_ChStateEnum SetState = *(AL_DMACAHB_ChStateEnum *)Data;
        AlDmacAhb_Dev_SetState(Channel, SetState);
        break;
    }
    case AL_DMACAHB_IOCTL_CLR_STATE: {
        AL_DMACAHB_ChStateEnum ClrState = *(AL_DMACAHB_ChStateEnum *)Data;
        AlDmacAhb_Dev_ClrState(Channel, ClrState);
        break;
    }
    case AL_DMACAHB_IOCTL_READ_CTL_LO_REG: {
        AL_DMACAHB_CtlLoUnion *ReadCtlLo = (AL_DMACAHB_CtlLoUnion *)Data;
        ReadCtlLo->Reg = AlDmacAhb_ll_ReadCtlLo(Channel->Dmac->BaseAddr, Channel->Param.ChBaseOffset);
        break;
    }
    case AL_DMACAHB_IOCTL_READ_CTL_HI_REG: {
        AL_DMACAHB_CtlHiUnion *ReadCtlHi = (AL_DMACAHB_CtlHiUnion *)Data;
        ReadCtlHi->Reg = AlDmacAhb_ll_ReadCtlHi(Channel->Dmac->BaseAddr, Channel->Param.ChBaseOffset);
        break;
    }
    case AL_DMACAHB_IOCTL_READ_CFG_LO_REG: {
        AL_DMACAHB_CfgLoUnion *ReadCfgLo = (AL_DMACAHB_CfgLoUnion *)Data;
        ReadCfgLo->Reg = AlDmacAhb_ll_ReadCfgLo(Channel->Dmac->BaseAddr, Channel->Param.ChBaseOffset);
        break;
    }
    case AL_DMACAHB_IOCTL_READ_CFG_HI_REG: {
        AL_DMACAHB_CfgHiUnion *ReadCfgHi = (AL_DMACAHB_CfgHiUnion *)Data;
        ReadCfgHi->Reg = AlDmacAhb_ll_ReadCfgHi(Channel->Dmac->BaseAddr, Channel->Param.ChBaseOffset);
        break;
    }
    case AL_DMACAHB_IOCTL_WRITE_CTL_LO_REG: {
        AL_DMACAHB_CtlLoUnion *WriteCtlLo = (AL_DMACAHB_CtlLoUnion *)Data;
        AlDmacAhb_ll_WriteCtlLo(Channel->Dmac->BaseAddr, Channel->Param.ChBaseOffset, WriteCtlLo->Reg);
        break;
    }
    case AL_DMACAHB_IOCTL_WRITE_CTL_HI_REG: {
        AL_DMACAHB_CtlHiUnion *WriteCtlHi = (AL_DMACAHB_CtlHiUnion *)Data;
        AlDmacAhb_ll_WriteCtlHi(Channel->Dmac->BaseAddr, Channel->Param.ChBaseOffset, WriteCtlHi->Reg);
        break;
    }
    case AL_DMACAHB_IOCTL_WRITE_CFG_LO_REG: {
        AL_DMACAHB_CfgLoUnion *WriteCfgLo = (AL_DMACAHB_CfgLoUnion *)Data;
        AlDmacAhb_ll_WriteCfgLo(Channel->Dmac->BaseAddr, Channel->Param.ChBaseOffset, WriteCfgLo->Reg);
        break;
    }
    case AL_DMACAHB_IOCTL_WRITE_CFG_HI_REG: {
        AL_DMACAHB_CfgHiUnion *WriteCfgHi = (AL_DMACAHB_CfgHiUnion *)Data;
        AlDmacAhb_ll_WriteCfgHi(Channel->Dmac->BaseAddr, Channel->Param.ChBaseOffset, WriteCfgHi->Reg);
        break;
    }
    case AL_DMACAHB_IOCTL_GET_PARAM_CHANNEL_0:
    case AL_DMACAHB_IOCTL_GET_PARAM_CHANNEL_1:
    case AL_DMACAHB_IOCTL_GET_PARAM_CHANNEL_2:
    case AL_DMACAHB_IOCTL_GET_PARAM_CHANNEL_3:
    case AL_DMACAHB_IOCTL_GET_PARAM_CHANNEL_4:
    case AL_DMACAHB_IOCTL_GET_PARAM_CHANNEL_5:
    case AL_DMACAHB_IOCTL_GET_PARAM_CHANNEL_6:
    case AL_DMACAHB_IOCTL_GET_PARAM_CHANNEL_7:{
        AL_DMACAHB_DmaCompChParamsUnion *ChParam = (AL_DMACAHB_DmaCompChParamsUnion *)Data;
        ChParam->Reg = AlDmacAhb_ll_ReadDmaCompChannelx(Channel->Dmac->BaseAddr,
                                                        (Cmd - AL_DMACAHB_IOCTL_GET_PARAM_CHANNEL_0));
        break;
    }
    case AL_DMACAHB_IOCTL_SET_CHANNEL_EN:{
        AL_BOOL IsChEn = *(AL_BOOL *)Data;
        AlDmacAhb_ll_SetChannelEn(Channel->Dmac->BaseAddr, Channel->Param.ChMask, IsChEn);
        break;
    }
    case AL_DMACAHB_IOCTL_SET_RELOAD_LAST_TRANS:{
        AL_BOOL IsSet = *(AL_BOOL *)Data;
        AlDmacAhb_ll_SetSrcAutoReload(Channel->Dmac->BaseAddr, Channel->Param.ChBaseOffset, ~IsSet);
        AlDmacAhb_ll_SetDstAutoReload(Channel->Dmac->BaseAddr, Channel->Param.ChBaseOffset, ~IsSet);
        break;
    }
    default:
        return AL_DMACAHB_ERR_IOCTL_CMD;
        break;
    }

    return AL_OK;
}

/**
 * This function maps a given DMA transaction type to a corresponding state. It is used to update
 * the state of a DMA channel based on the type of transaction it is set to perform.
 *
 * @param Type The DMA transaction type.
 * @param State Pointer to the state variable to be updated.
 * @return AL_S32 Returns AL_OK on success or AL_DMACAHB_ERR_ILLEGAL_PARAM if the type is not recognized.
 */
AL_S32 AlDmacAhb_Dev_TransTypeToState(AL_DMACAHB_TransTypeEnum Type, AL_DMACAHB_ChStateEnum *State)
{
    AL_ASSERT(State != AL_NULL, AL_DMACAHB_ERR_NULL_PTR);

    switch (Type)
    {
    case AL_DMACAHB_TRANS_TYPE_1:
    case AL_DMACAHB_TRANS_TYPE_5:
        *State = AL_DMACAHB_STATE_SINGLE_MODE_BUSY;
        break;
    case AL_DMACAHB_TRANS_TYPE_2:
    case AL_DMACAHB_TRANS_TYPE_3:
    case AL_DMACAHB_TRANS_TYPE_4:
        *State = AL_DMACAHB_STATE_RELOAD_MODE_BUSY;
        break;
    case AL_DMACAHB_TRANS_TYPE_6:
    case AL_DMACAHB_TRANS_TYPE_8:
    case AL_DMACAHB_TRANS_TYPE_10:
        *State = AL_DMACAHB_STATE_LLP_MODE_BUSY;
        break;
    case AL_DMACAHB_TRANS_TYPE_7:
    case AL_DMACAHB_TRANS_TYPE_9:
        *State = AL_DMACAHB_STATE_LLP_RELOAD_MODE_BUSY;
        break;
    default:
        return AL_DMACAHB_ERR_ILLEGAL_PARAM;
        break;
    }

    return AL_OK;
}

/**
 * This function attempts to acquire a lock necessary for performing DMA operations. It retries
 * until the lock is acquired or a timeout occurs.
 *
 * @param LockAddr The address of the lock to acquire.
 * @return AL_S32 Returns AL_OK on success or AL_DMACAHB_ERR_FETCH_LOCK if a timeout occurs.
 */
static AL_S32 AlDmacAhb_Dev_GetLock(AL_U32 LockAddr)
{
    AL_U32 Timeout = AL_DMACAHB_LOOP_REG_CNT_MAX;

    while ((!AlDmacAhb_ll_FetchLock(LockAddr)) && Timeout) {
        AL_DMACAHB_LOOP_REG_DELAY;
        Timeout--;
    }

    if (!Timeout) {
        AL_LOG(AL_LOG_LEVEL_ERROR, "Lock fetch timeout!\r\n");
        return AL_DMACAHB_ERR_FETCH_LOCK;
    }

    return AL_OK;
}

/**
 * This function attempts to allocate a DMA channel for use. It checks for channel availability,
 * requests a lock, and updates the channel state accordingly.
 *
 * @param HwConfig Pointer to the DMA hardware configuration structure.
 * @param RequestId The ID of the requested DMA channel.
 * @param AvailableId Pointer to the variable where the ID of the allocated channel will be stored.
 * @return AL_S32 Returns AL_OK on success,
 *         AL_DMACAHB_ERR_NONE_AVAILABLE_CH if no channel is available,
 *         or other error codes for different failures.
 */
AL_S32 AlDmacAhb_Dev_RequestCh(AL_DMACAHB_HwConfigStruct *HwConfig, AL_DMACAHB_ChIdEnum RequestId,
                               AL_DMACAHB_ChIdEnum *AvailableId)
{
    AL_S32 Ret = AL_OK;
    AL_ASSERT((HwConfig != AL_NULL) && (AvailableId != AL_NULL), AL_DMACAHB_ERR_NULL_PTR);

    if (RequestId > HwConfig->ChannelNum) {
        AL_LOG(AL_LOG_LEVEL_INFO, "Request channel Id is not support.\r\n");
    }

    Ret = AlDmacAhb_Dev_GetLock(HwConfig->LockAddress);
    if (Ret != AL_OK) {
        AL_LOG(AL_LOG_LEVEL_ERROR, "Request channel get lock fail.\r\n");
    }

    AL_U32 ChState = AlDmacAhb_ll_GetChannelState(HwConfig->ChStateAddr);
    if (ChState & AlDmacAhb_ChParam[RequestId].ChMask) {
        AL_LOG(AL_LOG_LEVEL_INFO, "Request channel Id is used!\r\n");
    } else {
        /* TODO: owner channel */
    }

    AL_LOG(AL_LOG_LEVEL_INFO, "Auto assign a channel!\r\n");

    AL_U32 i;
    for (i = 0; i < HwConfig->ChannelNum; i++) {
        if (!(ChState & AlDmacAhb_ChParam[i].ChMask)) {
            AlDmacAhb_ll_SetChannelState(HwConfig->ChStateAddr, (ChState | AlDmacAhb_ChParam[i].ChMask));
            AL_LOG(AL_LOG_LEVEL_INFO, "Assign an available channel %d!\r\n", i);
            *AvailableId = i;
            break;
        }
    }

    AlDmacAhb_ll_ReleaseLock(HwConfig->LockAddress);

    if (i == HwConfig->ChannelNum) {
        AL_LOG(AL_LOG_LEVEL_ERROR, "No available channel here!\r\n");
        return AL_DMACAHB_ERR_NONE_AVAILABLE_CH;
    }

    return AL_OK;
}

/**
 * This function releases a previously allocated DMA channel. It resets the channel state and
 * releases the lock associated with DMA operations.
 *
 * @param Channel Pointer to the DMA channel structure.
 * @return AL_S32 Returns AL_OK on success or other error codes for different failures.
 */
AL_S32 AlDmacAhb_Dev_ReleaseCh(AL_DMACAHB_ChStruct *Channel)
{
    AL_S32 Ret = AL_OK;

    AL_ASSERT(Channel != AL_NULL, AL_DMACAHB_ERR_NULL_PTR);

    Ret = AlDmacAhb_Dev_GetLock(Channel->Dmac->LockAddress);
    if (Ret != AL_OK) {
        AL_LOG(AL_LOG_LEVEL_ERROR, "Release channel get lock fail.\r\n");
    }

    AL_U32 ChState = AlDmacAhb_ll_GetChannelState(Channel->Dmac->ChStateAddr);

    AlDmacAhb_ll_SetChannelState(Channel->Dmac->ChStateAddr, (ChState & (~Channel->Param.ChMask)));

    AlDmacAhb_ll_ReleaseLock(Channel->Dmac->LockAddress);

    return AL_OK;
}

/**
 * This function clears the state of all DMA channels in a given DMA instance. It is typically
 * used during initialization or reset procedures.
 *
 * @param HwConfig Pointer to the DMA hardware configuration structure.
 * @return AL_S32 Returns AL_OK on success or other error codes for different failures.
 */
AL_S32 AlDmacAhb_Dev_ClrChannelState(AL_DMACAHB_HwConfigStruct *HwConfig)
{
    AL_ASSERT(HwConfig != AL_NULL, AL_ERR_NULL_PTR);

    AL_S32 Ret = AL_OK;
    AL_U32 DevId = HwConfig->DeviceId;

#ifdef __aarch64__
    if ((AlDmacAhb_DmacInstance[DevId].State.DmacEn == AL_FALSE) && (!(ARCH_SYSREG_READ(mpidr_el1) & 0xff))) {
#else
    if (AlDmacAhb_DmacInstance[DevId].State.DmacEn == AL_FALSE) {
#endif
        AlDmacAhb_DmacInstance[DevId].BaseAddr     = HwConfig->BaseAddress;
        AlDmacAhb_DmacInstance[DevId].DevId        = HwConfig->DeviceId;
        AlDmacAhb_DmacInstance[DevId].IntrId       = HwConfig->IntrId;
        AlDmacAhb_DmacInstance[DevId].ChannelNum   = HwConfig->ChannelNum;
        AlDmacAhb_DmacInstance[DevId].LockAddress  = HwConfig->LockAddress;
        AlDmacAhb_DmacInstance[DevId].ChStateAddr  = HwConfig->ChStateAddr;
        Ret = AlDmacAhb_Dev_GetLock(AlDmacAhb_DmacInstance[DevId].LockAddress);
        if (Ret != AL_OK) {
            AL_LOG(AL_LOG_LEVEL_ERROR, "Clear channel state get lock fail.\r\n");
        }

        AlDmacAhb_ll_ClrChannelState(AlDmacAhb_DmacInstance[DevId].ChStateAddr);

        AlDmacAhb_ll_ReleaseLock(AlDmacAhb_DmacInstance[DevId].LockAddress);
    }

    return AL_OK;
}
