#include "al_can_dev.h"
#include "al_errno.h"

/*intr state check*/
#define AL_CAN_RECV_INTR(Status)    (Status & AL_CAN_INTR_RIF)
#define AL_CAN_RB_INTR(Status)      (Status & (AL_CAN_INTR_RAFIF | AL_CAN_INTR_RFIF | \
                                    AL_CAN_INTR_ROIF))
#define AL_CAN_TRANS_INTR(Status)   (Status & (AL_CAN_INTR_TSIF | AL_CAN_INTR_TPIF))
#define AL_CAN_ERR_INTR(Status)     (Status & (AL_CAN_INTR_AIF | AL_CAN_INTR_EIF | \
                                    AL_CAN_INTR_BEIF | AL_CAN_INTR_ALIF | AL_CAN_INTR_EPIF))
/* Default Init config */
static AL_CAN_InitStruct CAN_DefInitConfig = {
    .Type           = AL_CAN_TYPE_FD,
    .OpsMode        = AL_CAN_MODE_NORMAL,
    .RunMode        = AL_CAN_RUN_INTR,
    .TransMode      = AL_CAN_TRANS_PTB,
    .SlowBitTiming  = AL_CAN_ARBITRATION__0_5M,
    .FastBitTiming  = AL_CAN__1_M,
    .RbAfwl         = AL_CAN_RB_LIMIT_8,
};

/* Default bit timing cofig with 80MHz */
static AL_U8 AL_CAN_DefBitTimArray[][4] = { \
    {64, 16, 16, 4}, {64, 16, 16, 2}, {32, 8, 8, 4}, {19, 5, 5, 4}, \
    {32, 8, 8, 2}, {20, 6, 6, 2}, {16, 4, 4, 2}, {10, 3, 3, 2}, \
    {16, 4, 4, 1}, {12, 4, 4, 1}, {10, 2, 2, 1}, {8, 2, 2, 1}, {6, 2, 2, 1}};

/* Data length in word catch up with DLC */
static AL_U8 AL_CAN_DataLenArray[] = {0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 4, 5, 6, 8, 12, 16};

/* Hardware config generated by TD */
extern AL_CAN_HwConfigStruct AlCan_HwConfig[];

/**
 * This function switch DLC to data size in word
 * @param   Dlc is Enum to DLC
 * @return  data size in word
 * @note
*/
static AL_U32 AlCan_Dev_Dlc2Len(AL_CAN_DataLenEnum Dlc)
{
    return AL_CAN_DataLenArray[Dlc];
}

/**
 * This function set CAN protocol type
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @param   Type is protocol of CAN with type AL_CAN_TypeEnum
 * @return  
 *          - AL_ERR_OK for successfully set
 * @note
*/
static AL_S32 AlCan_Dev_SetCanType(AL_CAN_DevStruct *Dev, AL_CAN_TypeEnum Type)
{
    if (Dev->Config.Type == Type) {
        return AL_ERR_OK; 
    }

    switch (Type) {
    case AL_CAN_TYPE_2_0B:
        AlCan_ll_SetFdEnabled(Dev->BaseAddr, AL_FALSE);
        Dev->Config.Type = AL_CAN_TYPE_2_0B;
        break;
    case AL_CAN_TYPE_FD:
        AlCan_ll_SetFdEnabled(Dev->BaseAddr, AL_TRUE);
        Dev->Config.Type = AL_CAN_TYPE_FD;
        break;
    default:
        Dev->Config.Type = AL_CAN_TYPE_NOT_SET;
        break;
    }

    return AL_ERR_OK;
}

/**
 * This function set CAN running mode
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @param   OpsMode is running mode with type AL_CAN_OpsModeEnum
 * @return  
 *          - AL_ERR_OK for successfully set
 * @note
*/
static AL_S32 AlCan_Dev_SetOpsMode(AL_CAN_DevStruct *Dev, AL_CAN_OpsModeEnum OpsMode)
{
    if (Dev->Config.OpsMode == OpsMode) {
        return AL_ERR_OK; 
    }

    switch (OpsMode) {
    case AL_CAN_MODE_NORMAL:
        // AlCan_ll_SetCanCtrlReset(Dev->BaseAddr, AL_TRUE);
        // AlCan_ll_SetCanCtrlReset(Dev->BaseAddr, AL_FALSE);
        // AlCan_Dev_WaitResetRelease(Dev);
        AlCan_ll_SetLbmi(Dev->BaseAddr, AL_FALSE);
        AlCan_ll_SetLbme(Dev->BaseAddr, AL_FALSE);
        Dev->Config.OpsMode |= AL_CAN_MODE_NORMAL;
        break;
    case AL_CAN_MODE_IN_LOOPBACK:
        AlCan_ll_SetLbmi(Dev->BaseAddr, AL_TRUE);
        Dev->Config.OpsMode |= AL_CAN_MODE_IN_LOOPBACK;
        break;
    case AL_CAN_MODE_EX_LOOPBACK:
        AlCan_ll_SetLbme(Dev->BaseAddr, AL_TRUE);
        Dev->Config.OpsMode |= AL_CAN_MODE_EX_LOOPBACK;
        break;
    case AL_CAN_MODE_LISTENONLY:
        AlCan_ll_SetLom(Dev->BaseAddr, AL_TRUE);
        Dev->Config.OpsMode |= AL_CAN_MODE_LISTENONLY;
        break;
    default:
        Dev->Config.OpsMode |= AL_CAN_MODE_NOT_SET;
        break;
    }

    return AL_ERR_OK;
}

/**
 * This function set CAN slow or fast speed bit timing patameter
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @param   Type is bit timing type to AL_CAN_BitTimingTypeEnum
 * @param   TimeSeg1 is pointer to bit timing segment 1
 * @param   TimeSeg2 is pointer to bit timing segment 2
 * @param   SyncJumpWidth is pointer to synchronization jump width
 * @return  
 * @note
*/
AL_VOID AlCan_Dev_SetBitTiming(AL_CAN_DevStruct *Dev, AL_CAN_BitTimingTypeEnum Type, \
    AL_U8 TimeSeg1, AL_U8 TimeSeg2, AL_U8 SyncJumpWidth)
{
    switch (Type)
    {
    case AL_CAN_BIT__2_0B__S:
    case AL_CAN_BIT__FD__S:
        AlCan_ll_SetSseg1(Dev->BaseAddr, TimeSeg1);
        AlCan_ll_SetSseg2(Dev->BaseAddr, TimeSeg2);
        AlCan_ll_SetSsjw(Dev->BaseAddr, SyncJumpWidth);
        break;
    case AL_CAN_BIT__FD__F:
        AlCan_ll_SetFseg1(Dev->BaseAddr, TimeSeg1);
        AlCan_ll_SetFseg2(Dev->BaseAddr, TimeSeg2);
        AlCan_ll_SetFsjw(Dev->BaseAddr, SyncJumpWidth);
        break;
    default:
        break;
    }
}

/**
 * This function get CAN slow or fast speed bit timing patameter
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @param   Type is bit timing type to AL_CAN_BitTimingTypeEnum
 * @param   TimeSeg1 is pointer to bit timing segment 1
 * @param   TimeSeg2 is pointer to bit timing segment 2
 * @param   SyncJumpWidth is pointer to synchronization jump width
 * @return  
 * @note
*/
AL_VOID AlCan_Dev_GetBitTiming(AL_CAN_DevStruct *Dev, AL_CAN_BitTimingTypeEnum Type, \
    AL_U8 *TimeSeg1, AL_U8 *TimeSeg2, AL_U8 *SyncJumpWidth)
{
    switch (Type)
    {
    case AL_CAN_BIT__2_0B__S:
    case AL_CAN_BIT__FD__S:
        *TimeSeg1       = (AL_U8)AlCan_ll_GetSseg1(Dev->BaseAddr);
        *TimeSeg2       = (AL_U8)AlCan_ll_GetSseg2(Dev->BaseAddr);
        *SyncJumpWidth  = (AL_U8)AlCan_ll_GetSsjw(Dev->BaseAddr);
        break;
    case AL_CAN_BIT__FD__F:
        *TimeSeg1       = (AL_U8)AlCan_ll_GetFseg1(Dev->BaseAddr);
        *TimeSeg2       = (AL_U8)AlCan_ll_GetFseg2(Dev->BaseAddr);
        *SyncJumpWidth  = (AL_U8)AlCan_ll_GetFsjw(Dev->BaseAddr);
        break;
    default:
        break;
    }
}

/**
 * This function set CAN slow or fast speed system clock prescaler
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @param   Type is bit timing type to AL_CAN_BitTimingTypeEnum
 * @param   Prescaler is to divides the system clock to get the time quanta clock
 * @return  
 * @note
*/
AL_VOID AlCan_Dev_SetBaudRatePrescaler(AL_CAN_DevStruct *Dev, AL_CAN_BitTimingTypeEnum Type, \
    AL_U8 Prescaler)
{
    switch (Type)
    {
    case AL_CAN_BIT__2_0B__S:
    case AL_CAN_BIT__FD__S:
        AlCan_ll_SetSpresc(Dev->BaseAddr, Prescaler);
        break;
    case AL_CAN_BIT__FD__F:
        AlCan_ll_SetFpresc(Dev->BaseAddr, Prescaler);
        break;
    default:
        break;
    }
    
}

/**
 * This function get CAN slow or fast speed system clock prescaler
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @param   Type is bit timing type to AL_CAN_BitTimingTypeEnum
 * @return  system clock Prescaler to get the time quanta clock
 * @note
*/
AL_U8 AlCan_Dev_GetBaudRatePrescaler(AL_CAN_DevStruct *Dev, AL_CAN_BitTimingTypeEnum Type)
{
    switch (Type)
    {
    case AL_CAN_BIT__2_0B__S:
    case AL_CAN_BIT__FD__S:
        return AlCan_ll_GetSpresc(Dev->BaseAddr);
        break;
    case AL_CAN_BIT__FD__F:
        return AlCan_ll_GetFpresc(Dev->BaseAddr);
        break;
    default:
        break;
    }
    
}

/**
 * This function set CAN default config bit timing parameter
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @param   Type is bit timing type with AL_CAN_BitTimingTypeEnum
 * @param   BitTiming is bit timing parameter with AL_CAN_BitTimingEnum
 * @return
 * @note
*/
AL_VOID AlCan_Dev_SetDefBitTimingAndPrescaler(AL_CAN_DevStruct *Dev, \
    AL_CAN_BitTimingTypeEnum Type, AL_CAN_BitTimingEnum BitTiming)
{
    AlCan_Dev_SetBitTiming(Dev->BaseAddr, Type, AL_CAN_DefBitTimArray[BitTiming][0], \
        AL_CAN_DefBitTimArray[BitTiming][1], AL_CAN_DefBitTimArray[BitTiming][2]);
    AlCan_Dev_SetBaudRatePrescaler(Dev->BaseAddr, Type, AL_CAN_DefBitTimArray[BitTiming][3]);

    if (Type == AL_CAN_BIT__FD__F) {
        AlCan_ll_SetSspoff(Dev->BaseAddr, AL_CAN_DefBitTimArray[BitTiming][0]);
        AlCan_ll_SetTdcen(Dev->BaseAddr, AL_TRUE);
        Dev->Config.FastBitTiming = BitTiming;
    } else {
        Dev->Config.SlowBitTiming = BitTiming;
    }
}

/**
 * This function set CAN transmit mode
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @param   TransMode is transmit mode with AL_CAN_TransModeEnum
 * @return
 * @note
*/
static AL_VOID AlCan_Dev_SetTransMode(AL_CAN_DevStruct *Dev, AL_CAN_TransModeEnum TransMode)
{
    switch (TransMode)
    {
    case AL_CAN_TRANS_PTB:
        AlCan_ll_SetTbsel(Dev->BaseAddr, AL_CAN_TBSEL_PTB);
        Dev->Config.TransMode = AL_CAN_TRANS_PTB;
        break;
    case AL_CAN_TRANS_STB_FIFO:
        AlCan_ll_SetTbsel(Dev->BaseAddr, AL_CAN_TBSEL_STB);
        AlCan_ll_SetTsmode(Dev->BaseAddr, AL_CAN_TSMODE_FIFO);
        Dev->Config.TransMode = AL_CAN_TRANS_STB_FIFO;
        break;
    case AL_CAN_TRANS_STB_PRIO:
        AlCan_ll_SetTbsel(Dev->BaseAddr, AL_CAN_TBSEL_STB);
        AlCan_ll_SetTsmode(Dev->BaseAddr, AL_CAN_TSMODE_PRIORITY);
        Dev->Config.TransMode = AL_CAN_TRANS_STB_PRIO;
        break;
    case AL_CAN_TRANS_FULL:
        break;
    default:
        break;
    }
}

/**
 * This function get module status
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @param   State is enum to AL_CAN_StateEnum
 * @return  current is tx busy or not
 * @note
*/
AL_BOOL AlCan_Dev_GetState(AL_CAN_DevStruct *Dev, AL_CAN_StateEnum State)
{
    return (Dev->State & State);
}

/**
 * This function set module status
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @param   State is enum to AL_CAN_StateEnum
 * @return  
 * @note
*/
AL_VOID AlCan_Dev_SetState(AL_CAN_DevStruct *Dev, AL_CAN_StateEnum State)
{
    Dev->State |= State;
}

/**
 * This function clr module status
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @param   State is enum to AL_CAN_StateEnum
 * @return  
 * @note
*/
AL_VOID AlCan_Dev_ClrState(AL_CAN_DevStruct *Dev, AL_CAN_StateEnum State)
{
    Dev->State &= ~State;
}

/**
 * This function is recv interrupt handler
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @param   IntrStatus is interrupt register status
 * @return
 * @note
*/
static AL_VOID AlCan_Dev_RecvFrameHandler(AL_CAN_DevStruct *Dev, AL_U32 IntrStatus)
{
    /* IP has if loop buffer, so nothing to do here */
    AlCan_Dev_ClrState(Dev, AL_CAN_STATE_RECV_EMPTY);
    AL_CAN_EventStruct Event = {
        .EventId    = AL_CAN_EVENT_RECV_DONE,
        .EventData  = AL_NULL
    };
    Dev->EventCallBack.Func(&Event, Dev->EventCallBack.Ref);

}

/**
 * This function is send frame done handler
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @param   IntrStatus is interrupt register status
 * @return
 * @note
*/
static AL_VOID AlCan_Dev_SendFrameHandler(AL_CAN_DevStruct *Dev, AL_U32 IntrStatus)
{
    AL_CAN_EventStruct Event = {
        .EventId    = AL_CAN_EVENT_SEND_DONE,
        .EventData  = AL_NULL
    };
    AlCan_Dev_ClrState(Dev, AL_CAN_STATE_SEND_BUSY);
    Dev->EventCallBack.Func(&Event, Dev->EventCallBack.Ref);
}

/**
 * This function is error interrupt handler
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @param   IntrStatus is interrupt register status
 * @return
 * @note
*/
static AL_VOID AlCan_Dev_ErrHandler(AL_CAN_DevStruct *Dev, AL_U32 IntrStatus)
{
    AL_CAN_EventStruct Event;

    if (IntrStatus & AL_CAN_INTR_AIF) {
        Event.EventId   = AL_CAN_EVENT_ABORT;
        Event.EventData = AL_NULL;
    }

    if (IntrStatus & AL_CAN_INTR_EIF) {
        Event.EventId   = AL_CAN_EVENT_ERR;
        Event.EventData = AL_NULL;
    }

    if (IntrStatus & AL_CAN_INTR_BEIF) {
        if (Dev->Config.OpsMode == AL_CAN_MODE_LISTENONLY) {
            AL_LOG(AL_ERR_LEVEL_DEBUG, "can bus error with listen only mode: 0x%x!\r\n", \
                AlCan_ll_GetKoer(Dev->BaseAddr));
            AlCan_Dev_GetDecodeError(Dev);
        }

        Event.EventId   = AL_CAN_EVENT_BUS_ERR;
        Event.EventData = AL_NULL;
    }

    if (IntrStatus & AL_CAN_INTR_ALIF) {
        Event.EventId   = AL_CAN_EVENT_ARBITRATION_LOST;
        Event.EventData = AL_NULL;
    }

    if (IntrStatus & AL_CAN_INTR_EPIF) {
        Event.EventId   = AL_CAN_EVENT_ERR_PASSIVE;
        Event.EventData = AL_NULL;
    }

    AlCan_Dev_ClrState(Dev, AL_CAN_STATE_READY);
    Dev->EventCallBack.Func(&Event, Dev->EventCallBack.Ref);
}

/**
 * This function is intr event handler
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @param   IntrStatus is interrupt register status
 * @return
 * @note
*/
static AL_VOID AlCan_Dev_EventHandler(AL_CAN_DevStruct *Dev, AL_U32 IntrStatus)
{
    AL_CAN_EventStruct Event;

    if (IntrStatus & AL_CAN_INTR_RAFIF) {
        AlCan_Dev_SetState(Dev, AL_CAN_STATE_RECV_ALMOST_FULL);
        Event.EventId   = AL_CAN_EVENT_RBUFF_ALMOST_FULL;
        Event.EventData = AL_NULL;
    }

    if (IntrStatus & AL_CAN_INTR_RFIF) {
        AlCan_Dev_SetState(Dev, AL_CAN_STATE_RECV_FULL);
        Event.EventId   = AL_CAN_EVENT_RBUFF_FULL;
        Event.EventData = AL_NULL;
    }

    if (IntrStatus & AL_CAN_INTR_ROIF) {
        AlCan_Dev_SetState(Dev, AL_CAN_STATE_RECV_OVERFLOW);
        Event.EventId   = AL_CAN_EVENT_RBUFF_OVERFLOW;
        Event.EventData = AL_NULL;
    }

    Dev->EventCallBack.Func(&Event, Dev->EventCallBack.Ref);
}

/**
 * This function is intr call back
 * @param   Instance is pointer to intr call back reference
 * @return
 * @note
*/
AL_VOID AlCan_Dev_IntrHandler(void *Instance)
{
    AL_CAN_DevStruct *Dev = (AL_CAN_DevStruct *)Instance;
    AL_U32 IntrStatus = AlCan_ll_GetUmaskIntrStatus(Dev->BaseAddr);

    if (AL_CAN_ERR_INTR(IntrStatus)) {
#ifdef CAN_DEBUG
        /**
         * TODO: handle error status
        */
        AlCan_Dev_ErrHandler(Dev, IntrStatus);
#endif
    }

    if (AL_CAN_RECV_INTR(IntrStatus)) {
        AlCan_Dev_RecvFrameHandler(Dev, IntrStatus);
    }

    if (AL_CAN_RB_INTR(IntrStatus)) {
        /**
         * TODO: handle recv buffer intr status
        */
       AlCan_Dev_EventHandler(Dev, IntrStatus);
    }

    if (AL_CAN_TRANS_INTR(IntrStatus)) {
        AlCan_Dev_SendFrameHandler(Dev, IntrStatus);
    }

    AlCan_ll_ClrIntrStatus(Dev->BaseAddr);
}

/**
 * This function register interrupt call back function
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @param   CallBack is call back struct with AL_CAN_CallBackStruct
 * @return
 *          - AL_ERR_OK is register correct
 * @note
*/
AL_S32 AlCan_Dev_RegisterEventCallBack(AL_CAN_DevStruct *Dev, AL_CAN_CallBackStruct *CallBack)
{
    if (Dev == AL_NULL || CallBack == AL_NULL) {
        return AL_DEF_ERR(AL_CAN, AL_ERR_LEVEL_ERROR, AL_ERR_ILLEGAL_PARAM);
    }

    if (Dev->EventCallBack.Func != AL_NULL) {

#ifdef CAN_DEBUG
        AL_LOG(AL_ERR_LEVEL_WARNING, "can=%p duplicate register callback: replace old:%p with New: %p\r\n", \
                Dev, Dev->EventCallBack, CallBack);
#endif
    }

    Dev->EventCallBack.Func = CallBack->Func;
    Dev->EventCallBack.Ref  = CallBack->Ref;

    return AL_ERR_OK;
}

/**
 * This function unregister interrupt call back function
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @return
 *          - AL_ERR_OK is register correct
 * @note
*/
AL_S32 AlCan_Dev_UnRegisterEventCallBack(AL_CAN_DevStruct *Dev)
{
    if (Dev == AL_NULL) {
        return AL_DEF_ERR(AL_CAN, AL_ERR_LEVEL_ERROR, AL_ERR_ILLEGAL_PARAM);
    }

    Dev->EventCallBack.Func = (AL_CAN_EventCallBack)AL_NULL;

    return AL_ERR_OK;
}

/**
 * This function look up hardware config structure
 * @param   DeviceId is hardware module id
 * @return  hardware config structure with AL_CAN_HwConfigStruct
 * @note
*/
AL_CAN_HwConfigStruct *AlCan_Dev_LookupConfig(AL_U32 DeviceId)
{
	AL_U32 Index;
	AL_CAN_HwConfigStruct *CfgPtr = AL_NULL;

	for (Index = 0; Index < AL_CAN_NUM_INSTANCE; Index++) {
		if (AlCan_HwConfig[Index].DeviceId == DeviceId) {
			CfgPtr = &AlCan_HwConfig[Index];
			break;
		}
	}

	return CfgPtr;
}

/**
 * This function set module in reset mode
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @param   IsReset is reset or not
 * @return
 * @note
*/
AL_VOID AlCan_Dev_SetReset(AL_CAN_DevStruct *Dev, AL_BOOL IsReset)
{
    AlCan_ll_SetCanCtrlReset(Dev->BaseAddr, IsReset);
    if (IsReset == AL_TRUE) {
        Dev->State = AL_CAN_STATE_RESET;
    } else {
        Dev->State &= ~AL_CAN_STATE_RESET;
    }
}

/**
 * This function init CAN module
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @param   HwConfig is hardware config structure with AL_CAN_HwConfigStruct
 * @param   InitConfig is module config structure with AL_CAN_InitStruct
 * @return
 *          - AL_ERR_OK is init done
 * @note
*/
AL_S32 AlCan_Dev_Init(AL_CAN_DevStruct *Dev, AL_CAN_HwConfigStruct *HwConfig, \
    AL_CAN_InitStruct *InitConfig)
{
    AL_CAN_InitStruct *Config;

    if (InitConfig == AL_NULL) {
#ifdef CAN_DEBUG
        AL_LOG(AL_ERR_LEVEL_INFO, "can=%p Init setting is AL_NULL, use default setting", Dev);
#endif
        Config = &CAN_DefInitConfig;
    } else {
        Config = InitConfig;
    }

    Dev->BaseAddr       = HwConfig->BaseAddress;

    AlCan_Dev_SetCanType(Dev, Config->Type);
    AlCan_Dev_SetReset(Dev, AL_TRUE);

    if (Config->TransMode == AL_CAN_TRANS_PTB) {
        AlCan_ll_SetTpss(Dev->BaseAddr, AL_TRUE);
    } else {
        AlCan_ll_SetTsss(Dev->BaseAddr, AL_TRUE);
    }

    if (Config->RunMode & (AL_CAN_RUN_INTR | AL_CAN_RUN_INTR_DMA)) {
        AlCan_ll_SetAllIntrEnabled(Dev->BaseAddr, AL_TRUE);
    } else {
        AlCan_ll_SetAllIntrEnabled(Dev->BaseAddr, AL_FALSE);
    }

    AlCan_Dev_SetDefBitTimingAndPrescaler(Dev, AL_CAN_BIT__FD__S, Config->SlowBitTiming);
    if (Config->Type == AL_CAN_TYPE_FD) {
        AlCan_Dev_SetDefBitTimingAndPrescaler(Dev, AL_CAN_BIT__FD__F, Config->FastBitTiming);
    }
    
    AlCan_Dev_SetOpsMode(Dev, Config->OpsMode);
    AlCan_Dev_SetTransMode(Dev, Config->TransMode);
    AlCan_ll_SetAfwl(Dev->BaseAddr, Config->RbAfwl);
    AlCan_ll_SetAcfen(Dev->BaseAddr, AL_FALSE);
    AlCan_Dev_SetReset(Dev, AL_FALSE);

    Dev->State |= AL_CAN_STATE_READY;

    /* TODO: wait for modify, delay for host controler reset release ready */
    for(volatile AL_U32 i = 0; i < 10000; i++){

    }

    return AL_ERR_OK;
}

/**
 * This function get module send busy status
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @return  current is tx busy or not
 * @note
*/
// AL_BOOL AlCan_Dev_IsSendBusy(AL_CAN_DevStruct *Dev)
// {
//     return (Dev->State & AL_CAN_STATE_SEND_BUSY);
// }

/**
 * This function get module recv busy status
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @return  current is rx done or not
 * @note
*/
// AL_BOOL AlCan_Dev_IsRecvBusy(AL_CAN_DevStruct *Dev)
// {
//     return (Dev->State & AL_CAN_STATE_RECV_BUSY);
// }

/**
 * This function set module send busy status
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @return  
 * @note
*/
// AL_VOID AlCan_Dev_SetSendBusy(AL_CAN_DevStruct *Dev)
// {
//     Dev->State |= AL_CAN_STATE_SEND_BUSY;
// }

/**
 * This function set module recv busy status
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @return  
 * @note
*/
// AL_VOID AlCan_Dev_SetRecvBusy(AL_CAN_DevStruct *Dev)
// {
//     Dev->State |= AL_CAN_STATE_RECV_BUSY;
// }

/**
 * This function clr module send busy status
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @return  
 * @note
*/
// AL_VOID AlCan_Dev_ClrSendBusy(AL_CAN_DevStruct *Dev)
// {
//     Dev->State &= ~AL_CAN_STATE_SEND_BUSY;
// }

/**
 * This function clr module recv busy status
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @return  
 * @note
*/
// AL_VOID AlCan_Dev_ClrRecvBusy(AL_CAN_DevStruct *Dev)
// {
//     Dev->State &= ~AL_CAN_STATE_RECV_BUSY;
// }

/**
 * This function send frame
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @param   Frame is tx buffer data with AL_CAN_FrameStruct
 * @return  
 *          - AL_ERR_OK is send done
 * @note
*/
AL_S32 AlCan_Dev_SendFrame(AL_CAN_DevStruct *Dev, AL_CAN_FrameStruct *Frame)
{
    AL_U32 Id, Ctrl;
    AL_U32 DataWordSize;
    AL_U32 i;

    if (Dev == AL_NULL || Frame == AL_NULL) {
        return AL_DEF_ERR(AL_CAN, AL_ERR_LEVEL_ERROR, AL_ERR_ILLEGAL_PARAM);
    }

    if (Frame->DataLen >= AL_CAN_LEN_MAX) {
        return AL_DEF_ERR(AL_CAN, AL_ERR_LEVEL_ERROR, AL_ERR_ILLEGAL_PARAM);
    }

    if (~AlCan_Dev_GetState(Dev, AL_CAN_STATE_READY)) {
        return AL_CAN_ERR_STATE_NOT_READY;
    }

    if (AlCan_Dev_GetState(Dev, AL_CAN_STATE_SEND_BUSY)) {
        return AL_DEF_ERR(AL_CAN, AL_ERR_LEVEL_ERROR, AL_ERR_BUSY);
    }

    Id = Frame->Id;
    Id |= (Frame->IsEnTts << CAN__TBUF_0_3__TTSEN__SHIFT);
    
    AlCan_ll_WriteWordSendBuffer(Dev->BaseAddr, 0, Id);

    Ctrl = Frame->DataLen & 0xF;

    if (Dev->Config.Type == AL_CAN_TYPE_FD) {
        Ctrl |= ((Frame->IsBitSwitch & 0x1) << CAN__TBUF_4_7__BRS__SHIFT) | \
            (0x1 << CAN__TBUF_4_7__FDF__SHIFT);
    } else {
        Ctrl |= (Frame->IsRemote << CAN__TBUF_4_7__RTR__SHIFT);
    }

    Ctrl |= ((Frame->IsIdExt == AL_TRUE) ? 0x1 : 0x0 ) << CAN__TBUF_4_7__IDE__SHIFT;
    
    AlCan_ll_WriteWordSendBuffer(Dev->BaseAddr, 1, Ctrl);

    for (AL_U32 i = 0; i < AL_CAN_DataLenArray[Frame->DataLen]; i++) {
        AlCan_ll_WriteWordSendBuffer(Dev->BaseAddr, (2 + i), Frame->Data[i]);
    }

    if (AlCan_ll_IsStby(Dev->BaseAddr)) {
        AlCan_ll_SetStby(Dev->BaseAddr, AL_FALSE);
        /* TODO: need delay a while for transceiver to start up */
    }

    switch (Dev->Config.TransMode)
    {
    case AL_CAN_TRANS_PTB:
        AlCan_ll_SetTpe(Dev->BaseAddr);
        break;
    case AL_CAN_TRANS_STB_FIFO:
    case AL_CAN_TRANS_STB_PRIO:
        AlCan_ll_SetTsone(Dev->BaseAddr);
        break;
    default:
        break;
    }

    AlCan_Dev_SetState(Dev, AL_CAN_STATE_SEND_BUSY);

    return AL_ERR_OK;
}

/**
 * This function decode a received frame
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @param   Frame is pointer to store frame buffer with AL_CAN_FrameStruct
 * @return  
 *          - AL_ERR_OK is send done
 * @note
*/
AL_S32 AlCan_Dev_RecvFrame(AL_CAN_DevStruct *Dev, AL_CAN_FrameStruct *Frame)
{
    AL_U32 RxBuf;
    AL_CAN_FrameCtrlUnion Ctrl;
    AL_U32 DataWordLen;

    if (Dev == AL_NULL || Frame == AL_NULL) {
        return AL_DEF_ERR(AL_CAN, AL_ERR_LEVEL_ERROR, AL_ERR_ILLEGAL_PARAM);
    }

    if (~AlCan_Dev_GetState(Dev, AL_CAN_STATE_READY)) {
        return AL_CAN_ERR_STATE_NOT_READY;
    }

    if (AlCan_Dev_GetState(Dev, AL_CAN_STATE_RECV_EMPTY)) {
        return AL_CAN_ERR_RECV_EMPTY;
    }

    Ctrl.Reg = AlCan_ll_ReadWordRecvBuffer(Dev->BaseAddr, 1);

    Frame->Koer         = Ctrl.Bit.Koer;
    if (Frame->Koer != AL_CAN_KOER_NONE) {
        return AL_DEF_ERR(AL_CAN, AL_ERR_LEVEL_ERROR, AL_CAN_ERR_RECV);
    }
    Frame->IsIdExt      = Ctrl.Bit.Ide;
    Frame->DataLen      = Ctrl.Bit.Dlc;
    Frame->IsBitSwitch  = Ctrl.Bit.Brs;
    Frame->IsRemote     = Ctrl.Bit.Rtr;
    
    Frame->Id = AlCan_ll_GetRecvExtId(Dev->BaseAddr, Frame->IsIdExt);
    DataWordLen = AlCan_Dev_Dlc2Len(Frame->DataLen);
    for (AL_U32 i = 0; i < DataWordLen; i++) {
        Frame->Data[i] = AlCan_ll_ReadWordRecvBuffer(Dev->BaseAddr, (2 + i));
    }

    AlCan_ll_SetRrel(Dev->BaseAddr, AL_CAN_RREL_RELEASE);

    if (AlCan_ll_GetRstat(Dev->BaseAddr) == AL_CAN_RSTAT_EMPTY) {
        AlCan_Dev_SetState(Dev, AL_CAN_STATE_RECV_EMPTY);
    }
    
    return AL_ERR_OK;
}

/**
 * This function set filter parameter
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @param   FilterCfg is pointer to filter configuration with AL_CAN_FilterCfgStruct
 * @return  
 *          - AL_ERR_OK is send done
 * @note
*/
AL_S32 AlCan_Dev_SetFilter(AL_CAN_DevStruct *Dev, AL_CAN_FilterCfgStruct *FilterCfg)
{
    if (!AlCan_ll_IsAcfenx(Dev->BaseAddr, FilterCfg->FilterIndex)) {
        AlCan_ll_SetAcfenx(Dev->BaseAddr, FilterCfg->FilterIndex, AL_TRUE);
    } else {
        /* TODO: Filter has enabled, should do somthing */
    }

    AlCan_ll_SetAcfadr(Dev->BaseAddr, FilterCfg->FilterIndex);
    AlCan_ll_SetSelmask(Dev->BaseAddr, AL_CAN_SELMASK_ACCEPT_MASK);
    AlCan_ll_WriteAcodexAmaskx(Dev->BaseAddr, (FilterCfg->MaskValue | \
        (FilterCfg->MaskType << CAN__ACF_3__ACF_2__ACF_1__ACF_0__AIDE__SHIFT)));
    AlCan_ll_SetSelmask(Dev->BaseAddr, AL_CAN_SELMASK_ACCEPT_CODE);
    AlCan_ll_WriteAcodexAmaskx(Dev->BaseAddr, FilterCfg->IdValue);

    return AL_ERR_OK;
}

/**
 * This function get filter parameter
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @param   FilterCfg is pointer to store filter configuration with AL_CAN_FilterCfgStruct
 * @return  
 *          - AL_ERR_OK is send done
 * @note
*/
AL_S32 AlCan_Dev_GetFilter(AL_CAN_DevStruct *Dev, AL_CAN_FilterCfgStruct *FilterCfg)
{
    AL_U32 Value;

    if (!AlCan_ll_IsAcfenx(Dev->BaseAddr, FilterCfg->FilterIndex)) {
        return AL_DEF_ERR(AL_CAN, AL_ERR_LEVEL_ERROR, AL_ERR_ILLEGAL_PARAM);
    }

    AlCan_ll_SetAcfadr(Dev->BaseAddr, FilterCfg->FilterIndex);
    AlCan_ll_SetSelmask(Dev->BaseAddr, AL_CAN_SELMASK_ACCEPT_MASK);
    Value = AlCan_ll_ReadAcodexAmaskx(Dev->BaseAddr);
    FilterCfg->MaskValue = Value & (CAN__ACF_3__ACF_2__ACF_1__ACF_0__ACODE_AMASK_7_0__MASK | \
        CAN__ACF_3__ACF_2__ACF_1__ACF_0__ACODE_AMASK_15_8__MASK | \
        CAN__ACF_3__ACF_2__ACF_1__ACF_0__ACODE_AMASK_23_16__MASK | \
        CAN__ACF_3__ACF_2__ACF_1__ACF_0__ACODE_AMASK_28_24__MASK);
    FilterCfg->MaskType = (Value & (CAN__ACF_3__ACF_2__ACF_1__ACF_0__AIDE__MASK | \
        CAN__ACF_3__ACF_2__ACF_1__ACF_0__AIDEE__MASK)) >> \
        CAN__ACF_3__ACF_2__ACF_1__ACF_0__AIDE__SHIFT;
    AlCan_ll_SetSelmask(Dev->BaseAddr, AL_CAN_SELMASK_ACCEPT_CODE);
    FilterCfg->IdValue = AlCan_ll_ReadAcodexAmaskx(Dev->BaseAddr);

    return AL_ERR_OK;
}

/**
 * This function get filter parameter
 * @param   Dev is pointer to AL_CAN_DevStruct
 * @return  
 *          - AL_ERR_OK is send done
 * @note
*/
AL_S32 AlCan_Dev_GetDecodeError(AL_CAN_DevStruct *Dev)
{
    AL_CAN_KoerEnum State;
    if (Dev == AL_NULL) {
        return AL_DEF_ERR(AL_CAN, AL_ERR_LEVEL_ERROR, AL_ERR_ILLEGAL_PARAM);
    }

    State = AlCan_ll_GetKoer(Dev->BaseAddr);

    switch (State)
    {
    case AL_CAN_KOER_NONE:
        AL_LOG(AL_ERR_LEVEL_INFO, "CAN success reception!\r\n");
        break;
    case AL_CAN_KOER_BIT:
        AL_LOG(AL_ERR_LEVEL_ERROR, "CAN bit error!\r\n");
        // if (Dev->State == AL_CAN_STATE_RECV_BUSY) {
        //     AL_LOG(AL_ERR_LEVEL_DEBUG, "CAN recv bit error, only in ACK slot, data valid!\r\n");
        //     return AL_CAN_ERR_KOER_RECV_BIT;
        // } else {
        //     AL_LOG(AL_ERR_LEVEL_DEBUG, "CAN send bit error, data invalid!\r\n");
        //     return AL_CAN_ERR_KOER_SEND_BIT;
        // }
        break;
    case AL_CAN_KOER_FORM:
        AL_LOG(AL_ERR_LEVEL_ERROR, "CAN form error!\r\n");
        return AL_CAN_ERR_KOER_FORM;
        break;
    case AL_CAN_KOER_STUFF:
        AL_LOG(AL_ERR_LEVEL_ERROR, "CAN stuff error!\r\n");
        // if (Dev->State == AL_CAN_STATE_RECV_BUSY) {
        //     AL_LOG(AL_ERR_LEVEL_DEBUG, "CAN recv stuff error, data invalid!\r\n");
        //     return AL_CAN_ERR_KOER_RECV_STUFF;
        // } else {
        //     AL_LOG(AL_ERR_LEVEL_DEBUG, "CAN send stuff error, only happen during arbitration, \
        //         data invalid!\r\n");
        //     return AL_CAN_ERR_KOER_SEND_STUFF;
        // }
        break;
    case AL_CAN_KOER_ACK:
        AL_LOG(AL_ERR_LEVEL_ERROR, "CAN ack error!\r\n");
        // if (Dev->State == AL_CAN_STATE_RX_BUSY) {
        //     AL_LOG(AL_ERR_LEVEL_DEBUG, "CAN recv ack error, only in LOM, data valid!\r\n");
        //     return AL_CAN_ERR_KOER_RECV_ACK;
        // } else {
        //     AL_LOG(AL_ERR_LEVEL_DEBUG, "CAN send ack error, only loop back without self-ack, \
        //         data valid!\r\n");
        //     return AL_CAN_ERR_KOER_SEND_ACK;
        // }
        break;
    case AL_CAN_KOER_CRC:
        AL_LOG(AL_ERR_LEVEL_ERROR, "CAN crc error, data invalid!\r\n");
        return AL_CAN_ERR_KOER_CRC;
        break;
    case AL_CAN_KOER_OTHER:
        AL_LOG(AL_ERR_LEVEL_ERROR, "CAN other error!\r\n");
        return AL_CAN_ERR_KOER_OTHER;
        break;
    default :
        AL_LOG(AL_ERR_LEVEL_ERROR, "CAN wrong KOER parameter\r\n");
        return AL_CAN_ERR_WRONG_KOER_PARAMETER;
        break;
    }

    return AL_ERR_OK;
}

#ifdef CAN_DEBUG
/**
 * This function display received frame
 * @param   Frame is pointer to received buffer with AL_CAN_FrameStruct
 * @return  
 *          - AL_ERR_OK is send done
 * @note
*/
AL_S32 AlCan_Dev_DisplayFrame(AL_CAN_FrameStruct *Frame)
{
    AL_U32 DataWordLen;
    AL_LOG(AL_ERR_LEVEL_INFO, "-------Recv Frame--------\r\n");
    AL_LOG(AL_ERR_LEVEL_INFO, "| Id: 0x%08x\r\n", Frame->Id);
    AL_LOG(AL_ERR_LEVEL_INFO, "| Data len: 0x%08x\r\n", Frame->DataLen);
    if (Frame->IsIdExt == AL_TRUE) {
        AL_LOG(AL_ERR_LEVEL_INFO, "| Extern Id\r\n");
    } else {
        AL_LOG(AL_ERR_LEVEL_INFO, "| Standard Id\r\n");
    }
    if (Frame->IsRemote == AL_TRUE) {
        AL_LOG(AL_ERR_LEVEL_INFO, "| Not remote frame\r\n");
    } else {
        AL_LOG(AL_ERR_LEVEL_INFO, "| Remote frame\r\n");
    }
    if (Frame->IsBitSwitch == AL_TRUE) {
        AL_LOG(AL_ERR_LEVEL_INFO, "| Switch fast bit rate\r\n");
    } else {
        AL_LOG(AL_ERR_LEVEL_INFO, "| Nominal bit rate\r\n");
    }
    DataWordLen = AlCan_Dev_Dlc2Len(Frame->DataLen);
    for (AL_U32 i = 0; i < DataWordLen; i++) {
        AL_LOG(AL_ERR_LEVEL_INFO, "| Data %02d: 0x%08x\r\n", i, Frame->Data[i]);
    }
    
    AL_LOG(AL_ERR_LEVEL_INFO, "-----Recv Frame Done-----\r\n");
}
#endif
