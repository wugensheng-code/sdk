
/*
 * main.c
 *
 *  Created on: 2021年11月10日
 *      Author: wei.pang
 */

#include <stdio.h>
#include <stdlib.h>
#include "nuclei_sdk_soc.h"
#include "al9000_uart.h"
#include "al9000_dmac.h"
#include "al9000_can.h"
#include <time.h>
uint8_t tx_buf1[64];
uint8_t tx_buf2[64];
uint8_t tx_buf3[64];
uint8_t tx_buf4[64];
uint8_t tx_buf5[64];
uint8_t rx_buf1[64];
uint8_t rx_buf2[64];
uint8_t rx_buf3[64];
uint8_t rx_buf4[64];
uint8_t rx_buf5[64];

void SOC_DMA_AHB_HANDLER(void)
{
    //printf("enter_irq_number%d\n\r",count); 
    //dma_interrupt_readfunction(LLP_BASE_ADDR);      
    dw_dmac_clearIrq(AL9000_DMAC,dw_dmac_channel_num_1,block_1);
}
int main(void){
	for (volatile uint8_t i = 0 ;i < 64 ; i++)
	{
		tx_buf1[i] = i;
		tx_buf2[i] = i+1;
		tx_buf3[i] = i+2;
		tx_buf4[i] = i+3;
		tx_buf5[i] = i+4;
	}
        __RV_CSR_CLEAR(CSR_MMISC_CTL,MMISC_CTL_BPU);
        set_reset_mode(AL9000_CAN0);
	set_reset_mode(AL9000_CAN1);
 #if 1
	/*mem2men mode
	 *If you want to use interrupts to count the number of blocks
 	 *You can open this part
 	 *But we do not recommend this
 	 *interrupts_count_blocks_mode will stay in interrupt fo a long time,reduce DMA efficiency
 	 *
 	 */
        ECLIC_Register_IRQ(SOC_INT65_IRQn, ECLIC_NON_VECTOR_INTERRUPT,ECLIC_LEVEL_TRIGGER, 1, 1,SOC_DMA_AHB_HANDLER);
	__enable_irq();
	/*
 	 *dw_dmac_enableChannelIrq()
 	 */
         dw_dmac_enableChannelIrq(AL9000_DMAC_channel_0,dw_dmac_channel_num_1);
	/*
	 *dw_dmac_unmaskIrq()
	 */
         dw_dmac_unmaskIrq(AL9000_DMAC,dw_dmac_channel_num_1,block_1);

    #endif
	canfd_device_driver_bittime_configuration(AL9000_CAN1,rate_5Mbit,AL9000_TOP0,can_fd);
	canfd_device_driver_bittime_configuration(AL9000_CAN0,rate_5Mbit,AL9000_TOP0,can_fd);
	can_tx_mode(AL9000_CAN0,NORMAL);
	can_tx_mode(AL9000_CAN1,NORMAL);
	set_canfd_xmit_mode(AL9000_CAN0,XMIT_PTB_MODE);
	set_canfd_xmit_mode(AL9000_CAN1,XMIT_PTB_MODE);
	Can_Send_Msg(AL9000_CAN1,tx_buf1,XMIT_PTB_MODE,data_length_8,0x10);
	//Can_Receive_Msg(AL9000_CAN0,rx_buf1,data_length_8);
	Can_Send_Msg(AL9000_CAN1,tx_buf2,XMIT_PTB_MODE,data_length_12,0x11);
	Can_Send_Msg(AL9000_CAN1,tx_buf2,XMIT_PTB_MODE,data_length_48,0x12);
	Can_Send_Msg(AL9000_CAN1,tx_buf2,XMIT_PTB_MODE,data_length_64,0x13);
	//Can_Receive_Msg(AL9000_CAN0,rx_buf2,data_length_8);
	can_dma_Init(AL9000_TOP0, can_fd, AL9000_CAN0);
        dw_dmac_enable(AL9000_DMAC);
        dw_dmac_enableChannel(AL9000_DMAC,dw_dmac_channel_num_1);
        while(1){
        	 //printf("OKOK\r\n");
        	 //printf("uart_dma_data %d\r\n",uart_read(AL9000_UART0));
        }
        	return 0;
}








